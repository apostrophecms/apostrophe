/* tslint:disable */
/* eslint-disable */
/**
 * ApostropheCMS REST API
 * **ðŸš€ The headless CMS that developers actually want to use**  **For production use:** Download this YAML file and update the server URL and cookie names to match your setup.  The ApostropheCMS REST API allows you to create, read, update, and delete content programmatically. Perfect for building modern websites, mobile apps, and any digital experience that needs flexible content management.  ## Quick Start Guide 1. **Authentication**: Use the login endpoint to get a bearer token or session cookie 2. **Get Content**: Start with `/@apostrophecms/page` to fetch your page structure 3. **Media Files**: Upload files via `/@apostrophecms/attachment/upload` 4. **Internationalization**: Use `/@apostrophecms/i18n` to localize your content  ## Content Architecture ApostropheCMS uses a flexible \"pieces\" system for content types. While the core system provides essential pieces like users and global content, most projects define custom piece types like articles, events, or products using the `@apostrophecms/piece-type` module.  ## Built-in Piece Types - `@apostrophecms/user` - User accounts and profiles - `@apostrophecms/global` - Site-wide content (customizable with additional fields) - `@apostrophecms/image` - Image file management - `@apostrophecms/file` - General file management (PDFs, documents, etc.)  ## Built-in Tag Types - `@apostrophecms/image-tag` - Tags for organizing images - `@apostrophecms/file-tag` - Tags for organizing files  ## Authentication Methods - **Bearer Token**: Recommended for API clients and SPAs - **Session Cookie**: For traditional web applications - **API Key**: For server-to-server communication  ## Rate Limiting API requests are rate-limited to prevent abuse. See response headers for current limits. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@apostrophecms.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * HTTP status code, e.g., 401
     * @type {number}
     * @memberof ApiError
     */
    'status'?: number;
    /**
     * Application error code (optional)
     * @type {string}
     * @memberof ApiError
     */
    'code'?: string;
    /**
     * Human-readable error message
     * @type {string}
     * @memberof ApiError
     */
    'message': string;
    /**
     * Extra context about the error
     * @type {{ [key: string]: any; }}
     * @memberof ApiError
     */
    'details'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface AreaField
 */
export interface AreaField {
    /**
     * Apostrophe field type id.
     * @type {string}
     * @memberof AreaField
     */
    'type': AreaFieldTypeEnum;
    /**
     * Human-readable label for editors.
     * @type {string}
     * @memberof AreaField
     */
    'label': string;
    /**
     * Short helper text shown in the UI.
     * @type {string}
     * @memberof AreaField
     */
    'help'?: string;
    /**
     * Rich helper text (HTML allowed by Apostrophe).
     * @type {string}
     * @memberof AreaField
     */
    'htmlHelp'?: string;
    /**
     * 
     * @type {any}
     * @memberof AreaField
     */
    'def'?: any;
    /**
     * If true, value must be provided.
     * @type {boolean}
     * @memberof AreaField
     */
    'required'?: boolean;
    /**
     * If true, UI should render as read-only (Apostrophe option).
     * @type {boolean}
     * @memberof AreaField
     */
    'readOnly'?: boolean;
    /**
     * If true, hide in editor UI.
     * @type {boolean}
     * @memberof AreaField
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {UiCondition}
     * @memberof AreaField
     */
    'if'?: UiCondition;
    /**
     * 
     * @type {UiCondition}
     * @memberof AreaField
     */
    'requiredIf'?: UiCondition;
    /**
     * 
     * @type {AreaOptions}
     * @memberof AreaField
     */
    'options': AreaOptions;
}

export const AreaFieldTypeEnum = {
    Area: 'area'
} as const;

export type AreaFieldTypeEnum = typeof AreaFieldTypeEnum[keyof typeof AreaFieldTypeEnum];

/**
 * 
 * @export
 * @interface AreaOptions
 */
export interface AreaOptions {
    [key: string]: any;

    /**
     * Allowed widget types for this area. Keys are widget module names (e.g., \"@apostrophecms/rich-text\"). Values are per-widget options that apply *only* in this area. 
     * @type {{ [key: string]: object; }}
     * @memberof AreaOptions
     */
    'widgets': { [key: string]: object; };
    /**
     * Organize widgets into groups for the expanded preview menu. Each group has a label, optional columns (1â€“4, default 3), and its own widgets map (same shape as `widgets`). 
     * @type {{ [key: string]: AreaWidgetGroup; }}
     * @memberof AreaOptions
     */
    'groups'?: { [key: string]: AreaWidgetGroup; };
    /**
     * Maximum number of widgets allowed in this area.
     * @type {number}
     * @memberof AreaOptions
     */
    'max'?: number;
    /**
     * Use the expanded preview menu UX.
     * @type {boolean}
     * @memberof AreaOptions
     */
    'expanded'?: boolean;
}
/**
 * 
 * @export
 * @interface AreaWidgetGroup
 */
export interface AreaWidgetGroup {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof AreaWidgetGroup
     */
    'label': string;
    /**
     * Number of widget previews per row (default 3).
     * @type {number}
     * @memberof AreaWidgetGroup
     */
    'columns'?: number;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AreaWidgetGroup
     */
    'widgets': { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface ArrayField
 */
export interface ArrayField {
    /**
     * Apostrophe field type id.
     * @type {string}
     * @memberof ArrayField
     */
    'type': ArrayFieldTypeEnum;
    /**
     * Human-readable label for editors.
     * @type {string}
     * @memberof ArrayField
     */
    'label': string;
    /**
     * Short helper text shown in the UI.
     * @type {string}
     * @memberof ArrayField
     */
    'help'?: string;
    /**
     * Rich helper text (HTML allowed by Apostrophe).
     * @type {string}
     * @memberof ArrayField
     */
    'htmlHelp'?: string;
    /**
     * 
     * @type {any}
     * @memberof ArrayField
     */
    'def'?: any;
    /**
     * If true, value must be provided.
     * @type {boolean}
     * @memberof ArrayField
     */
    'required'?: boolean;
    /**
     * If true, UI should render as read-only (Apostrophe option).
     * @type {boolean}
     * @memberof ArrayField
     */
    'readOnly'?: boolean;
    /**
     * If true, hide in editor UI.
     * @type {boolean}
     * @memberof ArrayField
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {UiCondition}
     * @memberof ArrayField
     */
    'if'?: UiCondition;
    /**
     * 
     * @type {UiCondition}
     * @memberof ArrayField
     */
    'requiredIf'?: UiCondition;
    /**
     * 
     * @type {Fieldset}
     * @memberof ArrayField
     */
    'fields': Fieldset;
    /**
     * Minimum number of items (inclusive).
     * @type {number}
     * @memberof ArrayField
     */
    'min'?: number;
    /**
     * Maximum number of items (inclusive).
     * @type {number}
     * @memberof ArrayField
     */
    'max'?: number;
    /**
     * Field name in each item used as the item label in the UI.
     * @type {string}
     * @memberof ArrayField
     */
    'titleField'?: string;
}

export const ArrayFieldTypeEnum = {
    Array: 'array'
} as const;

export type ArrayFieldTypeEnum = typeof ArrayFieldTypeEnum[keyof typeof ArrayFieldTypeEnum];

/**
 * File attachment information from upload endpoint
 * @export
 * @interface Attachment
 */
export interface Attachment {
    /**
     * Unique attachment identifier
     * @type {string}
     * @memberof Attachment
     */
    '_id'?: string;
    /**
     * URL to the original file
     * @type {string}
     * @memberof Attachment
     */
    '_url'?: string;
    /**
     * URLs for different image sizes (images only)
     * @type {{ [key: string]: string; }}
     * @memberof Attachment
     */
    '_urls'?: { [key: string]: string; };
    /**
     * Slugified filename
     * @type {string}
     * @memberof Attachment
     */
    'name'?: string;
    /**
     * Sortified filename
     * @type {string}
     * @memberof Attachment
     */
    'title'?: string;
    /**
     * File extension
     * @type {string}
     * @memberof Attachment
     */
    'extension'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'type'?: string;
    /**
     * File group type
     * @type {string}
     * @memberof Attachment
     */
    'group'?: string;
    /**
     * File size in bytes
     * @type {number}
     * @memberof Attachment
     */
    'length'?: number;
    /**
     * MD5 checksum
     * @type {string}
     * @memberof Attachment
     */
    'md5'?: string;
    /**
     * Image width in pixels (images only)
     * @type {number}
     * @memberof Attachment
     */
    'width'?: number;
    /**
     * Image height in pixels (images only)
     * @type {number}
     * @memberof Attachment
     */
    'height'?: number;
    /**
     * Whether image is landscape orientation (images only)
     * @type {boolean}
     * @memberof Attachment
     */
    'landscape'?: boolean;
    /**
     * Whether image is portrait orientation (images only)
     * @type {boolean}
     * @memberof Attachment
     */
    'portrait'?: boolean;
    /**
     * IDs of documents using this attachment
     * @type {Array<string>}
     * @memberof Attachment
     */
    'docIds'?: Array<string>;
    /**
     * IDs of archived documents using this attachment
     * @type {Array<string>}
     * @memberof Attachment
     */
    'archivedDocIds'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface AttachmentCropRequest
 */
export interface AttachmentCropRequest {
    /**
     * The _id property of an existing image attachment document
     * @type {string}
     * @memberof AttachmentCropRequest
     */
    '_id': string;
    /**
     * 
     * @type {AttachmentCropRequestCrop}
     * @memberof AttachmentCropRequest
     */
    'crop': AttachmentCropRequestCrop;
}
/**
 * Crop coordinates and dimensions
 * @export
 * @interface AttachmentCropRequestCrop
 */
export interface AttachmentCropRequestCrop {
    /**
     * Top coordinate of the crop area (pixels)
     * @type {number}
     * @memberof AttachmentCropRequestCrop
     */
    'top': number;
    /**
     * Left coordinate of the crop area (pixels)
     * @type {number}
     * @memberof AttachmentCropRequestCrop
     */
    'left': number;
    /**
     * Width of the crop area (pixels)
     * @type {number}
     * @memberof AttachmentCropRequestCrop
     */
    'width': number;
    /**
     * Height of the crop area (pixels)
     * @type {number}
     * @memberof AttachmentCropRequestCrop
     */
    'height': number;
}
/**
 * 
 * @export
 * @interface AttachmentField
 */
export interface AttachmentField {
    /**
     * Apostrophe field type id.
     * @type {string}
     * @memberof AttachmentField
     */
    'type': AttachmentFieldTypeEnum;
    /**
     * Human-readable label for editors.
     * @type {string}
     * @memberof AttachmentField
     */
    'label': string;
    /**
     * Short helper text shown in the UI.
     * @type {string}
     * @memberof AttachmentField
     */
    'help'?: string;
    /**
     * Rich helper text (HTML allowed by Apostrophe).
     * @type {string}
     * @memberof AttachmentField
     */
    'htmlHelp'?: string;
    /**
     * 
     * @type {any}
     * @memberof AttachmentField
     */
    'def'?: any;
    /**
     * If true, value must be provided.
     * @type {boolean}
     * @memberof AttachmentField
     */
    'required'?: boolean;
    /**
     * If true, UI should render as read-only (Apostrophe option).
     * @type {boolean}
     * @memberof AttachmentField
     */
    'readOnly'?: boolean;
    /**
     * If true, hide in editor UI.
     * @type {boolean}
     * @memberof AttachmentField
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {UiCondition}
     * @memberof AttachmentField
     */
    'if'?: UiCondition;
    /**
     * 
     * @type {UiCondition}
     * @memberof AttachmentField
     */
    'requiredIf'?: UiCondition;
    /**
     * 
     * @type {AttachmentFieldAllOfAccept}
     * @memberof AttachmentField
     */
    'accept'?: AttachmentFieldAllOfAccept;
    /**
     * Optional max file size in bytes (documentation-only hint).
     * @type {number}
     * @memberof AttachmentField
     */
    'maxSize'?: number;
}

export const AttachmentFieldTypeEnum = {
    Attachment: 'attachment'
} as const;

export type AttachmentFieldTypeEnum = typeof AttachmentFieldTypeEnum[keyof typeof AttachmentFieldTypeEnum];

/**
 * @type AttachmentFieldAllOfAccept
 * @export
 */
export type AttachmentFieldAllOfAccept = Array<string> | string;

/**
 * Additional context based on configuration
 * @export
 * @interface AuthContext200Response
 */
export interface AuthContext200Response {
    [key: string]: any;

    /**
     * Whether local login is enabled
     * @type {boolean}
     * @memberof AuthContext200Response
     */
    'localLogin'?: boolean;
    /**
     * Whether password reset is enabled
     * @type {boolean}
     * @memberof AuthContext200Response
     */
    'passwordReset'?: boolean;
    /**
     * The configured login URL
     * @type {string}
     * @memberof AuthContext200Response
     */
    'loginUrl'?: string;
}
/**
 * Additional context based on configuration\"
 * @export
 * @interface AuthContextPost200Response
 */
export interface AuthContextPost200Response {
    [key: string]: any;

    /**
     * Whether local login is enabled
     * @type {boolean}
     * @memberof AuthContextPost200Response
     */
    'localLogin'?: boolean;
    /**
     * Whether password reset is enabled
     * @type {boolean}
     * @memberof AuthContextPost200Response
     */
    'passwordReset'?: boolean;
    /**
     * The configured login URL
     * @type {string}
     * @memberof AuthContextPost200Response
     */
    'loginUrl'?: string;
}
/**
 * 
 * @export
 * @interface AuthLogin200Response
 */
export interface AuthLogin200Response {
    /**
     * Bearer token (only present when session is false/omitted)
     * @type {string}
     * @memberof AuthLogin200Response
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface AuthLoginRequest
 */
export interface AuthLoginRequest {
    /**
     * User\'s login username
     * @type {string}
     * @memberof AuthLoginRequest
     */
    'username': string;
    /**
     * User\'s password
     * @type {string}
     * @memberof AuthLoginRequest
     */
    'password': string;
    /**
     * Set to true to receive session cookie instead of bearer token
     * @type {boolean}
     * @memberof AuthLoginRequest
     */
    'session'?: boolean;
}
/**
 * 
 * @export
 * @interface AuthLogout200Response
 */
export interface AuthLogout200Response {
    /**
     * 
     * @type {boolean}
     * @memberof AuthLogout200Response
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface AuthReset200Response
 */
export interface AuthReset200Response {
    /**
     * 
     * @type {boolean}
     * @memberof AuthReset200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AuthReset200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AuthReset410Response
 */
export interface AuthReset410Response {
    /**
     * 
     * @type {string}
     * @memberof AuthReset410Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface AuthResetRequest
 */
export interface AuthResetRequest {
    /**
     * Reset token from the password reset email
     * @type {string}
     * @memberof AuthResetRequest
     */
    'token': string;
    /**
     * New password for the user account
     * @type {string}
     * @memberof AuthResetRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AuthResetRequest200Response
 */
export interface AuthResetRequest200Response {
    /**
     * 
     * @type {boolean}
     * @memberof AuthResetRequest200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AuthResetRequest200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AuthResetRequestRequest
 */
export interface AuthResetRequestRequest {
    /**
     * Email address of the user requesting password reset
     * @type {string}
     * @memberof AuthResetRequestRequest
     */
    'email': string;
}
/**
 * Additional fields based on whoamiFields configuration
 * @export
 * @interface AuthWhoAmI200Response
 */
export interface AuthWhoAmI200Response {
    [key: string]: any;

    /**
     * User\'s unique identifier
     * @type {string}
     * @memberof AuthWhoAmI200Response
     */
    '_id'?: string;
    /**
     * User\'s login username
     * @type {string}
     * @memberof AuthWhoAmI200Response
     */
    'username'?: string;
    /**
     * User\'s display name
     * @type {string}
     * @memberof AuthWhoAmI200Response
     */
    'title'?: string;
    /**
     * User\'s email address (if configured in whoamiFields)
     * @type {string}
     * @memberof AuthWhoAmI200Response
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface BaseField
 */
export interface BaseField {
    [key: string]: any;

    /**
     * Apostrophe field type id (e.g., \"float\", \"string\", \"boolean\").
     * @type {string}
     * @memberof BaseField
     */
    'type': string;
    /**
     * Human-readable label for editors.
     * @type {string}
     * @memberof BaseField
     */
    'label': string;
    /**
     * Short helper text shown in the UI.
     * @type {string}
     * @memberof BaseField
     */
    'help'?: string;
    /**
     * Rich helper text (HTML allowed by Apostrophe).
     * @type {string}
     * @memberof BaseField
     */
    'htmlHelp'?: string;
    /**
     * 
     * @type {any}
     * @memberof BaseField
     */
    'def'?: any;
    /**
     * If true, value must be provided.
     * @type {boolean}
     * @memberof BaseField
     */
    'required'?: boolean;
    /**
     * If true, UI should render as read-only (Apostrophe option).
     * @type {boolean}
     * @memberof BaseField
     */
    'readOnly'?: boolean;
    /**
     * If true, hide in editor UI.
     * @type {boolean}
     * @memberof BaseField
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {UiCondition}
     * @memberof BaseField
     */
    'if'?: UiCondition;
    /**
     * 
     * @type {UiCondition}
     * @memberof BaseField
     */
    'requiredIf'?: UiCondition;
}
/**
 * 
 * @export
 * @interface BooleanField
 */
export interface BooleanField {
    /**
     * Apostrophe field type id.
     * @type {string}
     * @memberof BooleanField
     */
    'type': BooleanFieldTypeEnum;
    /**
     * Human-readable label for editors.
     * @type {string}
     * @memberof BooleanField
     */
    'label': string;
    /**
     * Short helper text shown in the UI.
     * @type {string}
     * @memberof BooleanField
     */
    'help'?: string;
    /**
     * Rich helper text (HTML allowed by Apostrophe).
     * @type {string}
     * @memberof BooleanField
     */
    'htmlHelp'?: string;
    /**
     * Default value shown in the editor UI.
     * @type {boolean}
     * @memberof BooleanField
     */
    'def'?: boolean;
    /**
     * If true, value must be provided.
     * @type {boolean}
     * @memberof BooleanField
     */
    'required'?: boolean;
    /**
     * If true, UI should render as read-only (Apostrophe option).
     * @type {boolean}
     * @memberof BooleanField
     */
    'readOnly'?: boolean;
    /**
     * If true, hide in editor UI.
     * @type {boolean}
     * @memberof BooleanField
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {UiCondition}
     * @memberof BooleanField
     */
    'if'?: UiCondition;
    /**
     * 
     * @type {UiCondition}
     * @memberof BooleanField
     */
    'requiredIf'?: UiCondition;
    /**
     * 
     * @type {BooleanFieldAllOfToggle}
     * @memberof BooleanField
     */
    'toggle'?: BooleanFieldAllOfToggle;
}

export const BooleanFieldTypeEnum = {
    Boolean: 'boolean'
} as const;

export type BooleanFieldTypeEnum = typeof BooleanFieldTypeEnum[keyof typeof BooleanFieldTypeEnum];

/**
 * @type BooleanFieldAllOfToggle
 * @export
 */
export type BooleanFieldAllOfToggle = BooleanFieldAllOfToggleOneOf | boolean;

/**
 * Configure custom labels for the toggle UI.
 * @export
 * @interface BooleanFieldAllOfToggleOneOf
 */
export interface BooleanFieldAllOfToggleOneOf {
    [key: string]: any;

    /**
     * Label to display when value is true.
     * @type {string}
     * @memberof BooleanFieldAllOfToggleOneOf
     */
    'true'?: string;
    /**
     * Label to display when value is false.
     * @type {string}
     * @memberof BooleanFieldAllOfToggleOneOf
     */
    'false'?: string;
}
/**
 * 
 * @export
 * @interface BulkOperationRequest
 */
export interface BulkOperationRequest {
    /**
     * Array of document IDs to operate on
     * @type {Array<string>}
     * @memberof BulkOperationRequest
     */
    '_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface BulkOperationResponse
 */
export interface BulkOperationResponse {
    /**
     * 
     * @type {boolean}
     * @memberof BulkOperationResponse
     */
    'success'?: boolean;
    /**
     * Number of documents affected
     * @type {number}
     * @memberof BulkOperationResponse
     */
    'modified'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkOperationResponse
     */
    'errors'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CheckboxesField
 */
export interface CheckboxesField {
    /**
     * Apostrophe field type id.
     * @type {string}
     * @memberof CheckboxesField
     */
    'type': CheckboxesFieldTypeEnum;
    /**
     * Human-readable label for editors.
     * @type {string}
     * @memberof CheckboxesField
     */
    'label': string;
    /**
     * Short helper text shown in the UI.
     * @type {string}
     * @memberof CheckboxesField
     */
    'help'?: string;
    /**
     * Rich helper text (HTML allowed by Apostrophe).
     * @type {string}
     * @memberof CheckboxesField
     */
    'htmlHelp'?: string;
    /**
     * Default selected values.
     * @type {Array<CheckboxesFieldAllOfDef>}
     * @memberof CheckboxesField
     */
    'def'?: Array<CheckboxesFieldAllOfDef>;
    /**
     * If true, value must be provided.
     * @type {boolean}
     * @memberof CheckboxesField
     */
    'required'?: boolean;
    /**
     * If true, UI should render as read-only (Apostrophe option).
     * @type {boolean}
     * @memberof CheckboxesField
     */
    'readOnly'?: boolean;
    /**
     * If true, hide in editor UI.
     * @type {boolean}
     * @memberof CheckboxesField
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {UiCondition}
     * @memberof CheckboxesField
     */
    'if'?: UiCondition;
    /**
     * 
     * @type {UiCondition}
     * @memberof CheckboxesField
     */
    'requiredIf'?: UiCondition;
    /**
     * 
     * @type {CheckboxesFieldAllOfChoices}
     * @memberof CheckboxesField
     */
    'choices': CheckboxesFieldAllOfChoices;
    /**
     * 
     * @type {CheckboxesFieldAllOfFollowing}
     * @memberof CheckboxesField
     */
    'following'?: CheckboxesFieldAllOfFollowing;
    /**
     * 
     * @type {CheckboxesFieldAllOfFollowingIgnore}
     * @memberof CheckboxesField
     */
    'followingIgnore'?: CheckboxesFieldAllOfFollowingIgnore;
}

export const CheckboxesFieldTypeEnum = {
    Checkboxes: 'checkboxes'
} as const;

export type CheckboxesFieldTypeEnum = typeof CheckboxesFieldTypeEnum[keyof typeof CheckboxesFieldTypeEnum];

/**
 * @type CheckboxesFieldAllOfChoices
 * @export
 */
export type CheckboxesFieldAllOfChoices = Array<SelectChoice> | string;

/**
 * @type CheckboxesFieldAllOfDef
 * @export
 */
export type CheckboxesFieldAllOfDef = boolean | number | string;

/**
 * @type CheckboxesFieldAllOfFollowing
 * Populate dynamically based on other fields (supports `<` parent prefixes).
 * @export
 */
export type CheckboxesFieldAllOfFollowing = Array<string> | string;

/**
 * @type CheckboxesFieldAllOfFollowingIgnore
 * Ignore some or all followed fields when generating values.
 * @export
 */
export type CheckboxesFieldAllOfFollowingIgnore = Array<string> | boolean;

/**
 * 
 * @export
 * @interface ColorField
 */
export interface ColorField {
    /**
     * Apostrophe field type id.
     * @type {string}
     * @memberof ColorField
     */
    'type': ColorFieldTypeEnum;
    /**
     * Human-readable label for editors.
     * @type {string}
     * @memberof ColorField
     */
    'label': string;
    /**
     * Short helper text shown in the UI.
     * @type {string}
     * @memberof ColorField
     */
    'help'?: string;
    /**
     * Rich helper text (HTML allowed by Apostrophe).
     * @type {string}
     * @memberof ColorField
     */
    'htmlHelp'?: string;
    /**
     * Default hex color (e.g. \"#ff0000\").
     * @type {string}
     * @memberof ColorField
     */
    'def'?: string;
    /**
     * If true, value must be provided.
     * @type {boolean}
     * @memberof ColorField
     */
    'required'?: boolean;
    /**
     * If true, UI should render as read-only (Apostrophe option).
     * @type {boolean}
     * @memberof ColorField
     */
    'readOnly'?: boolean;
    /**
     * If true, hide in editor UI.
     * @type {boolean}
     * @memberof ColorField
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {UiCondition}
     * @memberof ColorField
     */
    'if'?: UiCondition;
    /**
     * 
     * @type {UiCondition}
     * @memberof ColorField
     */
    'requiredIf'?: UiCondition;
}

export const ColorFieldTypeEnum = {
    Color: 'color'
} as const;

export type ColorFieldTypeEnum = typeof ColorFieldTypeEnum[keyof typeof ColorFieldTypeEnum];

/**
 * Generic structure for creating any piece type
 * @export
 * @interface CreatePieceRequest
 */
export interface CreatePieceRequest {
    /**
     * Piece title (required for all piece types)
     * @type {string}
     * @memberof CreatePieceRequest
     */
    'title': string;
    /**
     * URL slug (auto-generated from title if not provided)
     * @type {string}
     * @memberof CreatePieceRequest
     */
    'slug'?: string;
    /**
     * Visibility setting
     * @type {string}
     * @memberof CreatePieceRequest
     */
    'visibility'?: CreatePieceRequestVisibilityEnum;
    /**
     * Whether the piece is archived
     * @type {boolean}
     * @memberof CreatePieceRequest
     */
    'archived'?: boolean;
}

export const CreatePieceRequestVisibilityEnum = {
    Public: 'public',
    LoginRequired: 'loginRequired'
} as const;

export type CreatePieceRequestVisibilityEnum = typeof CreatePieceRequestVisibilityEnum[keyof typeof CreatePieceRequestVisibilityEnum];

/**
 * 
 * @export
 * @interface DateAndTimeField
 */
export interface DateAndTimeField {
    /**
     * Apostrophe field type id.
     * @type {string}
     * @memberof DateAndTimeField
     */
    'type': DateAndTimeFieldTypeEnum;
    /**
     * Human-readable label for editors.
     * @type {string}
     * @memberof DateAndTimeField
     */
    'label': string;
    /**
     * Short helper text shown in the UI.
     * @type {string}
     * @memberof DateAndTimeField
     */
    'help'?: string;
    /**
     * Rich helper text (HTML allowed by Apostrophe).
     * @type {string}
     * @memberof DateAndTimeField
     */
    'htmlHelp'?: string;
    /**
     * Default timestamp in RFC 3339 format (e.g., 2025-08-29T13:00:00Z).
     * @type {string}
     * @memberof DateAndTimeField
     */
    'def'?: string;
    /**
     * If true, value must be provided.
     * @type {boolean}
     * @memberof DateAndTimeField
     */
    'required'?: boolean;
    /**
     * If true, UI should render as read-only (Apostrophe option).
     * @type {boolean}
     * @memberof DateAndTimeField
     */
    'readOnly'?: boolean;
    /**
     * If true, hide in editor UI.
     * @type {boolean}
     * @memberof DateAndTimeField
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {UiCondition}
     * @memberof DateAndTimeField
     */
    'if'?: UiCondition;
    /**
     * 
     * @type {UiCondition}
     * @memberof DateAndTimeField
     */
    'requiredIf'?: UiCondition;
    /**
     * Minimum allowed timestamp (inclusive), RFC 3339.
     * @type {string}
     * @memberof DateAndTimeField
     */
    'min'?: string;
    /**
     * Maximum allowed timestamp (inclusive), RFC 3339.
     * @type {string}
     * @memberof DateAndTimeField
     */
    'max'?: string;
}

export const DateAndTimeFieldTypeEnum = {
    DateAndTime: 'dateAndTime'
} as const;

export type DateAndTimeFieldTypeEnum = typeof DateAndTimeFieldTypeEnum[keyof typeof DateAndTimeFieldTypeEnum];

/**
 * 
 * @export
 * @interface DateBoundaryOptions
 */
export interface DateBoundaryOptions {
    [key: string]: any;

    /**
     * Minimum allowed date (inclusive), ISO-8601 (YYYY-MM-DD).
     * @type {string}
     * @memberof DateBoundaryOptions
     */
    'min'?: string;
    /**
     * Maximum allowed date (inclusive), ISO-8601 (YYYY-MM-DD).
     * @type {string}
     * @memberof DateBoundaryOptions
     */
    'max'?: string;
}
/**
 * 
 * @export
 * @interface DateField
 */
export interface DateField {
    /**
     * Apostrophe field type id.
     * @type {string}
     * @memberof DateField
     */
    'type': DateFieldTypeEnum;
    /**
     * Human-readable label for editors.
     * @type {string}
     * @memberof DateField
     */
    'label': string;
    /**
     * Short helper text shown in the UI.
     * @type {string}
     * @memberof DateField
     */
    'help'?: string;
    /**
     * Rich helper text (HTML allowed by Apostrophe).
     * @type {string}
     * @memberof DateField
     */
    'htmlHelp'?: string;
    /**
     * Default date shown in the editor UI (YYYY-MM-DD).
     * @type {string}
     * @memberof DateField
     */
    'def'?: string;
    /**
     * If true, value must be provided.
     * @type {boolean}
     * @memberof DateField
     */
    'required'?: boolean;
    /**
     * If true, UI should render as read-only (Apostrophe option).
     * @type {boolean}
     * @memberof DateField
     */
    'readOnly'?: boolean;
    /**
     * If true, hide in editor UI.
     * @type {boolean}
     * @memberof DateField
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {UiCondition}
     * @memberof DateField
     */
    'if'?: UiCondition;
    /**
     * 
     * @type {UiCondition}
     * @memberof DateField
     */
    'requiredIf'?: UiCondition;
    /**
     * Minimum allowed date (inclusive), ISO-8601 (YYYY-MM-DD).
     * @type {string}
     * @memberof DateField
     */
    'min'?: string;
    /**
     * Maximum allowed date (inclusive), ISO-8601 (YYYY-MM-DD).
     * @type {string}
     * @memberof DateField
     */
    'max'?: string;
}

export const DateFieldTypeEnum = {
    Date: 'date'
} as const;

export type DateFieldTypeEnum = typeof DateFieldTypeEnum[keyof typeof DateFieldTypeEnum];

/**
 * 
 * @export
 * @interface DateTimeBoundaryOptions
 */
export interface DateTimeBoundaryOptions {
    [key: string]: any;

    /**
     * Minimum allowed timestamp (inclusive), RFC 3339.
     * @type {string}
     * @memberof DateTimeBoundaryOptions
     */
    'min'?: string;
    /**
     * Maximum allowed timestamp (inclusive), RFC 3339.
     * @type {string}
     * @memberof DateTimeBoundaryOptions
     */
    'max'?: string;
}
/**
 * 
 * @export
 * @interface DifferentHostnameResponse
 */
export interface DifferentHostnameResponse {
    [key: string]: any;

    /**
     * Full URL to redirect to with cross-domain session token
     * @type {string}
     * @memberof DifferentHostnameResponse
     */
    'redirectTo': string;
}
/**
 * 
 * @export
 * @interface EmailField
 */
export interface EmailField {
    /**
     * Apostrophe field type id.
     * @type {string}
     * @memberof EmailField
     */
    'type': EmailFieldTypeEnum;
    /**
     * Human-readable label for editors.
     * @type {string}
     * @memberof EmailField
     */
    'label': string;
    /**
     * Short helper text shown in the UI.
     * @type {string}
     * @memberof EmailField
     */
    'help'?: string;
    /**
     * Rich helper text (HTML allowed by Apostrophe).
     * @type {string}
     * @memberof EmailField
     */
    'htmlHelp'?: string;
    /**
     * Default email address shown in the editor UI.
     * @type {string}
     * @memberof EmailField
     */
    'def'?: string;
    /**
     * If true, value must be provided.
     * @type {boolean}
     * @memberof EmailField
     */
    'required'?: boolean;
    /**
     * If true, UI should render as read-only (Apostrophe option).
     * @type {boolean}
     * @memberof EmailField
     */
    'readOnly'?: boolean;
    /**
     * If true, hide in editor UI.
     * @type {boolean}
     * @memberof EmailField
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {UiCondition}
     * @memberof EmailField
     */
    'if'?: UiCondition;
    /**
     * 
     * @type {UiCondition}
     * @memberof EmailField
     */
    'requiredIf'?: UiCondition;
    /**
     * Optional regex for stricter validation (in addition to HTML5 email validation).
     * @type {string}
     * @memberof EmailField
     */
    'pattern'?: string;
    /**
     * Value for the HTML autocomplete attribute. Common values are \"email\" or \"off\".
     * @type {string}
     * @memberof EmailField
     */
    'autocomplete'?: string;
}

export const EmailFieldTypeEnum = {
    Email: 'email'
} as const;

export type EmailFieldTypeEnum = typeof EmailFieldTypeEnum[keyof typeof EmailFieldTypeEnum];

/**
 * 
 * @export
 * @interface ExistInLocaleRequest
 */
export interface ExistInLocaleRequest {
    /**
     * Array of document IDs to check
     * @type {Array<string>}
     * @memberof ExistInLocaleRequest
     */
    'ids': Array<string>;
    /**
     * Locale to check documents in
     * @type {string}
     * @memberof ExistInLocaleRequest
     */
    'locale': string;
    /**
     * Mode to check documents in
     * @type {string}
     * @memberof ExistInLocaleRequest
     */
    'mode': ExistInLocaleRequestModeEnum;
}

export const ExistInLocaleRequestModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;

export type ExistInLocaleRequestModeEnum = typeof ExistInLocaleRequestModeEnum[keyof typeof ExistInLocaleRequestModeEnum];

/**
 * 
 * @export
 * @interface ExistInLocaleResponse
 */
export interface ExistInLocaleResponse {
    /**
     * Array of document IDs in the original locale and mode
     * @type {Array<string>}
     * @memberof ExistInLocaleResponse
     */
    'originalLocaleIds'?: Array<string>;
    /**
     * Array of document IDs in the new locale
     * @type {Array<string>}
     * @memberof ExistInLocaleResponse
     */
    'newLocaleIds'?: Array<string>;
    /**
     * Array of aposDocId values for the documents
     * @type {Array<string>}
     * @memberof ExistInLocaleResponse
     */
    'aposDocIds'?: Array<string>;
}
/**
 * @type FieldDefinition
 * @export
 */
export type FieldDefinition = { type: 'area' } & AreaField | { type: 'array' } & ArrayField | { type: 'attachment' } & AttachmentField | { type: 'boolean' } & BooleanField | { type: 'checkboxes' } & CheckboxesField | { type: 'color' } & ColorField | { type: 'date' } & DateField | { type: 'dateAndTime' } & DateAndTimeField | { type: 'email' } & EmailField | { type: 'float' } & FloatField | { type: 'integer' } & IntegerField | { type: 'object' } & ObjectField | { type: 'oembed' } & OembedField | { type: 'password' } & PasswordField | { type: 'radio' } & RadioField | { type: 'range' } & RangeField | { type: 'relationship' } & RelationshipField | { type: 'relationshipReverse' } & RelationshipReverseField | { type: 'select' } & SelectField | { type: 'slug' } & SlugField | { type: 'string' } & StringField | { type: 'time' } & TimeField | { type: 'url' } & UrlField;

/**
 * @type FieldPredicate
 * A simple equality (primitive) or an OperatorObject. :contentReference[oaicite:5]{index=5}
 * @export
 */
export type FieldPredicate = OperatorObject | boolean | number | string;

/**
 * 
 * @export
 * @interface Fieldset
 */
export interface Fieldset {
    [key: string]: any;

    /**
     * 
     * @type {{ [key: string]: FieldDefinition; }}
     * @memberof Fieldset
     */
    'add': { [key: string]: FieldDefinition; };
}
/**
 * 
 * @export
 * @interface FileGet200Response
 */
export interface FileGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof FileGet200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {PaginatedResponseData}
     * @memberof FileGet200Response
     */
    'data'?: PaginatedResponseData;
    /**
     * 
     * @type {Array<FileObject>}
     * @memberof FileGet200Response
     */
    'results'?: Array<FileObject>;
}
/**
 * Built-in file piece type for general file uploads (PDFs, documents, etc.)
 * @export
 * @interface FileObject
 */
export interface FileObject {
    /**
     * Unique identifier
     * @type {string}
     * @memberof FileObject
     */
    '_id'?: string;
    /**
     * File title/description
     * @type {string}
     * @memberof FileObject
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileObject
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileObject
     */
    'type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FileObject
     */
    'archived'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FileObject
     */
    'visibility'?: FileObjectVisibilityEnum;
    /**
     * 
     * @type {FileObjectAttachment}
     * @memberof FileObject
     */
    'attachment'?: FileObjectAttachment;
    /**
     * File description
     * @type {string}
     * @memberof FileObject
     */
    'description'?: string;
    /**
     * File tags for organization
     * @type {Array<string>}
     * @memberof FileObject
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FileObject
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileObject
     */
    'updatedAt'?: string;
}

export const FileObjectVisibilityEnum = {
    Public: 'public',
    LoginRequired: 'loginRequired'
} as const;

export type FileObjectVisibilityEnum = typeof FileObjectVisibilityEnum[keyof typeof FileObjectVisibilityEnum];

/**
 * File attachment information
 * @export
 * @interface FileObjectAttachment
 */
export interface FileObjectAttachment {
    /**
     * 
     * @type {string}
     * @memberof FileObjectAttachment
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileObjectAttachment
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileObjectAttachment
     */
    'extension'?: string;
    /**
     * File size in bytes
     * @type {number}
     * @memberof FileObjectAttachment
     */
    'length'?: number;
    /**
     * Public URL to access the file
     * @type {string}
     * @memberof FileObjectAttachment
     */
    'url'?: string;
}
/**
 * Only include fields to update
 * @export
 * @interface FilePatchByIdRequest
 */
export interface FilePatchByIdRequest {
    /**
     * File title
     * @type {string}
     * @memberof FilePatchByIdRequest
     */
    'title'?: string;
    /**
     * File description
     * @type {string}
     * @memberof FilePatchByIdRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface FilePostRequest
 */
export interface FilePostRequest {
    /**
     * 
     * @type {string}
     * @memberof FilePostRequest
     */
    'title': string;
    /**
     * Attachment object from upload endpoint
     * @type {Attachment}
     * @memberof FilePostRequest
     */
    'attachment': Attachment;
    /**
     * File description
     * @type {string}
     * @memberof FilePostRequest
     */
    'description'?: string;
}
/**
 * Built-in file tag piece type for organizing files
 * @export
 * @interface FileTag
 */
export interface FileTag {
    /**
     * 
     * @type {string}
     * @memberof FileTag
     */
    '_id'?: string;
    /**
     * Tag name
     * @type {string}
     * @memberof FileTag
     */
    'title'?: string;
    /**
     * URL-friendly tag name
     * @type {string}
     * @memberof FileTag
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileTag
     */
    'type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FileTag
     */
    'archived'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FileTag
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileTag
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface FileTagGet200Response
 */
export interface FileTagGet200Response {
    /**
     * 
     * @type {Array<FileTag>}
     * @memberof FileTagGet200Response
     */
    'results'?: Array<FileTag>;
    /**
     * Total number of pages
     * @type {number}
     * @memberof FileTagGet200Response
     */
    'pages'?: number;
    /**
     * Current page number
     * @type {number}
     * @memberof FileTagGet200Response
     */
    'currentPage'?: number;
}
/**
 * 
 * @export
 * @interface FileTagLocalizeRequest
 */
export interface FileTagLocalizeRequest {
    /**
     * Array of file tag IDs to localize
     * @type {Array<string>}
     * @memberof FileTagLocalizeRequest
     */
    '_ids'?: Array<string>;
    /**
     * Target locale for localization
     * @type {string}
     * @memberof FileTagLocalizeRequest
     */
    'toLocale'?: string;
}
/**
 * 
 * @export
 * @interface FileTagPatchByIdRequest
 */
export interface FileTagPatchByIdRequest {
    /**
     * File tag name
     * @type {string}
     * @memberof FileTagPatchByIdRequest
     */
    'title'?: string;
    /**
     * Optional description of the file tag
     * @type {string}
     * @memberof FileTagPatchByIdRequest
     */
    'description'?: string;
    /**
     * Color code for visual organization
     * @type {string}
     * @memberof FileTagPatchByIdRequest
     */
    'color'?: string;
}
/**
 * 
 * @export
 * @interface FileTagPostRequest
 */
export interface FileTagPostRequest {
    /**
     * File tag name
     * @type {string}
     * @memberof FileTagPostRequest
     */
    'title': string;
    /**
     * Optional description of the file tag
     * @type {string}
     * @memberof FileTagPostRequest
     */
    'description'?: string;
    /**
     * Color code for visual organization
     * @type {string}
     * @memberof FileTagPostRequest
     */
    'color'?: string;
}
/**
 * 
 * @export
 * @interface FileTagPublishRequest
 */
export interface FileTagPublishRequest {
    /**
     * Array of file tag IDs to publish
     * @type {Array<string>}
     * @memberof FileTagPublishRequest
     */
    '_ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface FileTagPutByIdRequest
 */
export interface FileTagPutByIdRequest {
    /**
     * File tag name
     * @type {string}
     * @memberof FileTagPutByIdRequest
     */
    'title': string;
    /**
     * Optional description of the file tag
     * @type {string}
     * @memberof FileTagPutByIdRequest
     */
    'description'?: string;
    /**
     * Color code for visual organization
     * @type {string}
     * @memberof FileTagPutByIdRequest
     */
    'color'?: string;
}
/**
 * Pages returned as flat array instead of tree structure
 * @export
 * @interface FlatPageResponse
 */
export interface FlatPageResponse {
    /**
     * 
     * @type {Array<FlatPageResponseResultsInner>}
     * @memberof FlatPageResponse
     */
    'results'?: Array<FlatPageResponseResultsInner>;
}
/**
 * 
 * @export
 * @interface FlatPageResponseResultsInner
 */
export interface FlatPageResponseResultsInner {
    /**
     * Unique document identifier
     * @type {string}
     * @memberof FlatPageResponseResultsInner
     */
    '_id'?: string;
    /**
     * Whether page is excluded from navigation menus
     * @type {boolean}
     * @memberof FlatPageResponseResultsInner
     */
    'orphan'?: boolean;
    /**
     * Page visibility setting - controls who can view this page
     * @type {string}
     * @memberof FlatPageResponseResultsInner
     */
    'visibility'?: FlatPageResponseResultsInnerVisibilityEnum;
    /**
     * Page type identifier (configured in your project)
     * @type {string}
     * @memberof FlatPageResponseResultsInner
     */
    'type'?: string;
    /**
     * Page title - used for navigation and SEO
     * @type {string}
     * @memberof FlatPageResponseResultsInner
     */
    'title'?: string;
    /**
     * URL slug for the page
     * @type {string}
     * @memberof FlatPageResponseResultsInner
     */
    'slug'?: string;
    /**
     * Order among sibling pages (for navigation sorting)
     * @type {number}
     * @memberof FlatPageResponseResultsInner
     */
    'rank'?: number;
    /**
     * Page tree depth level (0 = home page)
     * @type {number}
     * @memberof FlatPageResponseResultsInner
     */
    'level'?: number;
    /**
     * Ancestor path of page IDs
     * @type {string}
     * @memberof FlatPageResponseResultsInner
     */
    'path'?: string;
    /**
     * Complete page URL - use this for links
     * @type {string}
     * @memberof FlatPageResponseResultsInner
     */
    '_url'?: string;
    /**
     * Array of ancestor page IDs (in flat response)
     * @type {Array<string>}
     * @memberof FlatPageResponseResultsInner
     */
    '_ancestors'?: Array<string>;
    /**
     * Array of child page IDs (in flat response)
     * @type {Array<string>}
     * @memberof FlatPageResponseResultsInner
     */
    '_children'?: Array<string>;
    /**
     * ISO date of creation
     * @type {string}
     * @memberof FlatPageResponseResultsInner
     */
    'createdAt'?: string;
    /**
     * ISO date of last update
     * @type {string}
     * @memberof FlatPageResponseResultsInner
     */
    'updatedAt'?: string;
    /**
     * Whether page is archived (hidden from normal views)
     * @type {boolean}
     * @memberof FlatPageResponseResultsInner
     */
    'archived'?: boolean;
    /**
     * Previous URLs that redirect to this page (SEO preservation)
     * @type {Array<string>}
     * @memberof FlatPageResponseResultsInner
     */
    'historicUrls'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FlatPageResponseResultsInner
     */
    'metaType'?: string;
    /**
     * Sortable version of title
     * @type {string}
     * @memberof FlatPageResponseResultsInner
     */
    'titleSortified'?: string;
    /**
     * 
     * @type {User}
     * @memberof FlatPageResponseResultsInner
     */
    'updatedBy'?: User;
    /**
     * Whether current user can edit this page
     * @type {boolean}
     * @memberof FlatPageResponseResultsInner
     */
    '_edit'?: boolean;
}

export const FlatPageResponseResultsInnerVisibilityEnum = {
    Public: 'public',
    LoginRequired: 'loginRequired',
    Private: 'private'
} as const;

export type FlatPageResponseResultsInnerVisibilityEnum = typeof FlatPageResponseResultsInnerVisibilityEnum[keyof typeof FlatPageResponseResultsInnerVisibilityEnum];

/**
 * 
 * @export
 * @interface FloatField
 */
export interface FloatField {
    /**
     * 
     * @type {string}
     * @memberof FloatField
     */
    'type': FloatFieldTypeEnum;
    /**
     * Human-readable label for editors.
     * @type {string}
     * @memberof FloatField
     */
    'label': string;
    /**
     * Short helper text shown in the UI.
     * @type {string}
     * @memberof FloatField
     */
    'help'?: string;
    /**
     * Rich helper text (HTML allowed by Apostrophe).
     * @type {string}
     * @memberof FloatField
     */
    'htmlHelp'?: string;
    /**
     * Default decimal value.
     * @type {number}
     * @memberof FloatField
     */
    'def'?: number;
    /**
     * If true, value must be provided.
     * @type {boolean}
     * @memberof FloatField
     */
    'required'?: boolean;
    /**
     * If true, UI should render as read-only (Apostrophe option).
     * @type {boolean}
     * @memberof FloatField
     */
    'readOnly'?: boolean;
    /**
     * If true, hide in editor UI.
     * @type {boolean}
     * @memberof FloatField
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {UiCondition}
     * @memberof FloatField
     */
    'if'?: UiCondition;
    /**
     * 
     * @type {UiCondition}
     * @memberof FloatField
     */
    'requiredIf'?: UiCondition;
    /**
     * Minimum allowed value (inclusive).
     * @type {number}
     * @memberof FloatField
     */
    'min'?: number;
    /**
     * Maximum allowed value (inclusive)
     * @type {number}
     * @memberof FloatField
     */
    'max'?: number;
    /**
     * OpenAPI hint for tooling; always \"float\".
     * @type {string}
     * @memberof FloatField
     */
    'format'?: FloatFieldFormatEnum;
}

export const FloatFieldTypeEnum = {
    Float: 'float'
} as const;

export type FloatFieldTypeEnum = typeof FloatFieldTypeEnum[keyof typeof FloatFieldTypeEnum];
export const FloatFieldFormatEnum = {
    Float: 'float'
} as const;

export type FloatFieldFormatEnum = typeof FloatFieldFormatEnum[keyof typeof FloatFieldFormatEnum];

/**
 * \'Built-in global content piece type for site-wide settings.  ðŸ’¡ Developers can add custom fields to the global piece type in their project configuration. 
 * @export
 * @interface Global
 */
export interface Global {
    [key: string]: any;

    /**
     * Unique identifier
     * @type {string}
     * @memberof Global
     */
    '_id'?: string;
    /**
     * Default title field
     * @type {string}
     * @memberof Global
     */
    'title'?: string;
    /**
     * Default slug field
     * @type {string}
     * @memberof Global
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof Global
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface GlobalGet200Response
 */
export interface GlobalGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GlobalGet200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {PaginatedResponseData}
     * @memberof GlobalGet200Response
     */
    'data'?: PaginatedResponseData;
    /**
     * 
     * @type {Array<Global>}
     * @memberof GlobalGet200Response
     */
    'results'?: Array<Global>;
}
/**
 * Allows for patching of costom user added fields. It blocks the modification of the title, slu, and type fields. 
 * @export
 * @interface GlobalPatch
 */
export interface GlobalPatch {
    [key: string]: any;

    /**
     * Default title field
     * @type {string}
     * @memberof GlobalPatch
     */
    'title'?: string;
    /**
     * Default slug field
     * @type {string}
     * @memberof GlobalPatch
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalPatch
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface GlobalPostRequest
 */
export interface GlobalPostRequest {
    /**
     * Global content title
     * @type {string}
     * @memberof GlobalPostRequest
     */
    'title'?: string;
    /**
     * Footer content that appears on all pages
     * @type {string}
     * @memberof GlobalPostRequest
     */
    'footerContent'?: string;
    /**
     * 
     * @type {GlobalPostRequestContactInfo}
     * @memberof GlobalPostRequest
     */
    'contactInfo'?: GlobalPostRequestContactInfo;
    /**
     * 
     * @type {GlobalPostRequestSocialMedia}
     * @memberof GlobalPostRequest
     */
    'socialMedia'?: GlobalPostRequestSocialMedia;
    /**
     * 
     * @type {GlobalPostRequestSiteSettings}
     * @memberof GlobalPostRequest
     */
    'siteSettings'?: GlobalPostRequestSiteSettings;
}
/**
 * Site-wide contact information
 * @export
 * @interface GlobalPostRequestContactInfo
 */
export interface GlobalPostRequestContactInfo {
    /**
     * 
     * @type {string}
     * @memberof GlobalPostRequestContactInfo
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalPostRequestContactInfo
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalPostRequestContactInfo
     */
    'address'?: string;
}
/**
 * Global site configuration
 * @export
 * @interface GlobalPostRequestSiteSettings
 */
export interface GlobalPostRequestSiteSettings {
    /**
     * 
     * @type {string}
     * @memberof GlobalPostRequestSiteSettings
     */
    'siteName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalPostRequestSiteSettings
     */
    'tagline'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GlobalPostRequestSiteSettings
     */
    'maintenanceMode'?: boolean;
}
/**
 * Social media links
 * @export
 * @interface GlobalPostRequestSocialMedia
 */
export interface GlobalPostRequestSocialMedia {
    /**
     * 
     * @type {string}
     * @memberof GlobalPostRequestSocialMedia
     */
    'facebook'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalPostRequestSocialMedia
     */
    'twitter'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalPostRequestSocialMedia
     */
    'linkedin'?: string;
}
/**
 * @type I18nLocalePost200Response
 * @export
 */
export type I18nLocalePost200Response = DifferentHostnameResponse | SameHostnameResponse;

/**
 * Built-in image/media piece type for managing photos and graphics
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * Unique identifier
     * @type {string}
     * @memberof Image
     */
    '_id'?: string;
    /**
     * Image title/alt text
     * @type {string}
     * @memberof Image
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Image
     */
    'archived'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'visibility'?: ImageVisibilityEnum;
    /**
     * 
     * @type {ImageAttachment}
     * @memberof Image
     */
    'attachment'?: ImageAttachment;
    /**
     * Image credit or attribution
     * @type {string}
     * @memberof Image
     */
    'credit'?: string;
    /**
     * Image tags for organization
     * @type {Array<string>}
     * @memberof Image
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    'updatedAt'?: string;
}

export const ImageVisibilityEnum = {
    Public: 'public',
    LoginRequired: 'loginRequired'
} as const;

export type ImageVisibilityEnum = typeof ImageVisibilityEnum[keyof typeof ImageVisibilityEnum];

/**
 * File attachment information
 * @export
 * @interface ImageAttachment
 */
export interface ImageAttachment {
    /**
     * 
     * @type {string}
     * @memberof ImageAttachment
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageAttachment
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageAttachment
     */
    'extension'?: string;
    /**
     * File size in bytes
     * @type {number}
     * @memberof ImageAttachment
     */
    'length'?: number;
    /**
     * Public URL to access the image
     * @type {string}
     * @memberof ImageAttachment
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface ImageAutocropRequest
 */
export interface ImageAutocropRequest {
    /**
     * Array of image IDs to auto-crop
     * @type {Array<string>}
     * @memberof ImageAutocropRequest
     */
    '_ids'?: Array<string>;
    /**
     * Desired aspect ratio for cropping
     * @type {string}
     * @memberof ImageAutocropRequest
     */
    'cropRatio'?: string;
}
/**
 * 
 * @export
 * @interface ImageGet200Response
 */
export interface ImageGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ImageGet200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {PaginatedResponseData}
     * @memberof ImageGet200Response
     */
    'data'?: PaginatedResponseData;
    /**
     * 
     * @type {Array<Image>}
     * @memberof ImageGet200Response
     */
    'results'?: Array<Image>;
}
/**
 * 
 * @export
 * @interface ImageGetSrcById200Response
 */
export interface ImageGetSrcById200Response {
    /**
     * Direct URL to the image file
     * @type {string}
     * @memberof ImageGetSrcById200Response
     */
    'url'?: string;
    /**
     * Image width in pixels
     * @type {number}
     * @memberof ImageGetSrcById200Response
     */
    'width'?: number;
    /**
     * Image height in pixels
     * @type {number}
     * @memberof ImageGetSrcById200Response
     */
    'height'?: number;
    /**
     * Image format
     * @type {string}
     * @memberof ImageGetSrcById200Response
     */
    'format'?: string;
    /**
     * File size in bytes
     * @type {number}
     * @memberof ImageGetSrcById200Response
     */
    'size'?: number;
}
/**
 * 
 * @export
 * @interface ImageLocalizeRequest
 */
export interface ImageLocalizeRequest {
    /**
     * Array of image IDs to localize
     * @type {Array<string>}
     * @memberof ImageLocalizeRequest
     */
    '_ids'?: Array<string>;
    /**
     * Target locale for localization
     * @type {string}
     * @memberof ImageLocalizeRequest
     */
    'toLocale'?: string;
}
/**
 * Only include fields to update
 * @export
 * @interface ImagePatchByIdRequest
 */
export interface ImagePatchByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof ImagePatchByIdRequest
     */
    'title'?: string;
    /**
     * Alt text for accessibility
     * @type {string}
     * @memberof ImagePatchByIdRequest
     */
    'alt'?: string;
    /**
     * Photo credit
     * @type {string}
     * @memberof ImagePatchByIdRequest
     */
    'credit'?: string;
}
/**
 * 
 * @export
 * @interface ImagePostRequest
 */
export interface ImagePostRequest {
    /**
     * 
     * @type {string}
     * @memberof ImagePostRequest
     */
    'title': string;
    /**
     * Attachment object from upload endpoint
     * @type {Attachment}
     * @memberof ImagePostRequest
     */
    'attachment': Attachment;
    /**
     * Alt text for accessibility
     * @type {string}
     * @memberof ImagePostRequest
     */
    'alt'?: string;
    /**
     * Photo credit
     * @type {string}
     * @memberof ImagePostRequest
     */
    'credit'?: string;
}
/**
 * 
 * @export
 * @interface ImagePublishRequest
 */
export interface ImagePublishRequest {
    /**
     * Array of image IDs to publish
     * @type {Array<string>}
     * @memberof ImagePublishRequest
     */
    '_ids'?: Array<string>;
}
/**
 * Built-in image tag piece type for organizing images
 * @export
 * @interface ImageTag
 */
export interface ImageTag {
    /**
     * 
     * @type {string}
     * @memberof ImageTag
     */
    '_id'?: string;
    /**
     * Tag name
     * @type {string}
     * @memberof ImageTag
     */
    'title'?: string;
    /**
     * URL-friendly tag name
     * @type {string}
     * @memberof ImageTag
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageTag
     */
    'type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ImageTag
     */
    'archived'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ImageTag
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageTag
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface ImageTagGet200Response
 */
export interface ImageTagGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof ImageTagGet200Response
     */
    'success'?: boolean;
    /**
     * 
     * @type {PaginatedResponseData}
     * @memberof ImageTagGet200Response
     */
    'data'?: PaginatedResponseData;
    /**
     * 
     * @type {Array<ImageTag>}
     * @memberof ImageTagGet200Response
     */
    'results'?: Array<ImageTag>;
}
/**
 * Only include fields to update
 * @export
 * @interface ImageTagPatchByIdRequest
 */
export interface ImageTagPatchByIdRequest {
    /**
     * Tag name
     * @type {string}
     * @memberof ImageTagPatchByIdRequest
     */
    'title'?: string;
    /**
     * URL-friendly identifier
     * @type {string}
     * @memberof ImageTagPatchByIdRequest
     */
    'slug'?: string;
}
/**
 * 
 * @export
 * @interface ImageTagPostRequest
 */
export interface ImageTagPostRequest {
    /**
     * Tag name
     * @type {string}
     * @memberof ImageTagPostRequest
     */
    'title': string;
    /**
     * URL-friendly identifier (auto-generated if not provided)
     * @type {string}
     * @memberof ImageTagPostRequest
     */
    'slug'?: string;
}
/**
 * 
 * @export
 * @interface ImageTagRequest
 */
export interface ImageTagRequest {
    /**
     * Array of image IDs to tag
     * @type {Array<string>}
     * @memberof ImageTagRequest
     */
    '_ids'?: Array<string>;
    /**
     * Array of tags to add to the images
     * @type {Array<string>}
     * @memberof ImageTagRequest
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject5
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface IntegerField
 */
export interface IntegerField {
    /**
     * Apostrophe field type id.
     * @type {string}
     * @memberof IntegerField
     */
    'type': IntegerFieldTypeEnum;
    /**
     * Human-readable label for editors.
     * @type {string}
     * @memberof IntegerField
     */
    'label': string;
    /**
     * Short helper text shown in the UI.
     * @type {string}
     * @memberof IntegerField
     */
    'help'?: string;
    /**
     * Rich helper text (HTML allowed by Apostrophe).
     * @type {string}
     * @memberof IntegerField
     */
    'htmlHelp'?: string;
    /**
     * Default integer value shown in the editor UI.
     * @type {number}
     * @memberof IntegerField
     */
    'def'?: number;
    /**
     * If true, value must be provided.
     * @type {boolean}
     * @memberof IntegerField
     */
    'required'?: boolean;
    /**
     * If true, UI should render as read-only (Apostrophe option).
     * @type {boolean}
     * @memberof IntegerField
     */
    'readOnly'?: boolean;
    /**
     * If true, hide in editor UI.
     * @type {boolean}
     * @memberof IntegerField
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {UiCondition}
     * @memberof IntegerField
     */
    'if'?: UiCondition;
    /**
     * 
     * @type {UiCondition}
     * @memberof IntegerField
     */
    'requiredIf'?: UiCondition;
    /**
     * Minimum allowed value (inclusive).
     * @type {number}
     * @memberof IntegerField
     */
    'min'?: number;
    /**
     * Maximum allowed value (inclusive)
     * @type {number}
     * @memberof IntegerField
     */
    'max'?: number;
}

export const IntegerFieldTypeEnum = {
    Integer: 'integer'
} as const;

export type IntegerFieldTypeEnum = typeof IntegerFieldTypeEnum[keyof typeof IntegerFieldTypeEnum];

/**
 * 
 * @export
 * @interface LocaleRequest
 */
export interface LocaleRequest {
    /**
     * Target locale code
     * @type {string}
     * @memberof LocaleRequest
     */
    'locale': string;
    /**
     * Optional document ID for the path
     * @type {string}
     * @memberof LocaleRequest
     */
    'contextDocId'?: string;
    /**
     * Optional clipboard content for cross-domain situations
     * @type {string}
     * @memberof LocaleRequest
     */
    'clipboard'?: string;
}
/**
 * 
 * @export
 * @interface LocalesResponseValue
 */
export interface LocalesResponseValue {
    /**
     * Human-readable locale name
     * @type {string}
     * @memberof LocalesResponseValue
     */
    'label'?: string;
    /**
     * Whether current user can edit content in this locale
     * @type {boolean}
     * @memberof LocalesResponseValue
     */
    '_edit'?: boolean;
}
/**
 * 
 * @export
 * @interface NumericRangeOptions
 */
export interface NumericRangeOptions {
    [key: string]: any;

    /**
     * Minimum allowed value (inclusive).
     * @type {number}
     * @memberof NumericRangeOptions
     */
    'min'?: number;
    /**
     * Maximum allowed value (inclusive)
     * @type {number}
     * @memberof NumericRangeOptions
     */
    'max'?: number;
}
/**
 * 
 * @export
 * @interface ObjectField
 */
export interface ObjectField {
    /**
     * 
     * @type {string}
     * @memberof ObjectField
     */
    'type': ObjectFieldTypeEnum;
    /**
     * Human-readable label for editors.
     * @type {string}
     * @memberof ObjectField
     */
    'label': string;
    /**
     * Short helper text shown in the UI.
     * @type {string}
     * @memberof ObjectField
     */
    'help'?: string;
    /**
     * Rich helper text (HTML allowed by Apostrophe).
     * @type {string}
     * @memberof ObjectField
     */
    'htmlHelp'?: string;
    /**
     * 
     * @type {any}
     * @memberof ObjectField
     */
    'def'?: any;
    /**
     * If true, value must be provided.
     * @type {boolean}
     * @memberof ObjectField
     */
    'required'?: boolean;
    /**
     * If true, UI should render as read-only (Apostrophe option).
     * @type {boolean}
     * @memberof ObjectField
     */
    'readOnly'?: boolean;
    /**
     * If true, hide in editor UI.
     * @type {boolean}
     * @memberof ObjectField
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {UiCondition}
     * @memberof ObjectField
     */
    'if'?: UiCondition;
    /**
     * 
     * @type {UiCondition}
     * @memberof ObjectField
     */
    'requiredIf'?: UiCondition;
    /**
     * 
     * @type {Fieldset}
     * @memberof ObjectField
     */
    'fields': Fieldset;
}

export const ObjectFieldTypeEnum = {
    Object: 'object'
} as const;

export type ObjectFieldTypeEnum = typeof ObjectFieldTypeEnum[keyof typeof ObjectFieldTypeEnum];

/**
 * 
 * @export
 * @interface OembedField
 */
export interface OembedField {
    /**
     * Apostrophe field type id.
     * @type {string}
     * @memberof OembedField
     */
    'type': OembedFieldTypeEnum;
    /**
     * Human-readable label for editors.
     * @type {string}
     * @memberof OembedField
     */
    'label': string;
    /**
     * Short helper text shown in the UI.
     * @type {string}
     * @memberof OembedField
     */
    'help'?: string;
    /**
     * Rich helper text (HTML allowed by Apostrophe).
     * @type {string}
     * @memberof OembedField
     */
    'htmlHelp'?: string;
    /**
     * 
     * @type {any}
     * @memberof OembedField
     */
    'def'?: any;
    /**
     * If true, value must be provided.
     * @type {boolean}
     * @memberof OembedField
     */
    'required'?: boolean;
    /**
     * If true, UI should render as read-only (Apostrophe option).
     * @type {boolean}
     * @memberof OembedField
     */
    'readOnly'?: boolean;
    /**
     * If true, hide in editor UI.
     * @type {boolean}
     * @memberof OembedField
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {UiCondition}
     * @memberof OembedField
     */
    'if'?: UiCondition;
    /**
     * 
     * @type {UiCondition}
     * @memberof OembedField
     */
    'requiredIf'?: UiCondition;
}

export const OembedFieldTypeEnum = {
    Oembed: 'oembed'
} as const;

export type OembedFieldTypeEnum = typeof OembedFieldTypeEnum[keyof typeof OembedFieldTypeEnum];

/**
 * MongoDB-style operators supported by Apostrophe conditions. Note:   `$eq` has special handling with arrays (see docs).   `$exists: true` means not null/undefined; empty string is truthy so use `$ne: \'\'\'\'` or check `.length`. 
 * @export
 * @interface OperatorObject
 */
export interface OperatorObject {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof OperatorObject
     */
    '$eq'?: any;
    /**
     * 
     * @type {any}
     * @memberof OperatorObject
     */
    '$ne'?: any;
    /**
     * 
     * @type {number}
     * @memberof OperatorObject
     */
    '$gt'?: number;
    /**
     * 
     * @type {number}
     * @memberof OperatorObject
     */
    '$gte'?: number;
    /**
     * 
     * @type {number}
     * @memberof OperatorObject
     */
    '$lt'?: number;
    /**
     * 
     * @type {number}
     * @memberof OperatorObject
     */
    '$lte'?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof OperatorObject
     */
    '$in'?: Array<any>;
    /**
     * 
     * @type {Array<any>}
     * @memberof OperatorObject
     */
    '$nin'?: Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof OperatorObject
     */
    '$exists'?: boolean;
}
/**
 * An ApostropheCMS page document with hierarchical structure and content areas
 * @export
 * @interface Page
 */
export interface Page {
    [key: string]: any;

    /**
     * Unique document identifier, may include mode and locale (e.g., \"id:en:published\")
     * @type {string}
     * @memberof Page
     */
    '_id': string;
    /**
     * Base document ID without mode/locale qualifiers
     * @type {string}
     * @memberof Page
     */
    'aposDocId': string;
    /**
     * Document locale code
     * @type {string}
     * @memberof Page
     */
    'aposLocale'?: string;
    /**
     * Document mode (draft or published)
     * @type {string}
     * @memberof Page
     */
    'aposMode'?: PageAposModeEnum;
    /**
     * Whether the page is archived
     * @type {boolean}
     * @memberof Page
     */
    'archived'?: boolean;
    /**
     * Page creation timestamp
     * @type {string}
     * @memberof Page
     */
    'createdAt'?: string;
    /**
     * Page last update timestamp
     * @type {string}
     * @memberof Page
     */
    'updatedAt'?: string;
    /**
     * Sortable version of the page title
     * @type {string}
     * @memberof Page
     */
    'titleSortified'?: string;
    /**
     * URL slug for the page
     * @type {string}
     * @memberof Page
     */
    'slug': string;
    /**
     * Full hierarchical path in the page tree
     * @type {string}
     * @memberof Page
     */
    'path': string;
    /**
     * Sort order within parent page
     * @type {number}
     * @memberof Page
     */
    'rank'?: number;
    /**
     * Depth level in the page tree (0 = root level)
     * @type {number}
     * @memberof Page
     */
    'level': number;
    /**
     * Whether page is orphaned (not in tree structure)
     * @type {boolean}
     * @memberof Page
     */
    'orphan'?: boolean;
    /**
     * Array of parking lot configurations if page is parked
     * @type {Array<string>}
     * @memberof Page
     */
    'parked'?: Array<string>;
    /**
     * Page visibility setting
     * @type {string}
     * @memberof Page
     */
    'visibility'?: PageVisibilityEnum;
    /**
     * Page type module name
     * @type {string}
     * @memberof Page
     */
    'type': string;
    /**
     * Page title
     * @type {string}
     * @memberof Page
     */
    'title': string;
    /**
     * 
     * @type {PageMain}
     * @memberof Page
     */
    'main'?: PageMain;
    /**
     * 
     * @type {PageSeoFields}
     * @memberof Page
     */
    'seoFields'?: PageSeoFields;
    /**
     * Array of ancestor page IDs in the page tree hierarchy
     * @type {Array<string>}
     * @memberof Page
     */
    '_ancestors'?: Array<string>;
    /**
     * Array of child pages (when requested with children parameter)
     * @type {Array<Page>}
     * @memberof Page
     */
    '_children'?: Array<Page>;
    /**
     * Full URL to the page
     * @type {string}
     * @memberof Page
     */
    '_url'?: string;
    /**
     * Whether current user can edit this page
     * @type {boolean}
     * @memberof Page
     */
    '_edit'?: boolean;
    /**
     * Whether current user can publish this page
     * @type {boolean}
     * @memberof Page
     */
    '_publish'?: boolean;
    /**
     * Published version of the page (when viewing drafts)
     * @type {Page}
     * @memberof Page
     */
    '_publishedDoc'?: Page;
    /**
     * Draft version of the page (when viewing published)
     * @type {Page}
     * @memberof Page
     */
    '_draftDoc'?: Page;
}

export const PageAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;

export type PageAposModeEnum = typeof PageAposModeEnum[keyof typeof PageAposModeEnum];
export const PageVisibilityEnum = {
    Public: 'public',
    LoginRequired: 'loginRequired',
    Private: 'private'
} as const;

export type PageVisibilityEnum = typeof PageVisibilityEnum[keyof typeof PageVisibilityEnum];

/**
 * 
 * @export
 * @interface PageArchive200Response
 */
export interface PageArchive200Response {
    /**
     * ID of the background job processing the archive operation
     * @type {string}
     * @memberof PageArchive200Response
     */
    'jobId': string;
}
/**
 * 
 * @export
 * @interface PageArchiveRequest
 */
export interface PageArchiveRequest {
    /**
     * Array of page IDs to archive
     * @type {Array<string>}
     * @memberof PageArchiveRequest
     */
    '_ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PageCreateRequest
 */
export interface PageCreateRequest {
    /**
     * ID of target page for positioning (_home and _archive are convenience values)
     * @type {string}
     * @memberof PageCreateRequest
     */
    '_targetId': string;
    /**
     * 
     * @type {PageCreateRequestPosition}
     * @memberof PageCreateRequest
     */
    '_position': PageCreateRequestPosition;
    /**
     * Optional ID of existing page to copy properties from
     * @type {string}
     * @memberof PageCreateRequest
     */
    '_copyingId'?: string;
    /**
     * Page title
     * @type {string}
     * @memberof PageCreateRequest
     */
    'title': string;
    /**
     * URL slug (auto-generated if not provided)
     * @type {string}
     * @memberof PageCreateRequest
     */
    'slug'?: string;
    /**
     * Page type (must be configured in your project)
     * @type {string}
     * @memberof PageCreateRequest
     */
    'type'?: string;
    /**
     * Who can view this page
     * @type {string}
     * @memberof PageCreateRequest
     */
    'visibility'?: PageCreateRequestVisibilityEnum;
}

export const PageCreateRequestVisibilityEnum = {
    Public: 'public',
    LoginRequired: 'loginRequired',
    Private: 'private'
} as const;

export type PageCreateRequestVisibilityEnum = typeof PageCreateRequestVisibilityEnum[keyof typeof PageCreateRequestVisibilityEnum];

/**
 * @type PageCreateRequestPosition
 * Position relative to target (string values) or child index (number)
 * @export
 */
export type PageCreateRequestPosition = number | string;

/**
 * 
 * @export
 * @interface PageDeleteById400Response
 */
export interface PageDeleteById400Response {
    /**
     * 
     * @type {string}
     * @memberof PageDeleteById400Response
     */
    'name'?: string;
    /**
     * 
     * @type {object}
     * @memberof PageDeleteById400Response
     */
    'data'?: object;
    /**
     * 
     * @type {string}
     * @memberof PageDeleteById400Response
     */
    'message'?: string;
}
/**
 * @type PageDotNotationUpdateValue
 * @export
 */
export type PageDotNotationUpdateValue = Array<any> | boolean | number | object | string;

/**
 * @type PageGet200Response
 * @export
 */
export type PageGet200Response = FlatPageResponse | PageTreeResponse;

/**
 * 
 * @export
 * @interface PageGetLocalesById200Response
 */
export interface PageGetLocalesById200Response {
    /**
     * 
     * @type {Array<PageGetLocalesById200ResponseResultsInner>}
     * @memberof PageGetLocalesById200Response
     */
    'results': Array<PageGetLocalesById200ResponseResultsInner>;
}
/**
 * 
 * @export
 * @interface PageGetLocalesById200ResponseResultsInner
 */
export interface PageGetLocalesById200ResponseResultsInner {
    /**
     * Document ID with locale and mode
     * @type {string}
     * @memberof PageGetLocalesById200ResponseResultsInner
     */
    '_id': string;
    /**
     * Locale identifier with mode
     * @type {string}
     * @memberof PageGetLocalesById200ResponseResultsInner
     */
    'aposLocale': string;
}
/**
 * 
 * @export
 * @interface PageLocaleResult
 */
export interface PageLocaleResult {
    /**
     * 
     * @type {string}
     * @memberof PageLocaleResult
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof PageLocaleResult
     */
    'aposLocale': string;
}
/**
 * 
 * @export
 * @interface PageLocalesResponse
 */
export interface PageLocalesResponse {
    /**
     * 
     * @type {Array<PageLocaleResult>}
     * @memberof PageLocalesResponse
     */
    'results': Array<PageLocaleResult>;
}
/**
 * 
 * @export
 * @interface PageLocalizeByIdRequest
 */
export interface PageLocalizeByIdRequest {
    /**
     * Target locale for localization
     * @type {string}
     * @memberof PageLocalizeByIdRequest
     */
    'toLocale'?: string;
}
/**
 * 
 * @export
 * @interface PageLocalizeRequest
 */
export interface PageLocalizeRequest {
    /**
     * Array of page IDs to localize
     * @type {Array<string>}
     * @memberof PageLocalizeRequest
     */
    '_ids'?: Array<string>;
    /**
     * Target locale for localization
     * @type {string}
     * @memberof PageLocalizeRequest
     */
    'toLocale'?: string;
}
/**
 * Main content area with rich content widgets
 * @export
 * @interface PageMain
 */
export interface PageMain {
    /**
     * 
     * @type {string}
     * @memberof PageMain
     */
    'metaType'?: string;
    /**
     * 
     * @type {Array<PageMainItemsInner>}
     * @memberof PageMain
     */
    'items'?: Array<PageMainItemsInner>;
}
/**
 * 
 * @export
 * @interface PageMainItemsInner
 */
export interface PageMainItemsInner {
    /**
     * 
     * @type {string}
     * @memberof PageMainItemsInner
     */
    'metaType'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageMainItemsInner
     */
    'type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PageMainItemsInner
     */
    'aposPlaceholder'?: boolean;
    /**
     * Widget content (varies by widget type)
     * @type {string}
     * @memberof PageMainItemsInner
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageMainItemsInner
     */
    '_id'?: string;
}
/**
 * 
 * @export
 * @interface PagePatchByIdRequest
 */
export interface PagePatchByIdRequest {
    /**
     * ID of target page for repositioning (required if moving page)
     * @type {string}
     * @memberof PagePatchByIdRequest
     */
    '_targetId'?: string;
    /**
     * 
     * @type {PageUpdateRequestPosition}
     * @memberof PagePatchByIdRequest
     */
    '_position'?: PageUpdateRequestPosition;
    /**
     * Updated page title
     * @type {string}
     * @memberof PagePatchByIdRequest
     */
    'title'?: string;
    /**
     * Updated URL slug
     * @type {string}
     * @memberof PagePatchByIdRequest
     */
    'slug'?: string;
    /**
     * Updated visibility setting
     * @type {string}
     * @memberof PagePatchByIdRequest
     */
    'visibility'?: PagePatchByIdRequestVisibilityEnum;
    /**
     * 
     * @type {User}
     * @memberof PagePatchByIdRequest
     */
    'updatedBy'?: User;
}

export const PagePatchByIdRequestVisibilityEnum = {
    Public: 'public',
    LoginRequired: 'loginRequired',
    Private: 'private'
} as const;

export type PagePatchByIdRequestVisibilityEnum = typeof PagePatchByIdRequestVisibilityEnum[keyof typeof PagePatchByIdRequestVisibilityEnum];

/**
 * 
 * @export
 * @interface PagePublishRequest
 */
export interface PagePublishRequest {
    /**
     * Array of page IDs to publish
     * @type {Array<string>}
     * @memberof PagePublishRequest
     */
    '_ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PagePutByIdRequest
 */
export interface PagePutByIdRequest {
    /**
     * ID of target page for positioning (_home and _archive are convenience values)
     * @type {string}
     * @memberof PagePutByIdRequest
     */
    '_targetId': string;
    /**
     * 
     * @type {PageCreateRequestPosition}
     * @memberof PagePutByIdRequest
     */
    '_position': PageCreateRequestPosition;
    /**
     * Optional ID of existing page to copy properties from
     * @type {string}
     * @memberof PagePutByIdRequest
     */
    '_copyingId'?: string;
    /**
     * Page title
     * @type {string}
     * @memberof PagePutByIdRequest
     */
    'title': string;
    /**
     * URL slug (auto-generated if not provided)
     * @type {string}
     * @memberof PagePutByIdRequest
     */
    'slug'?: string;
    /**
     * Page type (must be configured in your project)
     * @type {string}
     * @memberof PagePutByIdRequest
     */
    'type'?: string;
    /**
     * Who can view this page
     * @type {string}
     * @memberof PagePutByIdRequest
     */
    'visibility'?: PagePutByIdRequestVisibilityEnum;
}

export const PagePutByIdRequestVisibilityEnum = {
    Public: 'public',
    LoginRequired: 'loginRequired',
    Private: 'private'
} as const;

export type PagePutByIdRequestVisibilityEnum = typeof PagePutByIdRequestVisibilityEnum[keyof typeof PagePutByIdRequestVisibilityEnum];

/**
 * SEO metadata for the page
 * @export
 * @interface PageSeoFields
 */
export interface PageSeoFields {
    /**
     * Meta description for search engines
     * @type {string}
     * @memberof PageSeoFields
     */
    'metaDescription'?: string;
    /**
     * Meta keywords (legacy, rarely used)
     * @type {string}
     * @memberof PageSeoFields
     */
    'metaKeywords'?: string;
    /**
     * Open Graph title for social sharing
     * @type {string}
     * @memberof PageSeoFields
     */
    'ogTitle'?: string;
    /**
     * Open Graph description for social sharing
     * @type {string}
     * @memberof PageSeoFields
     */
    'ogDescription'?: string;
    /**
     * 
     * @type {PageSeoFieldsOgImage}
     * @memberof PageSeoFields
     */
    'ogImage'?: PageSeoFieldsOgImage;
}
/**
 * Open Graph image for social sharing
 * @export
 * @interface PageSeoFieldsOgImage
 */
export interface PageSeoFieldsOgImage {
    /**
     * 
     * @type {string}
     * @memberof PageSeoFieldsOgImage
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageSeoFieldsOgImage
     */
    'title'?: string;
    /**
     * 
     * @type {PageSeoFieldsOgImageAttachment}
     * @memberof PageSeoFieldsOgImage
     */
    'attachment'?: PageSeoFieldsOgImageAttachment;
}
/**
 * 
 * @export
 * @interface PageSeoFieldsOgImageAttachment
 */
export interface PageSeoFieldsOgImageAttachment {
    /**
     * 
     * @type {string}
     * @memberof PageSeoFieldsOgImageAttachment
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageSeoFieldsOgImageAttachment
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageSeoFieldsOgImageAttachment
     */
    'extension'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageSeoFieldsOgImageAttachment
     */
    '_url'?: string;
}
/**
 * Abbreviated page information for ancestors/references
 * @export
 * @interface PageSummary
 */
export interface PageSummary {
    /**
     * 
     * @type {string}
     * @memberof PageSummary
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageSummary
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageSummary
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageSummary
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof PageSummary
     */
    '_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof PageSummary
     */
    'level'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageSummary
     */
    'rank'?: number;
}
/**
 * Complete page data with nested children structure - perfect for building navigation
 * @export
 * @interface PageTreeResponse
 */
export interface PageTreeResponse {
    /**
     * Unique document identifier
     * @type {string}
     * @memberof PageTreeResponse
     */
    '_id'?: string;
    /**
     * Whether page is excluded from navigation menus
     * @type {boolean}
     * @memberof PageTreeResponse
     */
    'orphan'?: boolean;
    /**
     * Page visibility setting - controls who can view this page
     * @type {string}
     * @memberof PageTreeResponse
     */
    'visibility'?: PageTreeResponseVisibilityEnum;
    /**
     * Page type identifier (configured in your project)
     * @type {string}
     * @memberof PageTreeResponse
     */
    'type'?: string;
    /**
     * Page title - used for navigation and SEO
     * @type {string}
     * @memberof PageTreeResponse
     */
    'title'?: string;
    /**
     * URL slug for the page
     * @type {string}
     * @memberof PageTreeResponse
     */
    'slug'?: string;
    /**
     * Order among sibling pages (for navigation sorting)
     * @type {number}
     * @memberof PageTreeResponse
     */
    'rank'?: number;
    /**
     * Page tree depth level (0 = home page)
     * @type {number}
     * @memberof PageTreeResponse
     */
    'level'?: number;
    /**
     * Ancestor path of page IDs
     * @type {string}
     * @memberof PageTreeResponse
     */
    'path'?: string;
    /**
     * Complete page URL - use this for links
     * @type {string}
     * @memberof PageTreeResponse
     */
    '_url'?: string;
    /**
     * Array of ancestor pages (for breadcrumbs)
     * @type {Array<PageSummary>}
     * @memberof PageTreeResponse
     */
    '_ancestors'?: Array<PageSummary>;
    /**
     * Array of child pages (nested structure)
     * @type {Array<PageTreeResponse>}
     * @memberof PageTreeResponse
     */
    '_children'?: Array<PageTreeResponse>;
    /**
     * ISO date of creation
     * @type {string}
     * @memberof PageTreeResponse
     */
    'createdAt'?: string;
    /**
     * ISO date of last update
     * @type {string}
     * @memberof PageTreeResponse
     */
    'updatedAt'?: string;
    /**
     * Whether page is archived (hidden from normal views)
     * @type {boolean}
     * @memberof PageTreeResponse
     */
    'archived'?: boolean;
    /**
     * Previous URLs that redirect to this page (SEO preservation)
     * @type {Array<string>}
     * @memberof PageTreeResponse
     */
    'historicUrls'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PageTreeResponse
     */
    'metaType'?: string;
    /**
     * Sortable version of title
     * @type {string}
     * @memberof PageTreeResponse
     */
    'titleSortified'?: string;
    /**
     * 
     * @type {User}
     * @memberof PageTreeResponse
     */
    'updatedBy'?: User;
    /**
     * Whether current user can edit this page
     * @type {boolean}
     * @memberof PageTreeResponse
     */
    '_edit'?: boolean;
}

export const PageTreeResponseVisibilityEnum = {
    Public: 'public',
    LoginRequired: 'loginRequired',
    Private: 'private'
} as const;

export type PageTreeResponseVisibilityEnum = typeof PageTreeResponseVisibilityEnum[keyof typeof PageTreeResponseVisibilityEnum];

/**
 * 
 * @export
 * @interface PageUpdateRequest
 */
export interface PageUpdateRequest {
    /**
     * ID of target page for repositioning (required if moving page)
     * @type {string}
     * @memberof PageUpdateRequest
     */
    '_targetId'?: string;
    /**
     * 
     * @type {PageUpdateRequestPosition}
     * @memberof PageUpdateRequest
     */
    '_position'?: PageUpdateRequestPosition;
    /**
     * Updated page title
     * @type {string}
     * @memberof PageUpdateRequest
     */
    'title'?: string;
    /**
     * Updated URL slug
     * @type {string}
     * @memberof PageUpdateRequest
     */
    'slug'?: string;
    /**
     * Updated visibility setting
     * @type {string}
     * @memberof PageUpdateRequest
     */
    'visibility'?: PageUpdateRequestVisibilityEnum;
    /**
     * 
     * @type {User}
     * @memberof PageUpdateRequest
     */
    'updatedBy'?: User;
}

export const PageUpdateRequestVisibilityEnum = {
    Public: 'public',
    LoginRequired: 'loginRequired',
    Private: 'private'
} as const;

export type PageUpdateRequestVisibilityEnum = typeof PageUpdateRequestVisibilityEnum[keyof typeof PageUpdateRequestVisibilityEnum];

/**
 * @type PageUpdateRequestPosition
 * New position (required if moving page)
 * @export
 */
export type PageUpdateRequestPosition = number | string;

/**
 * Standard response format for list endpoints
 * @export
 * @interface PaginatedResponse
 */
export interface PaginatedResponse {
    /**
     * 
     * @type {boolean}
     * @memberof PaginatedResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {PaginatedResponseData}
     * @memberof PaginatedResponse
     */
    'data'?: PaginatedResponseData;
}
/**
 * 
 * @export
 * @interface PaginatedResponseData
 */
export interface PaginatedResponseData {
    /**
     * 
     * @type {Array<object>}
     * @memberof PaginatedResponseData
     */
    'results'?: Array<object>;
    /**
     * Total number of pages
     * @type {number}
     * @memberof PaginatedResponseData
     */
    'pages'?: number;
    /**
     * Current page number (1-based)
     * @type {number}
     * @memberof PaginatedResponseData
     */
    'currentPage'?: number;
    /**
     * Total number of items across all pages
     * @type {number}
     * @memberof PaginatedResponseData
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface PasswordField
 */
export interface PasswordField {
    /**
     * Apostrophe field type id.
     * @type {string}
     * @memberof PasswordField
     */
    'type': PasswordFieldTypeEnum;
    /**
     * Human-readable label for editors.
     * @type {string}
     * @memberof PasswordField
     */
    'label': string;
    /**
     * Short helper text shown in the UI.
     * @type {string}
     * @memberof PasswordField
     */
    'help'?: string;
    /**
     * Rich helper text (HTML allowed by Apostrophe).
     * @type {string}
     * @memberof PasswordField
     */
    'htmlHelp'?: string;
    /**
     * Default password value (generally not used).
     * @type {string}
     * @memberof PasswordField
     */
    'def'?: string;
    /**
     * If true, value must be provided.
     * @type {boolean}
     * @memberof PasswordField
     */
    'required'?: boolean;
    /**
     * If true, UI should render as read-only (Apostrophe option).
     * @type {boolean}
     * @memberof PasswordField
     */
    'readOnly'?: boolean;
    /**
     * If true, hide in editor UI.
     * @type {boolean}
     * @memberof PasswordField
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {UiCondition}
     * @memberof PasswordField
     */
    'if'?: UiCondition;
    /**
     * 
     * @type {UiCondition}
     * @memberof PasswordField
     */
    'requiredIf'?: UiCondition;
    /**
     * Minimum number of characters required.
     * @type {number}
     * @memberof PasswordField
     */
    'min'?: number;
    /**
     * Maximum number of characters allowed.
     * @type {number}
     * @memberof PasswordField
     */
    'max'?: number;
    /**
     * Regex to enforce password rules (e.g., at least one number).
     * @type {string}
     * @memberof PasswordField
     */
    'pattern'?: string;
    /**
     * HTML autocomplete attribute, usually \"new-password\" or \"current-password\".
     * @type {string}
     * @memberof PasswordField
     */
    'autocomplete'?: string;
}

export const PasswordFieldTypeEnum = {
    Password: 'password'
} as const;

export type PasswordFieldTypeEnum = typeof PasswordFieldTypeEnum[keyof typeof PasswordFieldTypeEnum];

/**
 * 
 * @export
 * @interface PieceResponse
 */
export interface PieceResponse {
    /**
     * Whether the request was successful
     * @type {boolean}
     * @memberof PieceResponse
     */
    'success'?: boolean;
    /**
     * The piece data
     * @type {object}
     * @memberof PieceResponse
     */
    'data'?: object;
    /**
     * Error message if success is false
     * @type {string}
     * @memberof PieceResponse
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface RadioField
 */
export interface RadioField {
    /**
     * Apostrophe field type id.
     * @type {string}
     * @memberof RadioField
     */
    'type': RadioFieldTypeEnum;
    /**
     * Human-readable label for editors.
     * @type {string}
     * @memberof RadioField
     */
    'label': string;
    /**
     * Short helper text shown in the UI.
     * @type {string}
     * @memberof RadioField
     */
    'help'?: string;
    /**
     * Rich helper text (HTML allowed by Apostrophe).
     * @type {string}
     * @memberof RadioField
     */
    'htmlHelp'?: string;
    /**
     * 
     * @type {RadioFieldAllOfDef}
     * @memberof RadioField
     */
    'def'?: RadioFieldAllOfDef;
    /**
     * If true, value must be provided.
     * @type {boolean}
     * @memberof RadioField
     */
    'required'?: boolean;
    /**
     * If true, UI should render as read-only (Apostrophe option).
     * @type {boolean}
     * @memberof RadioField
     */
    'readOnly'?: boolean;
    /**
     * If true, hide in editor UI.
     * @type {boolean}
     * @memberof RadioField
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {UiCondition}
     * @memberof RadioField
     */
    'if'?: UiCondition;
    /**
     * 
     * @type {UiCondition}
     * @memberof RadioField
     */
    'requiredIf'?: UiCondition;
    /**
     * 
     * @type {RadioFieldAllOfChoices}
     * @memberof RadioField
     */
    'choices': RadioFieldAllOfChoices;
    /**
     * 
     * @type {RadioFieldAllOfFollowing}
     * @memberof RadioField
     */
    'following'?: RadioFieldAllOfFollowing;
    /**
     * 
     * @type {RadioFieldAllOfFollowingIgnore}
     * @memberof RadioField
     */
    'followingIgnore'?: RadioFieldAllOfFollowingIgnore;
}

export const RadioFieldTypeEnum = {
    Radio: 'radio'
} as const;

export type RadioFieldTypeEnum = typeof RadioFieldTypeEnum[keyof typeof RadioFieldTypeEnum];

/**
 * @type RadioFieldAllOfChoices
 * @export
 */
export type RadioFieldAllOfChoices = Array<SelectChoice> | string;

/**
 * @type RadioFieldAllOfDef
 * Default selected value.
 * @export
 */
export type RadioFieldAllOfDef = boolean | number | string;

/**
 * @type RadioFieldAllOfFollowing
 * Populate dynamically based on other fields (supports `<` parent prefixes).
 * @export
 */
export type RadioFieldAllOfFollowing = Array<string> | string;

/**
 * @type RadioFieldAllOfFollowingIgnore
 * Ignore some or all followed fields when generating values.
 * @export
 */
export type RadioFieldAllOfFollowingIgnore = Array<string> | boolean;

/**
 * 
 * @export
 * @interface RangeField
 */
export interface RangeField {
    /**
     * Apostrophe field type id.
     * @type {string}
     * @memberof RangeField
     */
    'type': RangeFieldTypeEnum;
    /**
     * Human-readable label for editors.
     * @type {string}
     * @memberof RangeField
     */
    'label': string;
    /**
     * Short helper text shown in the UI.
     * @type {string}
     * @memberof RangeField
     */
    'help'?: string;
    /**
     * Rich helper text (HTML allowed by Apostrophe).
     * @type {string}
     * @memberof RangeField
     */
    'htmlHelp'?: string;
    /**
     * Default slider value in the editor UI.
     * @type {number}
     * @memberof RangeField
     */
    'def'?: number;
    /**
     * If true, value must be provided.
     * @type {boolean}
     * @memberof RangeField
     */
    'required'?: boolean;
    /**
     * If true, UI should render as read-only (Apostrophe option).
     * @type {boolean}
     * @memberof RangeField
     */
    'readOnly'?: boolean;
    /**
     * If true, hide in editor UI.
     * @type {boolean}
     * @memberof RangeField
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {UiCondition}
     * @memberof RangeField
     */
    'if'?: UiCondition;
    /**
     * 
     * @type {UiCondition}
     * @memberof RangeField
     */
    'requiredIf'?: UiCondition;
    /**
     * Minimum value for the slider.
     * @type {number}
     * @memberof RangeField
     */
    'min'?: number;
    /**
     * Maximum value for the slider.
     * @type {number}
     * @memberof RangeField
     */
    'max'?: number;
    /**
     * Increment step for the slider. If omitted, defaults to 1.
     * @type {number}
     * @memberof RangeField
     */
    'step'?: number;
}

export const RangeFieldTypeEnum = {
    Range: 'range'
} as const;

export type RangeFieldTypeEnum = typeof RangeFieldTypeEnum[keyof typeof RangeFieldTypeEnum];

/**
 * One relationship entry. Always includes the related document `_id`. If you declared per-relationship `fields`, those values are stored alongside `_id` here. 
 * @export
 * @interface RelationshipEntry
 */
export interface RelationshipEntry {
    [key: string]: any;

    /**
     * Id of the related document.
     * @type {string}
     * @memberof RelationshipEntry
     */
    '_id': string;
}
/**
 * 
 * @export
 * @interface RelationshipField
 */
export interface RelationshipField {
    /**
     * Apostrophe field type id.
     * @type {string}
     * @memberof RelationshipField
     */
    'type': RelationshipFieldTypeEnum;
    /**
     * Human-readable label for editors.
     * @type {string}
     * @memberof RelationshipField
     */
    'label': string;
    /**
     * Short helper text shown in the UI.
     * @type {string}
     * @memberof RelationshipField
     */
    'help'?: string;
    /**
     * Rich helper text (HTML allowed by Apostrophe).
     * @type {string}
     * @memberof RelationshipField
     */
    'htmlHelp'?: string;
    /**
     * 
     * @type {any}
     * @memberof RelationshipField
     */
    'def'?: any;
    /**
     * If true, value must be provided.
     * @type {boolean}
     * @memberof RelationshipField
     */
    'required'?: boolean;
    /**
     * If true, UI should render as read-only (Apostrophe option).
     * @type {boolean}
     * @memberof RelationshipField
     */
    'readOnly'?: boolean;
    /**
     * If true, hide in editor UI.
     * @type {boolean}
     * @memberof RelationshipField
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {UiCondition}
     * @memberof RelationshipField
     */
    'if'?: UiCondition;
    /**
     * 
     * @type {UiCondition}
     * @memberof RelationshipField
     */
    'requiredIf'?: UiCondition;
    /**
     * Module name of the related doc type (e.g., \"article\", \"@apostrophecms/image\").
     * @type {string}
     * @memberof RelationshipField
     */
    'withType': string;
    /**
     * Minimum number of related docs required (inclusive).
     * @type {number}
     * @memberof RelationshipField
     */
    'min'?: number;
    /**
     * Maximum number of related docs allowed (inclusive).
     * @type {number}
     * @memberof RelationshipField
     */
    'max'?: number;
    /**
     * 
     * @type {Fieldset}
     * @memberof RelationshipField
     */
    'fields'?: Fieldset;
    /**
     * Apostrophe cursor builders for the related query (e.g., {project: { title: 1 }, sort: { title: 1 } }). 
     * @type {{ [key: string]: any; }}
     * @memberof RelationshipField
     */
    'builders'?: { [key: string]: any; };
}

export const RelationshipFieldTypeEnum = {
    Relationship: 'relationship'
} as const;

export type RelationshipFieldTypeEnum = typeof RelationshipFieldTypeEnum[keyof typeof RelationshipFieldTypeEnum];

/**
 * 
 * @export
 * @interface RelationshipReverseField
 */
export interface RelationshipReverseField {
    /**
     * Apostrophe field type id.
     * @type {string}
     * @memberof RelationshipReverseField
     */
    'type': RelationshipReverseFieldTypeEnum;
    /**
     * Human-readable label for editors.
     * @type {string}
     * @memberof RelationshipReverseField
     */
    'label': string;
    /**
     * Short helper text shown in the UI.
     * @type {string}
     * @memberof RelationshipReverseField
     */
    'help'?: string;
    /**
     * Rich helper text (HTML allowed by Apostrophe).
     * @type {string}
     * @memberof RelationshipReverseField
     */
    'htmlHelp'?: string;
    /**
     * 
     * @type {any}
     * @memberof RelationshipReverseField
     */
    'def'?: any;
    /**
     * If true, value must be provided.
     * @type {boolean}
     * @memberof RelationshipReverseField
     */
    'required'?: boolean;
    /**
     * If true, UI should render as read-only (Apostrophe option).
     * @type {boolean}
     * @memberof RelationshipReverseField
     */
    'readOnly'?: boolean;
    /**
     * If true, hide in editor UI.
     * @type {boolean}
     * @memberof RelationshipReverseField
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {UiCondition}
     * @memberof RelationshipReverseField
     */
    'if'?: UiCondition;
    /**
     * 
     * @type {UiCondition}
     * @memberof RelationshipReverseField
     */
    'requiredIf'?: UiCondition;
    /**
     * Module name that holds the forward relationship.
     * @type {string}
     * @memberof RelationshipReverseField
     */
    'withType': string;
    /**
     * Name of the forward relationship field on `withType` (e.g.,\"_authors\" on \"article\"). 
     * @type {string}
     * @memberof RelationshipReverseField
     */
    'reverseOf': string;
    /**
     * Cursor builders applied when populating the reverse join.
     * @type {{ [key: string]: any; }}
     * @memberof RelationshipReverseField
     */
    'builders'?: { [key: string]: any; };
}

export const RelationshipReverseFieldTypeEnum = {
    RelationshipReverse: 'relationshipReverse'
} as const;

export type RelationshipReverseFieldTypeEnum = typeof RelationshipReverseFieldTypeEnum[keyof typeof RelationshipReverseFieldTypeEnum];

/**
 * 
 * @export
 * @interface SameHostnameResponse
 */
export interface SameHostnameResponse {
    [key: string]: any;

    /**
     * Path to redirect to within same hostname
     * @type {string}
     * @memberof SameHostnameResponse
     */
    'redirectTo': string;
}
/**
 * 
 * @export
 * @interface SelectChoice
 */
export interface SelectChoice {
    [key: string]: any;

    /**
     * Human-friendly label shown in UI.
     * @type {string}
     * @memberof SelectChoice
     */
    'label': string;
    /**
     * 
     * @type {SelectChoiceValue}
     * @memberof SelectChoice
     */
    'value': SelectChoiceValue;
    /**
     * If true, show but disable this option.
     * @type {boolean}
     * @memberof SelectChoice
     */
    'disabled'?: boolean;
}
/**
 * @type SelectChoiceValue
 * The stored value for this choice.
 * @export
 */
export type SelectChoiceValue = boolean | number | string;

/**
 * 
 * @export
 * @interface SelectField
 */
export interface SelectField {
    /**
     * Apostrophe field type id.
     * @type {string}
     * @memberof SelectField
     */
    'type': SelectFieldTypeEnum;
    /**
     * Human-readable label for editors.
     * @type {string}
     * @memberof SelectField
     */
    'label': string;
    /**
     * Short helper text shown in the UI.
     * @type {string}
     * @memberof SelectField
     */
    'help'?: string;
    /**
     * Rich helper text (HTML allowed by Apostrophe).
     * @type {string}
     * @memberof SelectField
     */
    'htmlHelp'?: string;
    /**
     * 
     * @type {SelectFieldAllOfDef}
     * @memberof SelectField
     */
    'def'?: SelectFieldAllOfDef;
    /**
     * If true, value must be provided.
     * @type {boolean}
     * @memberof SelectField
     */
    'required'?: boolean;
    /**
     * If true, UI should render as read-only (Apostrophe option).
     * @type {boolean}
     * @memberof SelectField
     */
    'readOnly'?: boolean;
    /**
     * If true, hide in editor UI.
     * @type {boolean}
     * @memberof SelectField
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {UiCondition}
     * @memberof SelectField
     */
    'if'?: UiCondition;
    /**
     * 
     * @type {UiCondition}
     * @memberof SelectField
     */
    'requiredIf'?: UiCondition;
    /**
     * Allow selecting multiple values (stores an array).
     * @type {boolean}
     * @memberof SelectField
     */
    'multiple'?: boolean;
    /**
     * 
     * @type {SelectFieldAllOfChoices}
     * @memberof SelectField
     */
    'choices'?: SelectFieldAllOfChoices;
    /**
     * 
     * @type {SelectFieldAllOfFollowing}
     * @memberof SelectField
     */
    'following'?: SelectFieldAllOfFollowing;
    /**
     * 
     * @type {SelectFieldAllOfFollowingIgnore}
     * @memberof SelectField
     */
    'followingIgnore'?: SelectFieldAllOfFollowingIgnore;
}

export const SelectFieldTypeEnum = {
    Select: 'select'
} as const;

export type SelectFieldTypeEnum = typeof SelectFieldTypeEnum[keyof typeof SelectFieldTypeEnum];

/**
 * @type SelectFieldAllOfChoices
 * @export
 */
export type SelectFieldAllOfChoices = Array<SelectChoice> | string;

/**
 * @type SelectFieldAllOfDef
 * Default value. If `multiple: true`, this should be an array. 
 * @export
 */
export type SelectFieldAllOfDef = Array<CheckboxesFieldAllOfDef> | boolean | number | string;

/**
 * @type SelectFieldAllOfFollowing
 * Populate dynamically based on other fieldsâ€™ values (supports `<` parent prefixes).
 * @export
 */
export type SelectFieldAllOfFollowing = Array<string> | string;

/**
 * @type SelectFieldAllOfFollowingIgnore
 * Ignore some or all followed fields when generating values.
 * @export
 */
export type SelectFieldAllOfFollowingIgnore = Array<string> | boolean;

/**
 * 
 * @export
 * @interface SlugField
 */
export interface SlugField {
    /**
     * Apostrophe field type id.
     * @type {string}
     * @memberof SlugField
     */
    'type': SlugFieldTypeEnum;
    /**
     * Human-readable label for editors.
     * @type {string}
     * @memberof SlugField
     */
    'label': string;
    /**
     * Short helper text shown in the UI.
     * @type {string}
     * @memberof SlugField
     */
    'help'?: string;
    /**
     * Rich helper text (HTML allowed by Apostrophe).
     * @type {string}
     * @memberof SlugField
     */
    'htmlHelp'?: string;
    /**
     * Default slug value shown in the editor UI.
     * @type {string}
     * @memberof SlugField
     */
    'def'?: string;
    /**
     * If true, value must be provided.
     * @type {boolean}
     * @memberof SlugField
     */
    'required'?: boolean;
    /**
     * If true, UI should render as read-only (Apostrophe option).
     * @type {boolean}
     * @memberof SlugField
     */
    'readOnly'?: boolean;
    /**
     * If true, hide in editor UI.
     * @type {boolean}
     * @memberof SlugField
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {UiCondition}
     * @memberof SlugField
     */
    'if'?: UiCondition;
    /**
     * 
     * @type {UiCondition}
     * @memberof SlugField
     */
    'requiredIf'?: UiCondition;
    /**
     * Optional prefix automatically prepended when generating the slug.
     * @type {string}
     * @memberof SlugField
     */
    'prefix'?: string;
    /**
     * Name of the field this slug should follow (usually \"title\"). Works with `following`/`followingIgnore`. 
     * @type {string}
     * @memberof SlugField
     */
    'source'?: string;
    /**
     * If true, ensures slug is unique across docs of this type.
     * @type {boolean}
     * @memberof SlugField
     */
    'unique'?: boolean;
    /**
     * Optional regex to further constrain allowed slugs.
     * @type {string}
     * @memberof SlugField
     */
    'pattern'?: string;
}

export const SlugFieldTypeEnum = {
    Slug: 'slug'
} as const;

export type SlugFieldTypeEnum = typeof SlugFieldTypeEnum[keyof typeof SlugFieldTypeEnum];

/**
 * 
 * @export
 * @interface StringField
 */
export interface StringField {
    /**
     * Apostrophe field type id.
     * @type {string}
     * @memberof StringField
     */
    'type': StringFieldTypeEnum;
    /**
     * Human-readable label for editors.
     * @type {string}
     * @memberof StringField
     */
    'label': string;
    /**
     * Short helper text shown in the UI.
     * @type {string}
     * @memberof StringField
     */
    'help'?: string;
    /**
     * Rich helper text (HTML allowed by Apostrophe).
     * @type {string}
     * @memberof StringField
     */
    'htmlHelp'?: string;
    /**
     * Default value shown in the editor UI.
     * @type {string}
     * @memberof StringField
     */
    'def'?: string;
    /**
     * If true, value must be provided.
     * @type {boolean}
     * @memberof StringField
     */
    'required'?: boolean;
    /**
     * If true, UI should render as read-only (Apostrophe option).
     * @type {boolean}
     * @memberof StringField
     */
    'readOnly'?: boolean;
    /**
     * If true, hide in editor UI.
     * @type {boolean}
     * @memberof StringField
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {UiCondition}
     * @memberof StringField
     */
    'if'?: UiCondition;
    /**
     * 
     * @type {UiCondition}
     * @memberof StringField
     */
    'requiredIf'?: UiCondition;
    /**
     * If true, renders a multiline textarea UI.
     * @type {boolean}
     * @memberof StringField
     */
    'textarea'?: boolean;
    /**
     * Minimum number of characters allowed.
     * @type {number}
     * @memberof StringField
     */
    'min'?: number;
    /**
     * Maximum number of characters allowed.
     * @type {number}
     * @memberof StringField
     */
    'max'?: number;
    /**
     * Regular expression (string form) to validate the input. Only matching values are allowed. 
     * @type {string}
     * @memberof StringField
     */
    'pattern'?: string;
    /**
     * Value of the HTML autocomplete attribute (see MDN). Use `\"off\"` to disable autocomplete. 
     * @type {string}
     * @memberof StringField
     */
    'autocomplete'?: string;
    /**
     * 
     * @type {StringFieldAllOfFollowing}
     * @memberof StringField
     */
    'following'?: StringFieldAllOfFollowing;
    /**
     * 
     * @type {StringFieldAllOfFollowingIgnore}
     * @memberof StringField
     */
    'followingIgnore'?: StringFieldAllOfFollowingIgnore;
    /**
     * If true, creates a parallel â€œsortifiedâ€ version of this field for case- and punctuation-insensitive sorting.
     * @type {boolean}
     * @memberof StringField
     */
    'sortify'?: boolean;
}

export const StringFieldTypeEnum = {
    String: 'string'
} as const;

export type StringFieldTypeEnum = typeof StringFieldTypeEnum[keyof typeof StringFieldTypeEnum];

/**
 * @type StringFieldAllOfFollowing
 * Field(s) to follow for automatic value generation. Supports `<` prefixes to access parent fields.
 * @export
 */
export type StringFieldAllOfFollowing = Array<string> | string;

/**
 * @type StringFieldAllOfFollowingIgnore
 * Controls which `following` values are ignored.
 * @export
 */
export type StringFieldAllOfFollowingIgnore = Array<string> | boolean;

/**
 * 
 * @export
 * @interface SubmittedDraft
 */
export interface SubmittedDraft {
    /**
     * Unique identifier for the submitted draft
     * @type {string}
     * @memberof SubmittedDraft
     */
    '_id': string;
    /**
     * Document type identifier
     * @type {string}
     * @memberof SubmittedDraft
     */
    'type': string;
    /**
     * Title of the submitted draft
     * @type {string}
     * @memberof SubmittedDraft
     */
    'title': string;
    /**
     * URL-friendly version of the title
     * @type {string}
     * @memberof SubmittedDraft
     */
    'slug'?: string;
    /**
     * Content of the submitted draft
     * @type {string}
     * @memberof SubmittedDraft
     */
    'content': string;
    /**
     * Author of the submitted draft
     * @type {string}
     * @memberof SubmittedDraft
     */
    'author': string;
    /**
     * ID of the user who created the draft
     * @type {string}
     * @memberof SubmittedDraft
     */
    'authorId'?: string;
    /**
     * Notes from the submitter about the draft
     * @type {string}
     * @memberof SubmittedDraft
     */
    'submissionNotes'?: string;
    /**
     * Priority level for review
     * @type {string}
     * @memberof SubmittedDraft
     */
    'priority'?: SubmittedDraftPriorityEnum;
    /**
     * Category or type of content being submitted
     * @type {string}
     * @memberof SubmittedDraft
     */
    'category'?: string;
    /**
     * Current status of the submitted draft
     * @type {string}
     * @memberof SubmittedDraft
     */
    'status': SubmittedDraftStatusEnum;
    /**
     * When the draft was submitted for review
     * @type {string}
     * @memberof SubmittedDraft
     */
    'submittedAt'?: string;
    /**
     * When the draft was last reviewed
     * @type {string}
     * @memberof SubmittedDraft
     */
    'reviewedAt'?: string;
    /**
     * ID of the user who reviewed the draft
     * @type {string}
     * @memberof SubmittedDraft
     */
    'reviewedBy'?: string;
    /**
     * Notes from the reviewer
     * @type {string}
     * @memberof SubmittedDraft
     */
    'reviewNotes'?: string;
    /**
     * When the draft was published (if applicable)
     * @type {string}
     * @memberof SubmittedDraft
     */
    'publishedAt'?: string;
    /**
     * Whether the submitted draft is archived
     * @type {boolean}
     * @memberof SubmittedDraft
     */
    'archived'?: boolean;
    /**
     * When the submitted draft was created
     * @type {string}
     * @memberof SubmittedDraft
     */
    'createdAt': string;
    /**
     * When the submitted draft was last updated
     * @type {string}
     * @memberof SubmittedDraft
     */
    'updatedAt': string;
    /**
     * Locale for this version of the content
     * @type {string}
     * @memberof SubmittedDraft
     */
    'aposLocale'?: string;
    /**
     * Content mode (draft or published)
     * @type {string}
     * @memberof SubmittedDraft
     */
    'aposMode'?: SubmittedDraftAposModeEnum;
}

export const SubmittedDraftPriorityEnum = {
    Low: 'low',
    Normal: 'normal',
    High: 'high',
    Urgent: 'urgent'
} as const;

export type SubmittedDraftPriorityEnum = typeof SubmittedDraftPriorityEnum[keyof typeof SubmittedDraftPriorityEnum];
export const SubmittedDraftStatusEnum = {
    Draft: 'draft',
    Submitted: 'submitted',
    UnderReview: 'under-review',
    Approved: 'approved',
    Rejected: 'rejected',
    Published: 'published'
} as const;

export type SubmittedDraftStatusEnum = typeof SubmittedDraftStatusEnum[keyof typeof SubmittedDraftStatusEnum];
export const SubmittedDraftAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;

export type SubmittedDraftAposModeEnum = typeof SubmittedDraftAposModeEnum[keyof typeof SubmittedDraftAposModeEnum];

/**
 * 
 * @export
 * @interface SubmittedDraftArchive200Response
 */
export interface SubmittedDraftArchive200Response {
    /**
     * 
     * @type {Array<SubmittedDraft>}
     * @memberof SubmittedDraftArchive200Response
     */
    'archived'?: Array<SubmittedDraft>;
}
/**
 * 
 * @export
 * @interface SubmittedDraftGet200Response
 */
export interface SubmittedDraftGet200Response {
    /**
     * 
     * @type {Array<SubmittedDraft>}
     * @memberof SubmittedDraftGet200Response
     */
    'results'?: Array<SubmittedDraft>;
    /**
     * Total number of pages available
     * @type {number}
     * @memberof SubmittedDraftGet200Response
     */
    'pages'?: number;
}
/**
 * 
 * @export
 * @interface SubmittedDraftLocalize200Response
 */
export interface SubmittedDraftLocalize200Response {
    /**
     * 
     * @type {Array<SubmittedDraft>}
     * @memberof SubmittedDraftLocalize200Response
     */
    'localized'?: Array<SubmittedDraft>;
}
/**
 * 
 * @export
 * @interface SubmittedDraftPatchByIdRequest
 */
export interface SubmittedDraftPatchByIdRequest {
    /**
     * Updated title of the submitted draft
     * @type {string}
     * @memberof SubmittedDraftPatchByIdRequest
     */
    'title'?: string;
    /**
     * Updated content of the submitted draft
     * @type {string}
     * @memberof SubmittedDraftPatchByIdRequest
     */
    'content'?: string;
    /**
     * Updated notes about the submission
     * @type {string}
     * @memberof SubmittedDraftPatchByIdRequest
     */
    'submissionNotes'?: string;
    /**
     * Updated priority level for review
     * @type {string}
     * @memberof SubmittedDraftPatchByIdRequest
     */
    'priority'?: SubmittedDraftPatchByIdRequestPriorityEnum;
}

export const SubmittedDraftPatchByIdRequestPriorityEnum = {
    Low: 'low',
    Normal: 'normal',
    High: 'high',
    Urgent: 'urgent'
} as const;

export type SubmittedDraftPatchByIdRequestPriorityEnum = typeof SubmittedDraftPatchByIdRequestPriorityEnum[keyof typeof SubmittedDraftPatchByIdRequestPriorityEnum];

/**
 * 
 * @export
 * @interface SubmittedDraftPostRequest
 */
export interface SubmittedDraftPostRequest {
    /**
     * Title of the submitted draft
     * @type {string}
     * @memberof SubmittedDraftPostRequest
     */
    'title'?: string;
    /**
     * Content of the submitted draft
     * @type {string}
     * @memberof SubmittedDraftPostRequest
     */
    'content'?: string;
    /**
     * Author of the submitted draft
     * @type {string}
     * @memberof SubmittedDraftPostRequest
     */
    'author'?: string;
    /**
     * Notes from the submitter about the draft
     * @type {string}
     * @memberof SubmittedDraftPostRequest
     */
    'submissionNotes'?: string;
    /**
     * Priority level for review
     * @type {string}
     * @memberof SubmittedDraftPostRequest
     */
    'priority'?: SubmittedDraftPostRequestPriorityEnum;
    /**
     * Category or type of content being submitted
     * @type {string}
     * @memberof SubmittedDraftPostRequest
     */
    'category'?: string;
}

export const SubmittedDraftPostRequestPriorityEnum = {
    Low: 'low',
    Normal: 'normal',
    High: 'high',
    Urgent: 'urgent'
} as const;

export type SubmittedDraftPostRequestPriorityEnum = typeof SubmittedDraftPostRequestPriorityEnum[keyof typeof SubmittedDraftPostRequestPriorityEnum];

/**
 * 
 * @export
 * @interface SubmittedDraftPublish200Response
 */
export interface SubmittedDraftPublish200Response {
    /**
     * 
     * @type {Array<SubmittedDraft>}
     * @memberof SubmittedDraftPublish200Response
     */
    'published'?: Array<SubmittedDraft>;
}
/**
 * 
 * @export
 * @interface SubmittedDraftPutByIdRequest
 */
export interface SubmittedDraftPutByIdRequest {
    /**
     * Title of the submitted draft
     * @type {string}
     * @memberof SubmittedDraftPutByIdRequest
     */
    'title': string;
    /**
     * Content of the submitted draft
     * @type {string}
     * @memberof SubmittedDraftPutByIdRequest
     */
    'content': string;
    /**
     * Author of the submitted draft
     * @type {string}
     * @memberof SubmittedDraftPutByIdRequest
     */
    'author'?: string;
    /**
     * Notes about the submission
     * @type {string}
     * @memberof SubmittedDraftPutByIdRequest
     */
    'submissionNotes'?: string;
    /**
     * Priority level for review
     * @type {string}
     * @memberof SubmittedDraftPutByIdRequest
     */
    'priority'?: SubmittedDraftPutByIdRequestPriorityEnum;
}

export const SubmittedDraftPutByIdRequestPriorityEnum = {
    Low: 'low',
    Normal: 'normal',
    High: 'high',
    Urgent: 'urgent'
} as const;

export type SubmittedDraftPutByIdRequestPriorityEnum = typeof SubmittedDraftPutByIdRequestPriorityEnum[keyof typeof SubmittedDraftPutByIdRequestPriorityEnum];

/**
 * 
 * @export
 * @interface SubmittedDraftRestore200Response
 */
export interface SubmittedDraftRestore200Response {
    /**
     * 
     * @type {Array<SubmittedDraft>}
     * @memberof SubmittedDraftRestore200Response
     */
    'restored'?: Array<SubmittedDraft>;
}
/**
 * 
 * @export
 * @interface TimeField
 */
export interface TimeField {
    /**
     * Apostrophe field type id.
     * @type {string}
     * @memberof TimeField
     */
    'type': TimeFieldTypeEnum;
    /**
     * Human-readable label for editors.
     * @type {string}
     * @memberof TimeField
     */
    'label': string;
    /**
     * Short helper text shown in the UI.
     * @type {string}
     * @memberof TimeField
     */
    'help'?: string;
    /**
     * Rich helper text (HTML allowed by Apostrophe).
     * @type {string}
     * @memberof TimeField
     */
    'htmlHelp'?: string;
    /**
     * Default value in HH:MM:SS (24-hour). If not set and not required, defaults to the current time. 
     * @type {string}
     * @memberof TimeField
     */
    'def'?: string;
    /**
     * If true, value must be provided.
     * @type {boolean}
     * @memberof TimeField
     */
    'required'?: boolean;
    /**
     * If true, UI should render as read-only (Apostrophe option).
     * @type {boolean}
     * @memberof TimeField
     */
    'readOnly'?: boolean;
    /**
     * If true, hide in editor UI.
     * @type {boolean}
     * @memberof TimeField
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {UiCondition}
     * @memberof TimeField
     */
    'if'?: UiCondition;
    /**
     * 
     * @type {UiCondition}
     * @memberof TimeField
     */
    'requiredIf'?: UiCondition;
}

export const TimeFieldTypeEnum = {
    Time: 'time'
} as const;

export type TimeFieldTypeEnum = typeof TimeFieldTypeEnum[keyof typeof TimeFieldTypeEnum];

/**
 * \'Apostrophe conditional used by `if` and `requiredIf`. Keys are field paths (including `<` parent access and dot notation) or method calls with `()`. Values are either simple equality (primitive) or an operator object. Supports `$or` / `$and` groups. See OperatorObject. 
 * @export
 * @interface UiCondition
 */
export interface UiCondition {
    [key: string]: any;

    /**
     * Any condition group may pass. :contentReference[oaicite:1]{index=1}
     * @type {Array<UiCondition>}
     * @memberof UiCondition
     */
    '$or'?: Array<UiCondition>;
    /**
     * All condition groups must pass. (Redundant at the same level, but useful when nested with `$or`.) :contentReference[oaicite:2]{index=2}
     * @type {Array<UiCondition>}
     * @memberof UiCondition
     */
    '$and'?: Array<UiCondition>;
}
/**
 * 
 * @export
 * @interface UrlField
 */
export interface UrlField {
    /**
     * Apostrophe field type id.
     * @type {string}
     * @memberof UrlField
     */
    'type': UrlFieldTypeEnum;
    /**
     * Human-readable label for editors.
     * @type {string}
     * @memberof UrlField
     */
    'label': string;
    /**
     * Short helper text shown in the UI.
     * @type {string}
     * @memberof UrlField
     */
    'help'?: string;
    /**
     * Rich helper text (HTML allowed by Apostrophe).
     * @type {string}
     * @memberof UrlField
     */
    'htmlHelp'?: string;
    /**
     * Default URL shown in the editor UI.
     * @type {string}
     * @memberof UrlField
     */
    'def'?: string;
    /**
     * If true, value must be provided.
     * @type {boolean}
     * @memberof UrlField
     */
    'required'?: boolean;
    /**
     * If true, UI should render as read-only (Apostrophe option).
     * @type {boolean}
     * @memberof UrlField
     */
    'readOnly'?: boolean;
    /**
     * If true, hide in editor UI.
     * @type {boolean}
     * @memberof UrlField
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {UiCondition}
     * @memberof UrlField
     */
    'if'?: UiCondition;
    /**
     * 
     * @type {UiCondition}
     * @memberof UrlField
     */
    'requiredIf'?: UiCondition;
    /**
     * Optional regex for stricter validation of allowed URLs (in addition to standard URI syntax).
     * @type {string}
     * @memberof UrlField
     */
    'pattern'?: string;
    /**
     * Value for the HTML autocomplete attribute. Common values include \"url\" or \"off\".
     * @type {string}
     * @memberof UrlField
     */
    'autocomplete'?: string;
}

export const UrlFieldTypeEnum = {
    Url: 'url'
} as const;

export type UrlFieldTypeEnum = typeof UrlFieldTypeEnum[keyof typeof UrlFieldTypeEnum];

/**
 * Built-in user piece type for account management.  **Base Properties**: Inherited from @apostrophecms/piece-type **User-Specific Properties**: title, username, email, role, disabled  ðŸ’¡ Developers can add custom fields to the user piece type in their project configuration. 
 * @export
 * @interface User
 */
export interface User {
    /**
     * Unique identifier
     * @type {string}
     * @memberof User
     */
    '_id'?: string;
    /**
     * User\'s display name
     * @type {string}
     * @memberof User
     */
    'title'?: string;
    /**
     * Login username (must be unique)
     * @type {string}
     * @memberof User
     */
    'username'?: string;
    /**
     * User\'s email address
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * User role - determines permissions
     * @type {string}
     * @memberof User
     */
    'role'?: UserRoleEnum;
    /**
     * Whether the user account is disabled
     * @type {boolean}
     * @memberof User
     */
    'disabled'?: boolean;
    /**
     * Whether the user is archived
     * @type {boolean}
     * @memberof User
     */
    'archived'?: boolean;
    /**
     * Visibility setting
     * @type {string}
     * @memberof User
     */
    'visibility'?: UserVisibilityEnum;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'slug'?: string;
    /**
     * Account creation date
     * @type {string}
     * @memberof User
     */
    'createdAt'?: string;
    /**
     * Last update date
     * @type {string}
     * @memberof User
     */
    'updatedAt'?: string;
}

export const UserRoleEnum = {
    Guest: 'guest',
    Contributor: 'contributor',
    Editor: 'editor',
    Admin: 'admin'
} as const;

export type UserRoleEnum = typeof UserRoleEnum[keyof typeof UserRoleEnum];
export const UserVisibilityEnum = {
    Public: 'public',
    LoginRequired: 'loginRequired'
} as const;

export type UserVisibilityEnum = typeof UserVisibilityEnum[keyof typeof UserVisibilityEnum];

/**
 * 
 * @export
 * @interface UserCreateRequest
 */
export interface UserCreateRequest {
    /**
     * Display name for the user
     * @type {string}
     * @memberof UserCreateRequest
     */
    'title': string;
    /**
     * Unique username for login
     * @type {string}
     * @memberof UserCreateRequest
     */
    'username': string;
    /**
     * User\'s email address
     * @type {string}
     * @memberof UserCreateRequest
     */
    'email': string;
    /**
     * User\'s password
     * @type {string}
     * @memberof UserCreateRequest
     */
    'password'?: string;
    /**
     * User\'s first name
     * @type {string}
     * @memberof UserCreateRequest
     */
    'firstName'?: string;
    /**
     * User\'s last name
     * @type {string}
     * @memberof UserCreateRequest
     */
    'lastName'?: string;
    /**
     * User\'s role/permission level
     * @type {string}
     * @memberof UserCreateRequest
     */
    'role'?: string;
    /**
     * Whether the user account is disabled
     * @type {boolean}
     * @memberof UserCreateRequest
     */
    'disabled'?: boolean;
}
/**
 * 
 * @export
 * @interface UserList200Response
 */
export interface UserList200Response {
    /**
     * 
     * @type {Array<User>}
     * @memberof UserList200Response
     */
    'results'?: Array<User>;
    /**
     * Total number of pages
     * @type {number}
     * @memberof UserList200Response
     */
    'pages'?: number;
    /**
     * Current page number
     * @type {number}
     * @memberof UserList200Response
     */
    'currentPage'?: number;
}
/**
 * 
 * @export
 * @interface UserPatchByIdRequest
 */
export interface UserPatchByIdRequest {
    /**
     * Display name for the user
     * @type {string}
     * @memberof UserPatchByIdRequest
     */
    'title'?: string;
    /**
     * User\'s email address
     * @type {string}
     * @memberof UserPatchByIdRequest
     */
    'email'?: string;
    /**
     * User\'s first name
     * @type {string}
     * @memberof UserPatchByIdRequest
     */
    'firstName'?: string;
    /**
     * User\'s last name
     * @type {string}
     * @memberof UserPatchByIdRequest
     */
    'lastName'?: string;
    /**
     * User\'s role/permission level
     * @type {string}
     * @memberof UserPatchByIdRequest
     */
    'role'?: string;
    /**
     * Whether the user account is disabled
     * @type {boolean}
     * @memberof UserPatchByIdRequest
     */
    'disabled'?: boolean;
}
/**
 * 
 * @export
 * @interface UserPutByIdRequest
 */
export interface UserPutByIdRequest {
    /**
     * Display name for the user
     * @type {string}
     * @memberof UserPutByIdRequest
     */
    'title': string;
    /**
     * Unique username for login
     * @type {string}
     * @memberof UserPutByIdRequest
     */
    'username': string;
    /**
     * User\'s email address
     * @type {string}
     * @memberof UserPutByIdRequest
     */
    'email': string;
    /**
     * User\'s first name
     * @type {string}
     * @memberof UserPutByIdRequest
     */
    'firstName'?: string;
    /**
     * User\'s last name
     * @type {string}
     * @memberof UserPutByIdRequest
     */
    'lastName'?: string;
    /**
     * User\'s role/permission level
     * @type {string}
     * @memberof UserPutByIdRequest
     */
    'role'?: string;
    /**
     * Whether the user account is disabled
     * @type {boolean}
     * @memberof UserPutByIdRequest
     */
    'disabled'?: boolean;
}
/**
 * Content widget within an area - represents a piece of structured content
 * @export
 * @interface Widget
 */
export interface Widget {
    /**
     * 
     * @type {string}
     * @memberof Widget
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Widget
     */
    'metaType'?: WidgetMetaTypeEnum;
    /**
     * Widget type (e.g., rich-text, image, custom widgets)
     * @type {string}
     * @memberof Widget
     */
    'type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Widget
     */
    '_edit'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Widget
     */
    '_docId'?: string;
    /**
     * HTML content for rich text widgets (filtered based on widget configuration)
     * @type {string}
     * @memberof Widget
     */
    'content'?: string;
    /**
     * 
     * @type {WidgetImport}
     * @memberof Widget
     */
    'import'?: WidgetImport;
}

export const WidgetMetaTypeEnum = {
    Widget: 'widget'
} as const;

export type WidgetMetaTypeEnum = typeof WidgetMetaTypeEnum[keyof typeof WidgetMetaTypeEnum];

/**
 * Import configuration for external content (used during creation/update)
 * @export
 * @interface WidgetImport
 */
export interface WidgetImport {
    /**
     * Base URL for resolving relative image URLs
     * @type {string}
     * @memberof WidgetImport
     */
    'baseUrl'?: string;
    /**
     * HTML content to import (images will be automatically imported)
     * @type {string}
     * @memberof WidgetImport
     */
    'html'?: string;
    /**
     * Array of existing @apostrophecms/image-tag piece _ids to apply to imported images
     * @type {Array<string>}
     * @memberof WidgetImport
     */
    'imageTags'?: Array<string>;
}

/**
 * AttachmentsApi - axios parameter creator
 * @export
 */
export const AttachmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a cropped version of an existing image attachment. The crop object is appended to the crops array property of the attachment document. The newly uploaded image file will be stored with a filename using the crop properties: {_id}-{name}.{top}.{left}.{width}.{height}.{extension} 
         * @summary Crop image attachment
         * @param {AttachmentCropRequest} attachmentCropRequest 
         * @param {AttachmentCropAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachmentCrop: async (attachmentCropRequest: AttachmentCropRequest, aposMode?: AttachmentCropAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'attachmentCropRequest' is not null or undefined
            assertParamExists('attachmentCrop', 'attachmentCropRequest', attachmentCropRequest)
            const localVarPath = `/@apostrophecms/attachment/crop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachmentCropRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a media file to create an attachment. The uploaded file can then be used to create image or file documents. Uses multipart/form-data encoding with the file uploaded under the name \'file\'. 
         * @summary Upload media file
         * @param {File} file The file to upload
         * @param {AttachmentUploadAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachmentUpload: async (file: File, aposMode?: AttachmentUploadAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('attachmentUpload', 'file', file)
            const localVarPath = `/@apostrophecms/attachment/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AttachmentsApi - functional programming interface
 * @export
 */
export const AttachmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AttachmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a cropped version of an existing image attachment. The crop object is appended to the crops array property of the attachment document. The newly uploaded image file will be stored with a filename using the crop properties: {_id}-{name}.{top}.{left}.{width}.{height}.{extension} 
         * @summary Crop image attachment
         * @param {AttachmentCropRequest} attachmentCropRequest 
         * @param {AttachmentCropAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachmentCrop(attachmentCropRequest: AttachmentCropRequest, aposMode?: AttachmentCropAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachmentCrop(attachmentCropRequest, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttachmentsApi.attachmentCrop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload a media file to create an attachment. The uploaded file can then be used to create image or file documents. Uses multipart/form-data encoding with the file uploaded under the name \'file\'. 
         * @summary Upload media file
         * @param {File} file The file to upload
         * @param {AttachmentUploadAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachmentUpload(file: File, aposMode?: AttachmentUploadAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachmentUpload(file, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttachmentsApi.attachmentUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AttachmentsApi - factory interface
 * @export
 */
export const AttachmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AttachmentsApiFp(configuration)
    return {
        /**
         * Create a cropped version of an existing image attachment. The crop object is appended to the crops array property of the attachment document. The newly uploaded image file will be stored with a filename using the crop properties: {_id}-{name}.{top}.{left}.{width}.{height}.{extension} 
         * @summary Crop image attachment
         * @param {AttachmentCropRequest} attachmentCropRequest 
         * @param {AttachmentCropAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachmentCrop(attachmentCropRequest: AttachmentCropRequest, aposMode?: AttachmentCropAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.attachmentCrop(attachmentCropRequest, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a media file to create an attachment. The uploaded file can then be used to create image or file documents. Uses multipart/form-data encoding with the file uploaded under the name \'file\'. 
         * @summary Upload media file
         * @param {File} file The file to upload
         * @param {AttachmentUploadAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachmentUpload(file: File, aposMode?: AttachmentUploadAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<Attachment> {
            return localVarFp.attachmentUpload(file, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AttachmentsApi - object-oriented interface
 * @export
 * @class AttachmentsApi
 * @extends {BaseAPI}
 */
export class AttachmentsApi extends BaseAPI {
    /**
     * Create a cropped version of an existing image attachment. The crop object is appended to the crops array property of the attachment document. The newly uploaded image file will be stored with a filename using the crop properties: {_id}-{name}.{top}.{left}.{width}.{height}.{extension} 
     * @summary Crop image attachment
     * @param {AttachmentCropRequest} attachmentCropRequest 
     * @param {AttachmentCropAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public attachmentCrop(attachmentCropRequest: AttachmentCropRequest, aposMode?: AttachmentCropAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return AttachmentsApiFp(this.configuration).attachmentCrop(attachmentCropRequest, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a media file to create an attachment. The uploaded file can then be used to create image or file documents. Uses multipart/form-data encoding with the file uploaded under the name \'file\'. 
     * @summary Upload media file
     * @param {File} file The file to upload
     * @param {AttachmentUploadAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public attachmentUpload(file: File, aposMode?: AttachmentUploadAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return AttachmentsApiFp(this.configuration).attachmentUpload(file, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AttachmentCropAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type AttachmentCropAposModeEnum = typeof AttachmentCropAposModeEnum[keyof typeof AttachmentCropAposModeEnum];
/**
 * @export
 */
export const AttachmentUploadAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type AttachmentUploadAposModeEnum = typeof AttachmentUploadAposModeEnum[keyof typeof AttachmentUploadAposModeEnum];


/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **âš ï¸ DEPRECATED:** This GET endpoint is deprecated due to caching issues. Use the POST method instead.  Returns login context information including environment and requirements. This endpoint provides information about the login system configuration.  **Useful for:** - Understanding available login methods - Checking if password reset is enabled - Getting login system configuration 
         * @summary Get login context information
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authContext: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/login/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns login context information including environment and requirements. This endpoint provides information about the login system configuration.  **Note:** POST method is recommended for this endpoint to avoid caching issues.  **Useful for:** - Understanding available login methods - Checking if password reset is enabled - Getting login system configuration 
         * @summary Get login context information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authContextPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/login/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ðŸš€ **Start here!** Authenticate and receive either a bearer token or session cookie for subsequent API requests.  **Perfect for:** - Getting started with the API - Setting up authentication for your app - Testing API access  **Choose your authentication method:** - **Bearer Token** (recommended): omit `session` field or set to `false` - **Session Cookie**: set `session` to `true` and include `credentials: \'include\'` in fetch 
         * @summary Login to get authentication token
         * @param {AuthLoginRequest} authLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogin: async (authLoginRequest: AuthLoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authLoginRequest' is not null or undefined
            assertParamExists('authLogin', 'authLoginRequest', authLoginRequest)
            const localVarPath = `/@apostrophecms/login/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authLoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * End the current session or invalidate the bearer token.  **For bearer token**: include Authorization header **For session cookie**: include credentials in request 
         * @summary Logout and invalidate session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/login/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completes a password reset using the token provided in the reset email.  **âš ï¸ Note:** This endpoint is only available when `passwordReset` is enabled in the login module configuration.  Reset tokens are valid for the number of hours specified in `passwordResetHours` (default: 48 hours). 
         * @summary Complete password reset
         * @param {AuthResetRequest} authResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authReset: async (authResetRequest: AuthResetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authResetRequest' is not null or undefined
            assertParamExists('authReset', 'authResetRequest', authResetRequest)
            const localVarPath = `/@apostrophecms/login/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authResetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiates a password reset process by sending a reset link to the user\'s email address.  **âš ï¸ Note:** This endpoint is only available when `passwordReset` is enabled in the login module configuration.  **Security feature:** The user will not be notified if the email check fails or if the email fails to send. However, debug information will be output in the server terminal. 
         * @summary Request password reset
         * @param {AuthResetRequestRequest} authResetRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authResetRequest: async (authResetRequestRequest: AuthResetRequestRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authResetRequestRequest' is not null or undefined
            assertParamExists('authResetRequest', 'authResetRequestRequest', authResetRequestRequest)
            const localVarPath = `/@apostrophecms/login/reset-request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authResetRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **âš ï¸ DEPRECATED:** This GET endpoint is deprecated due to caching issues. Use the POST method instead.  Returns information about the currently authenticated user.  **Security note:** Only explicitly configured fields are returned, never the complete user object. This prevents accidental exposure of sensitive user data. 
         * @summary Get current user information
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authWhoAmI: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/login/whoami`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the currently authenticated user.  **Note:** POST method is recommended for this endpoint to avoid caching issues.  **Perfect for:** - Checking if authentication is working - Getting user details for your app - Validating permissions  **Security note:** Only explicitly configured fields are returned,  never the complete user object. This prevents accidental exposure  of sensitive user data. 
         * @summary Get current user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authWhoAmIPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/login/whoami`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * **âš ï¸ DEPRECATED:** This GET endpoint is deprecated due to caching issues. Use the POST method instead.  Returns login context information including environment and requirements. This endpoint provides information about the login system configuration.  **Useful for:** - Understanding available login methods - Checking if password reset is enabled - Getting login system configuration 
         * @summary Get login context information
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async authContext(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthContext200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authContext(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authContext']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns login context information including environment and requirements. This endpoint provides information about the login system configuration.  **Note:** POST method is recommended for this endpoint to avoid caching issues.  **Useful for:** - Understanding available login methods - Checking if password reset is enabled - Getting login system configuration 
         * @summary Get login context information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authContextPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthContextPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authContextPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authContextPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ðŸš€ **Start here!** Authenticate and receive either a bearer token or session cookie for subsequent API requests.  **Perfect for:** - Getting started with the API - Setting up authentication for your app - Testing API access  **Choose your authentication method:** - **Bearer Token** (recommended): omit `session` field or set to `false` - **Session Cookie**: set `session` to `true` and include `credentials: \'include\'` in fetch 
         * @summary Login to get authentication token
         * @param {AuthLoginRequest} authLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogin(authLoginRequest: AuthLoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthLogin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogin(authLoginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * End the current session or invalidate the bearer token.  **For bearer token**: include Authorization header **For session cookie**: include credentials in request 
         * @summary Logout and invalidate session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthLogout200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Completes a password reset using the token provided in the reset email.  **âš ï¸ Note:** This endpoint is only available when `passwordReset` is enabled in the login module configuration.  Reset tokens are valid for the number of hours specified in `passwordResetHours` (default: 48 hours). 
         * @summary Complete password reset
         * @param {AuthResetRequest} authResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authReset(authResetRequest: AuthResetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthReset200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authReset(authResetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authReset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Initiates a password reset process by sending a reset link to the user\'s email address.  **âš ï¸ Note:** This endpoint is only available when `passwordReset` is enabled in the login module configuration.  **Security feature:** The user will not be notified if the email check fails or if the email fails to send. However, debug information will be output in the server terminal. 
         * @summary Request password reset
         * @param {AuthResetRequestRequest} authResetRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authResetRequest(authResetRequestRequest: AuthResetRequestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResetRequest200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authResetRequest(authResetRequestRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authResetRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * **âš ï¸ DEPRECATED:** This GET endpoint is deprecated due to caching issues. Use the POST method instead.  Returns information about the currently authenticated user.  **Security note:** Only explicitly configured fields are returned, never the complete user object. This prevents accidental exposure of sensitive user data. 
         * @summary Get current user information
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async authWhoAmI(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthWhoAmI200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authWhoAmI(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authWhoAmI']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns information about the currently authenticated user.  **Note:** POST method is recommended for this endpoint to avoid caching issues.  **Perfect for:** - Checking if authentication is working - Getting user details for your app - Validating permissions  **Security note:** Only explicitly configured fields are returned,  never the complete user object. This prevents accidental exposure  of sensitive user data. 
         * @summary Get current user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authWhoAmIPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthWhoAmI200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authWhoAmIPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authWhoAmIPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * **âš ï¸ DEPRECATED:** This GET endpoint is deprecated due to caching issues. Use the POST method instead.  Returns login context information including environment and requirements. This endpoint provides information about the login system configuration.  **Useful for:** - Understanding available login methods - Checking if password reset is enabled - Getting login system configuration 
         * @summary Get login context information
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authContext(options?: RawAxiosRequestConfig): AxiosPromise<AuthContext200Response> {
            return localVarFp.authContext(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns login context information including environment and requirements. This endpoint provides information about the login system configuration.  **Note:** POST method is recommended for this endpoint to avoid caching issues.  **Useful for:** - Understanding available login methods - Checking if password reset is enabled - Getting login system configuration 
         * @summary Get login context information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authContextPost(options?: RawAxiosRequestConfig): AxiosPromise<AuthContextPost200Response> {
            return localVarFp.authContextPost(options).then((request) => request(axios, basePath));
        },
        /**
         * ðŸš€ **Start here!** Authenticate and receive either a bearer token or session cookie for subsequent API requests.  **Perfect for:** - Getting started with the API - Setting up authentication for your app - Testing API access  **Choose your authentication method:** - **Bearer Token** (recommended): omit `session` field or set to `false` - **Session Cookie**: set `session` to `true` and include `credentials: \'include\'` in fetch 
         * @summary Login to get authentication token
         * @param {AuthLoginRequest} authLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogin(authLoginRequest: AuthLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthLogin200Response> {
            return localVarFp.authLogin(authLoginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * End the current session or invalidate the bearer token.  **For bearer token**: include Authorization header **For session cookie**: include credentials in request 
         * @summary Logout and invalidate session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogout(options?: RawAxiosRequestConfig): AxiosPromise<AuthLogout200Response> {
            return localVarFp.authLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * Completes a password reset using the token provided in the reset email.  **âš ï¸ Note:** This endpoint is only available when `passwordReset` is enabled in the login module configuration.  Reset tokens are valid for the number of hours specified in `passwordResetHours` (default: 48 hours). 
         * @summary Complete password reset
         * @param {AuthResetRequest} authResetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authReset(authResetRequest: AuthResetRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthReset200Response> {
            return localVarFp.authReset(authResetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates a password reset process by sending a reset link to the user\'s email address.  **âš ï¸ Note:** This endpoint is only available when `passwordReset` is enabled in the login module configuration.  **Security feature:** The user will not be notified if the email check fails or if the email fails to send. However, debug information will be output in the server terminal. 
         * @summary Request password reset
         * @param {AuthResetRequestRequest} authResetRequestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authResetRequest(authResetRequestRequest: AuthResetRequestRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthResetRequest200Response> {
            return localVarFp.authResetRequest(authResetRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * **âš ï¸ DEPRECATED:** This GET endpoint is deprecated due to caching issues. Use the POST method instead.  Returns information about the currently authenticated user.  **Security note:** Only explicitly configured fields are returned, never the complete user object. This prevents accidental exposure of sensitive user data. 
         * @summary Get current user information
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        authWhoAmI(options?: RawAxiosRequestConfig): AxiosPromise<AuthWhoAmI200Response> {
            return localVarFp.authWhoAmI(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the currently authenticated user.  **Note:** POST method is recommended for this endpoint to avoid caching issues.  **Perfect for:** - Checking if authentication is working - Getting user details for your app - Validating permissions  **Security note:** Only explicitly configured fields are returned,  never the complete user object. This prevents accidental exposure  of sensitive user data. 
         * @summary Get current user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authWhoAmIPost(options?: RawAxiosRequestConfig): AxiosPromise<AuthWhoAmI200Response> {
            return localVarFp.authWhoAmIPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * **âš ï¸ DEPRECATED:** This GET endpoint is deprecated due to caching issues. Use the POST method instead.  Returns login context information including environment and requirements. This endpoint provides information about the login system configuration.  **Useful for:** - Understanding available login methods - Checking if password reset is enabled - Getting login system configuration 
     * @summary Get login context information
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authContext(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authContext(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns login context information including environment and requirements. This endpoint provides information about the login system configuration.  **Note:** POST method is recommended for this endpoint to avoid caching issues.  **Useful for:** - Understanding available login methods - Checking if password reset is enabled - Getting login system configuration 
     * @summary Get login context information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authContextPost(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authContextPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ðŸš€ **Start here!** Authenticate and receive either a bearer token or session cookie for subsequent API requests.  **Perfect for:** - Getting started with the API - Setting up authentication for your app - Testing API access  **Choose your authentication method:** - **Bearer Token** (recommended): omit `session` field or set to `false` - **Session Cookie**: set `session` to `true` and include `credentials: \'include\'` in fetch 
     * @summary Login to get authentication token
     * @param {AuthLoginRequest} authLoginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authLogin(authLoginRequest: AuthLoginRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authLogin(authLoginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * End the current session or invalidate the bearer token.  **For bearer token**: include Authorization header **For session cookie**: include credentials in request 
     * @summary Logout and invalidate session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authLogout(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completes a password reset using the token provided in the reset email.  **âš ï¸ Note:** This endpoint is only available when `passwordReset` is enabled in the login module configuration.  Reset tokens are valid for the number of hours specified in `passwordResetHours` (default: 48 hours). 
     * @summary Complete password reset
     * @param {AuthResetRequest} authResetRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authReset(authResetRequest: AuthResetRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authReset(authResetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiates a password reset process by sending a reset link to the user\'s email address.  **âš ï¸ Note:** This endpoint is only available when `passwordReset` is enabled in the login module configuration.  **Security feature:** The user will not be notified if the email check fails or if the email fails to send. However, debug information will be output in the server terminal. 
     * @summary Request password reset
     * @param {AuthResetRequestRequest} authResetRequestRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authResetRequest(authResetRequestRequest: AuthResetRequestRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authResetRequest(authResetRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **âš ï¸ DEPRECATED:** This GET endpoint is deprecated due to caching issues. Use the POST method instead.  Returns information about the currently authenticated user.  **Security note:** Only explicitly configured fields are returned, never the complete user object. This prevents accidental exposure of sensitive user data. 
     * @summary Get current user information
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authWhoAmI(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authWhoAmI(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about the currently authenticated user.  **Note:** POST method is recommended for this endpoint to avoid caching issues.  **Perfect for:** - Checking if authentication is working - Getting user details for your app - Validating permissions  **Security note:** Only explicitly configured fields are returned,  never the complete user object. This prevents accidental exposure  of sensitive user data. 
     * @summary Get current user information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authWhoAmIPost(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authWhoAmIPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GlobalContentApi - axios parameter creator
 * @export
 */
export const GlobalContentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Archive the global document, making it inactive while preserving its data
         * @summary Archive global document
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalArchive: async (bulkOperationRequest: BulkOperationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkOperationRequest' is not null or undefined
            assertParamExists('globalArchive', 'bulkOperationRequest', bulkOperationRequest)
            const localVarPath = `/@apostrophecms/global/archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkOperationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete a specific global document by ID (requires appropriate permissions)
         * @summary Delete global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalDeleteById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('globalDeleteById', 'id', id)
            const localVarPath = `/@apostrophecms/global/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Dismiss a pending submission for the specified global document, removing it from the review queue
         * @summary Dismiss global submission
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalDismissSubmissionById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('globalDismissSubmissionById', 'id', id)
            const localVarPath = `/@apostrophecms/global/{_id}/dismiss-submission`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve global site configuration and content that appears across all pages
         * @summary Get global content
         * @param {GlobalGetAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalGet: async (aposMode?: GlobalGetAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/global`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific global document by ID (requires appropriate permissions)
         * @summary Get global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalGetById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('globalGetById', 'id', id)
            const localVarPath = `/@apostrophecms/global/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the specified global document in a specific locale
         * @summary Get global document locale
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} toLocale Target locale code (e.g., en:us:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalGetLocaleById: async (id: string, toLocale: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('globalGetLocaleById', 'id', id)
            // verify required parameter 'toLocale' is not null or undefined
            assertParamExists('globalGetLocaleById', 'toLocale', toLocale)
            const localVarPath = `/@apostrophecms/global/{_id}/locale/{toLocale}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"toLocale"}}`, encodeURIComponent(String(toLocale)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all available locales for the specified global document
         * @summary Get global document locales
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalGetLocalesById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('globalGetLocalesById', 'id', id)
            const localVarPath = `/@apostrophecms/global/{_id}/locales`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update localized versions of the global document for different languages/regions
         * @summary Localize global document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalLocalize: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/global/localize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a localized version of the specified global document for a specific language/region
         * @summary Localize global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalLocalizeById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('globalLocalizeById', 'id', id)
            const localVarPath = `/@apostrophecms/global/{_id}/localize`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially update a specific global document by ID using PATCH semantics. Writes must target the draft mode. 
         * @summary Update global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {GlobalPatch} globalPatch 
         * @param {GlobalPatchByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalPatchById: async (id: string, globalPatch: GlobalPatch, aposMode?: GlobalPatchByIdAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('globalPatchById', 'id', id)
            // verify required parameter 'globalPatch' is not null or undefined
            assertParamExists('globalPatchById', 'globalPatch', globalPatch)
            const localVarPath = `/@apostrophecms/global/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(globalPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update global site configuration and content (requires editor permissions or higher)
         * @summary Update global content
         * @param {GlobalPostRequest} globalPostRequest 
         * @param {GlobalPostAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalPost: async (globalPostRequest: GlobalPostRequest, aposMode?: GlobalPostAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'globalPostRequest' is not null or undefined
            assertParamExists('globalPost', 'globalPostRequest', globalPostRequest)
            const localVarPath = `/@apostrophecms/global`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(globalPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publish the global document, making it live and visible to end users
         * @summary Publish global document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalPublish: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/global/publish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publish the specified global document, making it live and visible to end users
         * @summary Publish global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalPublishById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('globalPublishById', 'id', id)
            const localVarPath = `/@apostrophecms/global/{_id}/publish`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completely replace a specific global document by ID using PUT semantics
         * @summary Replace global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalPutById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('globalPutById', 'id', id)
            const localVarPath = `/@apostrophecms/global/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore a previously archived global document, making it active again
         * @summary Restore global document
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalRestore: async (bulkOperationRequest: BulkOperationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkOperationRequest' is not null or undefined
            assertParamExists('globalRestore', 'bulkOperationRequest', bulkOperationRequest)
            const localVarPath = `/@apostrophecms/global/restore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkOperationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revert the draft version of the specified global document back to its published state
         * @summary Revert draft to published
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalRevertDraftToPublishedById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('globalRevertDraftToPublishedById', 'id', id)
            const localVarPath = `/@apostrophecms/global/{_id}/revert-draft-to-published`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revert the published version of the specified global document to its previous published state
         * @summary Revert published to previous
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalRevertPublishedToPreviousById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('globalRevertPublishedToPreviousById', 'id', id)
            const localVarPath = `/@apostrophecms/global/{_id}/revert-published-to-previous`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a sharing link or configure sharing permissions for the specified global document
         * @summary Share global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalShareById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('globalShareById', 'id', id)
            const localVarPath = `/@apostrophecms/global/{_id}/share`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit the specified global document for review and approval workflow
         * @summary Submit global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalSubmitById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('globalSubmitById', 'id', id)
            const localVarPath = `/@apostrophecms/global/{_id}/submit`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unpublish the specified global document, removing it from public visibility while preserving the content
         * @summary Unpublish global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalUnpublishById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('globalUnpublishById', 'id', id)
            const localVarPath = `/@apostrophecms/global/{_id}/unpublish`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GlobalContentApi - functional programming interface
 * @export
 */
export const GlobalContentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GlobalContentApiAxiosParamCreator(configuration)
    return {
        /**
         * Archive the global document, making it inactive while preserving its data
         * @summary Archive global document
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async globalArchive(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageArchive200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.globalArchive(bulkOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalContentApi.globalArchive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently delete a specific global document by ID (requires appropriate permissions)
         * @summary Delete global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async globalDeleteById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Global>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.globalDeleteById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalContentApi.globalDeleteById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Dismiss a pending submission for the specified global document, removing it from the review queue
         * @summary Dismiss global submission
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async globalDismissSubmissionById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Global>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.globalDismissSubmissionById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalContentApi.globalDismissSubmissionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve global site configuration and content that appears across all pages
         * @summary Get global content
         * @param {GlobalGetAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async globalGet(aposMode?: GlobalGetAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GlobalGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.globalGet(aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalContentApi.globalGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific global document by ID (requires appropriate permissions)
         * @summary Get global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async globalGetById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Global>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.globalGetById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalContentApi.globalGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the specified global document in a specific locale
         * @summary Get global document locale
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} toLocale Target locale code (e.g., en:us:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async globalGetLocaleById(id: string, toLocale: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Global>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.globalGetLocaleById(id, toLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalContentApi.globalGetLocaleById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all available locales for the specified global document
         * @summary Get global document locales
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async globalGetLocalesById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.globalGetLocalesById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalContentApi.globalGetLocalesById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or update localized versions of the global document for different languages/regions
         * @summary Localize global document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async globalLocalize(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Global>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.globalLocalize(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalContentApi.globalLocalize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a localized version of the specified global document for a specific language/region
         * @summary Localize global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async globalLocalizeById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Global>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.globalLocalizeById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalContentApi.globalLocalizeById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update a specific global document by ID using PATCH semantics. Writes must target the draft mode. 
         * @summary Update global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {GlobalPatch} globalPatch 
         * @param {GlobalPatchByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async globalPatchById(id: string, globalPatch: GlobalPatch, aposMode?: GlobalPatchByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Global>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.globalPatchById(id, globalPatch, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalContentApi.globalPatchById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update global site configuration and content (requires editor permissions or higher)
         * @summary Update global content
         * @param {GlobalPostRequest} globalPostRequest 
         * @param {GlobalPostAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async globalPost(globalPostRequest: GlobalPostRequest, aposMode?: GlobalPostAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Global>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.globalPost(globalPostRequest, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalContentApi.globalPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Publish the global document, making it live and visible to end users
         * @summary Publish global document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async globalPublish(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Global>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.globalPublish(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalContentApi.globalPublish']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Publish the specified global document, making it live and visible to end users
         * @summary Publish global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async globalPublishById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Global>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.globalPublishById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalContentApi.globalPublishById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Completely replace a specific global document by ID using PUT semantics
         * @summary Replace global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async globalPutById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Global>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.globalPutById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalContentApi.globalPutById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restore a previously archived global document, making it active again
         * @summary Restore global document
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async globalRestore(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Global>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.globalRestore(bulkOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalContentApi.globalRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revert the draft version of the specified global document back to its published state
         * @summary Revert draft to published
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async globalRevertDraftToPublishedById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Global>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.globalRevertDraftToPublishedById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalContentApi.globalRevertDraftToPublishedById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revert the published version of the specified global document to its previous published state
         * @summary Revert published to previous
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async globalRevertPublishedToPreviousById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Global>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.globalRevertPublishedToPreviousById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalContentApi.globalRevertPublishedToPreviousById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate a sharing link or configure sharing permissions for the specified global document
         * @summary Share global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async globalShareById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Global>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.globalShareById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalContentApi.globalShareById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit the specified global document for review and approval workflow
         * @summary Submit global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async globalSubmitById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Global>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.globalSubmitById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalContentApi.globalSubmitById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unpublish the specified global document, removing it from public visibility while preserving the content
         * @summary Unpublish global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async globalUnpublishById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Global>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.globalUnpublishById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlobalContentApi.globalUnpublishById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GlobalContentApi - factory interface
 * @export
 */
export const GlobalContentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GlobalContentApiFp(configuration)
    return {
        /**
         * Archive the global document, making it inactive while preserving its data
         * @summary Archive global document
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalArchive(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<PageArchive200Response> {
            return localVarFp.globalArchive(bulkOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently delete a specific global document by ID (requires appropriate permissions)
         * @summary Delete global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalDeleteById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Global> {
            return localVarFp.globalDeleteById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Dismiss a pending submission for the specified global document, removing it from the review queue
         * @summary Dismiss global submission
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalDismissSubmissionById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Global> {
            return localVarFp.globalDismissSubmissionById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve global site configuration and content that appears across all pages
         * @summary Get global content
         * @param {GlobalGetAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalGet(aposMode?: GlobalGetAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<GlobalGet200Response> {
            return localVarFp.globalGet(aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific global document by ID (requires appropriate permissions)
         * @summary Get global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalGetById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Global> {
            return localVarFp.globalGetById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the specified global document in a specific locale
         * @summary Get global document locale
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} toLocale Target locale code (e.g., en:us:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalGetLocaleById(id: string, toLocale: string, options?: RawAxiosRequestConfig): AxiosPromise<Global> {
            return localVarFp.globalGetLocaleById(id, toLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all available locales for the specified global document
         * @summary Get global document locales
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalGetLocalesById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.globalGetLocalesById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update localized versions of the global document for different languages/regions
         * @summary Localize global document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalLocalize(options?: RawAxiosRequestConfig): AxiosPromise<Global> {
            return localVarFp.globalLocalize(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a localized version of the specified global document for a specific language/region
         * @summary Localize global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalLocalizeById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Global> {
            return localVarFp.globalLocalizeById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Partially update a specific global document by ID using PATCH semantics. Writes must target the draft mode. 
         * @summary Update global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {GlobalPatch} globalPatch 
         * @param {GlobalPatchByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalPatchById(id: string, globalPatch: GlobalPatch, aposMode?: GlobalPatchByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<Global> {
            return localVarFp.globalPatchById(id, globalPatch, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Update global site configuration and content (requires editor permissions or higher)
         * @summary Update global content
         * @param {GlobalPostRequest} globalPostRequest 
         * @param {GlobalPostAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalPost(globalPostRequest: GlobalPostRequest, aposMode?: GlobalPostAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<Global> {
            return localVarFp.globalPost(globalPostRequest, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Publish the global document, making it live and visible to end users
         * @summary Publish global document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalPublish(options?: RawAxiosRequestConfig): AxiosPromise<Global> {
            return localVarFp.globalPublish(options).then((request) => request(axios, basePath));
        },
        /**
         * Publish the specified global document, making it live and visible to end users
         * @summary Publish global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalPublishById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Global> {
            return localVarFp.globalPublishById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Completely replace a specific global document by ID using PUT semantics
         * @summary Replace global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalPutById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Global> {
            return localVarFp.globalPutById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore a previously archived global document, making it active again
         * @summary Restore global document
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalRestore(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Global> {
            return localVarFp.globalRestore(bulkOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Revert the draft version of the specified global document back to its published state
         * @summary Revert draft to published
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalRevertDraftToPublishedById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Global> {
            return localVarFp.globalRevertDraftToPublishedById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Revert the published version of the specified global document to its previous published state
         * @summary Revert published to previous
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalRevertPublishedToPreviousById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Global> {
            return localVarFp.globalRevertPublishedToPreviousById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a sharing link or configure sharing permissions for the specified global document
         * @summary Share global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalShareById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Global> {
            return localVarFp.globalShareById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit the specified global document for review and approval workflow
         * @summary Submit global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalSubmitById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Global> {
            return localVarFp.globalSubmitById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Unpublish the specified global document, removing it from public visibility while preserving the content
         * @summary Unpublish global document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        globalUnpublishById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Global> {
            return localVarFp.globalUnpublishById(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GlobalContentApi - object-oriented interface
 * @export
 * @class GlobalContentApi
 * @extends {BaseAPI}
 */
export class GlobalContentApi extends BaseAPI {
    /**
     * Archive the global document, making it inactive while preserving its data
     * @summary Archive global document
     * @param {BulkOperationRequest} bulkOperationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalContentApi
     */
    public globalArchive(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig) {
        return GlobalContentApiFp(this.configuration).globalArchive(bulkOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently delete a specific global document by ID (requires appropriate permissions)
     * @summary Delete global document
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalContentApi
     */
    public globalDeleteById(id: string, options?: RawAxiosRequestConfig) {
        return GlobalContentApiFp(this.configuration).globalDeleteById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Dismiss a pending submission for the specified global document, removing it from the review queue
     * @summary Dismiss global submission
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalContentApi
     */
    public globalDismissSubmissionById(id: string, options?: RawAxiosRequestConfig) {
        return GlobalContentApiFp(this.configuration).globalDismissSubmissionById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve global site configuration and content that appears across all pages
     * @summary Get global content
     * @param {GlobalGetAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalContentApi
     */
    public globalGet(aposMode?: GlobalGetAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return GlobalContentApiFp(this.configuration).globalGet(aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific global document by ID (requires appropriate permissions)
     * @summary Get global document
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalContentApi
     */
    public globalGetById(id: string, options?: RawAxiosRequestConfig) {
        return GlobalContentApiFp(this.configuration).globalGetById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the specified global document in a specific locale
     * @summary Get global document locale
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {string} toLocale Target locale code (e.g., en:us:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalContentApi
     */
    public globalGetLocaleById(id: string, toLocale: string, options?: RawAxiosRequestConfig) {
        return GlobalContentApiFp(this.configuration).globalGetLocaleById(id, toLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all available locales for the specified global document
     * @summary Get global document locales
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalContentApi
     */
    public globalGetLocalesById(id: string, options?: RawAxiosRequestConfig) {
        return GlobalContentApiFp(this.configuration).globalGetLocalesById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update localized versions of the global document for different languages/regions
     * @summary Localize global document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalContentApi
     */
    public globalLocalize(options?: RawAxiosRequestConfig) {
        return GlobalContentApiFp(this.configuration).globalLocalize(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a localized version of the specified global document for a specific language/region
     * @summary Localize global document
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalContentApi
     */
    public globalLocalizeById(id: string, options?: RawAxiosRequestConfig) {
        return GlobalContentApiFp(this.configuration).globalLocalizeById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update a specific global document by ID using PATCH semantics. Writes must target the draft mode. 
     * @summary Update global document
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {GlobalPatch} globalPatch 
     * @param {GlobalPatchByIdAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalContentApi
     */
    public globalPatchById(id: string, globalPatch: GlobalPatch, aposMode?: GlobalPatchByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return GlobalContentApiFp(this.configuration).globalPatchById(id, globalPatch, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update global site configuration and content (requires editor permissions or higher)
     * @summary Update global content
     * @param {GlobalPostRequest} globalPostRequest 
     * @param {GlobalPostAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalContentApi
     */
    public globalPost(globalPostRequest: GlobalPostRequest, aposMode?: GlobalPostAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return GlobalContentApiFp(this.configuration).globalPost(globalPostRequest, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Publish the global document, making it live and visible to end users
     * @summary Publish global document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalContentApi
     */
    public globalPublish(options?: RawAxiosRequestConfig) {
        return GlobalContentApiFp(this.configuration).globalPublish(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Publish the specified global document, making it live and visible to end users
     * @summary Publish global document
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalContentApi
     */
    public globalPublishById(id: string, options?: RawAxiosRequestConfig) {
        return GlobalContentApiFp(this.configuration).globalPublishById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completely replace a specific global document by ID using PUT semantics
     * @summary Replace global document
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalContentApi
     */
    public globalPutById(id: string, options?: RawAxiosRequestConfig) {
        return GlobalContentApiFp(this.configuration).globalPutById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore a previously archived global document, making it active again
     * @summary Restore global document
     * @param {BulkOperationRequest} bulkOperationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalContentApi
     */
    public globalRestore(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig) {
        return GlobalContentApiFp(this.configuration).globalRestore(bulkOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revert the draft version of the specified global document back to its published state
     * @summary Revert draft to published
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalContentApi
     */
    public globalRevertDraftToPublishedById(id: string, options?: RawAxiosRequestConfig) {
        return GlobalContentApiFp(this.configuration).globalRevertDraftToPublishedById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revert the published version of the specified global document to its previous published state
     * @summary Revert published to previous
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalContentApi
     */
    public globalRevertPublishedToPreviousById(id: string, options?: RawAxiosRequestConfig) {
        return GlobalContentApiFp(this.configuration).globalRevertPublishedToPreviousById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a sharing link or configure sharing permissions for the specified global document
     * @summary Share global document
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalContentApi
     */
    public globalShareById(id: string, options?: RawAxiosRequestConfig) {
        return GlobalContentApiFp(this.configuration).globalShareById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit the specified global document for review and approval workflow
     * @summary Submit global document
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalContentApi
     */
    public globalSubmitById(id: string, options?: RawAxiosRequestConfig) {
        return GlobalContentApiFp(this.configuration).globalSubmitById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unpublish the specified global document, removing it from public visibility while preserving the content
     * @summary Unpublish global document
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlobalContentApi
     */
    public globalUnpublishById(id: string, options?: RawAxiosRequestConfig) {
        return GlobalContentApiFp(this.configuration).globalUnpublishById(id, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GlobalGetAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type GlobalGetAposModeEnum = typeof GlobalGetAposModeEnum[keyof typeof GlobalGetAposModeEnum];
/**
 * @export
 */
export const GlobalPatchByIdAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type GlobalPatchByIdAposModeEnum = typeof GlobalPatchByIdAposModeEnum[keyof typeof GlobalPatchByIdAposModeEnum];
/**
 * @export
 */
export const GlobalPostAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type GlobalPostAposModeEnum = typeof GlobalPostAposModeEnum[keyof typeof GlobalPostAposModeEnum];


/**
 * InternationalizationApi - axios parameter creator
 * @export
 */
export const InternationalizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns arrays of original document IDs, new locale IDs, and aposDocIds  for an array of document IDs in a specified locale and mode. 
         * @summary Check document existence in locale
         * @param {Array<string>} ids Required. Array of document IDs to check in the specified locale
         * @param {string} locale Required. The locale in which to check for the document IDs
         * @param {I18nExistsPostModeEnum} mode Required. The mode (draft or published) in which to check for the document IDs
         * @param {ExistInLocaleRequest} existInLocaleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        i18nExistsPost: async (ids: Array<string>, locale: string, mode: I18nExistsPostModeEnum, existInLocaleRequest: ExistInLocaleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('i18nExistsPost', 'ids', ids)
            // verify required parameter 'locale' is not null or undefined
            assertParamExists('i18nExistsPost', 'locale', locale)
            // verify required parameter 'mode' is not null or undefined
            assertParamExists('i18nExistsPost', 'mode', mode)
            // verify required parameter 'existInLocaleRequest' is not null or undefined
            assertParamExists('i18nExistsPost', 'existInLocaleRequest', existInLocaleRequest)
            const localVarPath = `/@apostrophecms/i18n/exist-in-locale`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(existInLocaleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the path to a locale home-page or optional document and makes the clipboard  available in the given locale. Used for cross-locale navigation. 
         * @summary Get locale path and manage clipboard
         * @param {string} locale Required. The locale for the desired path
         * @param {LocaleRequest} localeRequest 
         * @param {string} [contextDocId] Optional document ID for the path, defaults to locale home-page
         * @param {string} [clipboard] Optional clipboard content for cross-domain situations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        i18nLocalePost: async (locale: string, localeRequest: LocaleRequest, contextDocId?: string, clipboard?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'locale' is not null or undefined
            assertParamExists('i18nLocalePost', 'locale', locale)
            // verify required parameter 'localeRequest' is not null or undefined
            assertParamExists('i18nLocalePost', 'localeRequest', localeRequest)
            const localVarPath = `/@apostrophecms/i18n/locale`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (contextDocId !== undefined) {
                localVarQueryParameter['contextDocId'] = contextDocId;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }

            if (clipboard !== undefined) {
                localVarQueryParameter['clipboard'] = clipboard;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(localeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about all configured locales including labels and edit permissions. Authentication is required to access locale configuration data. 
         * @summary Get all configured locales
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        i18nLocalesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/i18n/locales`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternationalizationApi - functional programming interface
 * @export
 */
export const InternationalizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InternationalizationApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns arrays of original document IDs, new locale IDs, and aposDocIds  for an array of document IDs in a specified locale and mode. 
         * @summary Check document existence in locale
         * @param {Array<string>} ids Required. Array of document IDs to check in the specified locale
         * @param {string} locale Required. The locale in which to check for the document IDs
         * @param {I18nExistsPostModeEnum} mode Required. The mode (draft or published) in which to check for the document IDs
         * @param {ExistInLocaleRequest} existInLocaleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async i18nExistsPost(ids: Array<string>, locale: string, mode: I18nExistsPostModeEnum, existInLocaleRequest: ExistInLocaleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExistInLocaleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.i18nExistsPost(ids, locale, mode, existInLocaleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternationalizationApi.i18nExistsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the path to a locale home-page or optional document and makes the clipboard  available in the given locale. Used for cross-locale navigation. 
         * @summary Get locale path and manage clipboard
         * @param {string} locale Required. The locale for the desired path
         * @param {LocaleRequest} localeRequest 
         * @param {string} [contextDocId] Optional document ID for the path, defaults to locale home-page
         * @param {string} [clipboard] Optional clipboard content for cross-domain situations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async i18nLocalePost(locale: string, localeRequest: LocaleRequest, contextDocId?: string, clipboard?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<I18nLocalePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.i18nLocalePost(locale, localeRequest, contextDocId, clipboard, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternationalizationApi.i18nLocalePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns information about all configured locales including labels and edit permissions. Authentication is required to access locale configuration data. 
         * @summary Get all configured locales
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async i18nLocalesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: LocalesResponseValue; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.i18nLocalesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternationalizationApi.i18nLocalesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InternationalizationApi - factory interface
 * @export
 */
export const InternationalizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InternationalizationApiFp(configuration)
    return {
        /**
         * Returns arrays of original document IDs, new locale IDs, and aposDocIds  for an array of document IDs in a specified locale and mode. 
         * @summary Check document existence in locale
         * @param {Array<string>} ids Required. Array of document IDs to check in the specified locale
         * @param {string} locale Required. The locale in which to check for the document IDs
         * @param {I18nExistsPostModeEnum} mode Required. The mode (draft or published) in which to check for the document IDs
         * @param {ExistInLocaleRequest} existInLocaleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        i18nExistsPost(ids: Array<string>, locale: string, mode: I18nExistsPostModeEnum, existInLocaleRequest: ExistInLocaleRequest, options?: RawAxiosRequestConfig): AxiosPromise<ExistInLocaleResponse> {
            return localVarFp.i18nExistsPost(ids, locale, mode, existInLocaleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the path to a locale home-page or optional document and makes the clipboard  available in the given locale. Used for cross-locale navigation. 
         * @summary Get locale path and manage clipboard
         * @param {string} locale Required. The locale for the desired path
         * @param {LocaleRequest} localeRequest 
         * @param {string} [contextDocId] Optional document ID for the path, defaults to locale home-page
         * @param {string} [clipboard] Optional clipboard content for cross-domain situations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        i18nLocalePost(locale: string, localeRequest: LocaleRequest, contextDocId?: string, clipboard?: string, options?: RawAxiosRequestConfig): AxiosPromise<I18nLocalePost200Response> {
            return localVarFp.i18nLocalePost(locale, localeRequest, contextDocId, clipboard, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about all configured locales including labels and edit permissions. Authentication is required to access locale configuration data. 
         * @summary Get all configured locales
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        i18nLocalesGet(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: LocalesResponseValue; }> {
            return localVarFp.i18nLocalesGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternationalizationApi - object-oriented interface
 * @export
 * @class InternationalizationApi
 * @extends {BaseAPI}
 */
export class InternationalizationApi extends BaseAPI {
    /**
     * Returns arrays of original document IDs, new locale IDs, and aposDocIds  for an array of document IDs in a specified locale and mode. 
     * @summary Check document existence in locale
     * @param {Array<string>} ids Required. Array of document IDs to check in the specified locale
     * @param {string} locale Required. The locale in which to check for the document IDs
     * @param {I18nExistsPostModeEnum} mode Required. The mode (draft or published) in which to check for the document IDs
     * @param {ExistInLocaleRequest} existInLocaleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternationalizationApi
     */
    public i18nExistsPost(ids: Array<string>, locale: string, mode: I18nExistsPostModeEnum, existInLocaleRequest: ExistInLocaleRequest, options?: RawAxiosRequestConfig) {
        return InternationalizationApiFp(this.configuration).i18nExistsPost(ids, locale, mode, existInLocaleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the path to a locale home-page or optional document and makes the clipboard  available in the given locale. Used for cross-locale navigation. 
     * @summary Get locale path and manage clipboard
     * @param {string} locale Required. The locale for the desired path
     * @param {LocaleRequest} localeRequest 
     * @param {string} [contextDocId] Optional document ID for the path, defaults to locale home-page
     * @param {string} [clipboard] Optional clipboard content for cross-domain situations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternationalizationApi
     */
    public i18nLocalePost(locale: string, localeRequest: LocaleRequest, contextDocId?: string, clipboard?: string, options?: RawAxiosRequestConfig) {
        return InternationalizationApiFp(this.configuration).i18nLocalePost(locale, localeRequest, contextDocId, clipboard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about all configured locales including labels and edit permissions. Authentication is required to access locale configuration data. 
     * @summary Get all configured locales
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternationalizationApi
     */
    public i18nLocalesGet(options?: RawAxiosRequestConfig) {
        return InternationalizationApiFp(this.configuration).i18nLocalesGet(options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const I18nExistsPostModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type I18nExistsPostModeEnum = typeof I18nExistsPostModeEnum[keyof typeof I18nExistsPostModeEnum];


/**
 * MediaApi - axios parameter creator
 * @export
 */
export const MediaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Archive multiple files, making them inactive while preserving their data
         * @summary Archive files
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileArchive: async (bulkOperationRequest: BulkOperationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkOperationRequest' is not null or undefined
            assertParamExists('fileArchive', 'bulkOperationRequest', bulkOperationRequest)
            const localVarPath = `/@apostrophecms/file/archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkOperationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete a specific file by ID (requires appropriate permissions)
         * @summary Delete file
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {FileDeleteByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileDeleteById: async (id: string, aposMode?: FileDeleteByIdAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileDeleteById', 'id', id)
            const localVarPath = `/@apostrophecms/file/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Dismiss a pending submission for the specified file, removing it from the review queue
         * @summary Dismiss file submission
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileDismissSubmissionById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileDismissSubmissionById', 'id', id)
            const localVarPath = `/@apostrophecms/file/{_id}/dismiss-submission`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a paginated list of files from the media library
         * @summary List files
         * @param {number} [page] Page number for pagination (1-based)
         * @param {number} [perPage] Number of items per page
         * @param {string} [search] Search term for filtering results
         * @param {FileGetAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileGet: async (page?: number, perPage?: number, search?: string, aposMode?: FileGetAposModeEnum, aposLocale?: string, renderAreas?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }

            if (renderAreas !== undefined) {
                localVarQueryParameter['render-areas'] = renderAreas;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific file by ID from the media library
         * @summary Get file by ID
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {FileGetByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileGetById: async (id: string, aposMode?: FileGetByIdAposModeEnum, aposLocale?: string, renderAreas?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileGetById', 'id', id)
            const localVarPath = `/@apostrophecms/file/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }

            if (renderAreas !== undefined) {
                localVarQueryParameter['render-areas'] = renderAreas;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the specified file in a specific locale
         * @summary Get file locale
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} toLocale Target locale code (e.g., en:us:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileGetLocaleById: async (id: string, toLocale: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileGetLocaleById', 'id', id)
            // verify required parameter 'toLocale' is not null or undefined
            assertParamExists('fileGetLocaleById', 'toLocale', toLocale)
            const localVarPath = `/@apostrophecms/file/{_id}/locale/{toLocale}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"toLocale"}}`, encodeURIComponent(String(toLocale)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all available locales for the specified file
         * @summary Get file locales
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileGetLocalesById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileGetLocalesById', 'id', id)
            const localVarPath = `/@apostrophecms/file/{_id}/locales`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update localized versions of files for different languages/regions
         * @summary Localize files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileLocalize: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/file/localize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a localized version of the specified file for a specific language/region
         * @summary Localize file
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileLocalizeById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileLocalizeById', 'id', id)
            const localVarPath = `/@apostrophecms/file/{_id}/localize`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially update a specific file by ID using PATCH semantics
         * @summary Update file
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {FilePatchByIdRequest} filePatchByIdRequest 
         * @param {FilePatchByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filePatchById: async (id: string, filePatchByIdRequest: FilePatchByIdRequest, aposMode?: FilePatchByIdAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('filePatchById', 'id', id)
            // verify required parameter 'filePatchByIdRequest' is not null or undefined
            assertParamExists('filePatchById', 'filePatchByIdRequest', filePatchByIdRequest)
            const localVarPath = `/@apostrophecms/file/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filePatchByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new file document (requires prior attachment upload)
         * @summary Create file
         * @param {FilePostRequest} filePostRequest 
         * @param {FilePostAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filePost: async (filePostRequest: FilePostRequest, aposMode?: FilePostAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filePostRequest' is not null or undefined
            assertParamExists('filePost', 'filePostRequest', filePostRequest)
            const localVarPath = `/@apostrophecms/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk publish multiple files, making them live and visible to end users
         * @summary Publish files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filePublish: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/file/publish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publish the specified file, making it live and visible to end users
         * @summary Publish file
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filePublishById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('filePublishById', 'id', id)
            const localVarPath = `/@apostrophecms/file/{_id}/publish`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completely replace a specific file by ID using PUT semantics
         * @summary Replace file
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {FilePostRequest} filePostRequest 
         * @param {FilePutByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filePutById: async (id: string, filePostRequest: FilePostRequest, aposMode?: FilePutByIdAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('filePutById', 'id', id)
            // verify required parameter 'filePostRequest' is not null or undefined
            assertParamExists('filePutById', 'filePostRequest', filePostRequest)
            const localVarPath = `/@apostrophecms/file/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore previously archived files, making them active again
         * @summary Restore files
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileRestore: async (bulkOperationRequest: BulkOperationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkOperationRequest' is not null or undefined
            assertParamExists('fileRestore', 'bulkOperationRequest', bulkOperationRequest)
            const localVarPath = `/@apostrophecms/file/restore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkOperationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revert the draft version of the specified file back to its published state
         * @summary Revert file draft to published
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileRevertDraftToPublishedById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileRevertDraftToPublishedById', 'id', id)
            const localVarPath = `/@apostrophecms/file/{_id}/revert-draft-to-published`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revert the published version of the specified file to its previous published state
         * @summary Revert file published to previous
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileRevertPublishedToPreviousById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileRevertPublishedToPreviousById', 'id', id)
            const localVarPath = `/@apostrophecms/file/{_id}/revert-published-to-previous`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a sharing link or configure sharing permissions for the specified file
         * @summary Share file
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileShareById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileShareById', 'id', id)
            const localVarPath = `/@apostrophecms/file/{_id}/share`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit the specified file for review and approval workflow
         * @summary Submit file
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileSubmitById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileSubmitById', 'id', id)
            const localVarPath = `/@apostrophecms/file/{_id}/submit`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Archive multiple file tags, making them inactive while preserving their data
         * @summary Archive file tags
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagArchive: async (bulkOperationRequest: BulkOperationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkOperationRequest' is not null or undefined
            assertParamExists('fileTagArchive', 'bulkOperationRequest', bulkOperationRequest)
            const localVarPath = `/@apostrophecms/file-tag/archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkOperationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete a specific file tag by ID (requires appropriate permissions)
         * @summary Delete file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagDeleteById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileTagDeleteById', 'id', id)
            const localVarPath = `/@apostrophecms/file-tag/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Dismiss a pending submission for the specified file tag, removing it from the review queue
         * @summary Dismiss file tag submission
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagDismissSubmissionById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileTagDismissSubmissionById', 'id', id)
            const localVarPath = `/@apostrophecms/file-tag/{_id}/dismiss-submission`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of file tags used for organizing and categorizing uploaded files
         * @summary List file tags
         * @param {FileTagGetAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagGet: async (aposMode?: FileTagGetAposModeEnum, aposLocale?: string, renderAreas?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/file-tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }

            if (renderAreas !== undefined) {
                localVarQueryParameter['render-areas'] = renderAreas;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific file tag by ID
         * @summary Get file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {FileTagGetByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagGetById: async (id: string, aposMode?: FileTagGetByIdAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileTagGetById', 'id', id)
            const localVarPath = `/@apostrophecms/file-tag/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the specified file tag in a specific locale
         * @summary Get file tag locale
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} toLocale Target locale code (e.g., en:us:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagGetLocaleById: async (id: string, toLocale: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileTagGetLocaleById', 'id', id)
            // verify required parameter 'toLocale' is not null or undefined
            assertParamExists('fileTagGetLocaleById', 'toLocale', toLocale)
            const localVarPath = `/@apostrophecms/file-tag/{_id}/locale/{toLocale}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"toLocale"}}`, encodeURIComponent(String(toLocale)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all available locales for the specified file tag
         * @summary Get file tag locales
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagGetLocalesById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileTagGetLocalesById', 'id', id)
            const localVarPath = `/@apostrophecms/file-tag/{_id}/locales`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update localized versions of file tags for different languages/regions
         * @summary Localize file tags
         * @param {FileTagLocalizeRequest} fileTagLocalizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagLocalize: async (fileTagLocalizeRequest: FileTagLocalizeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileTagLocalizeRequest' is not null or undefined
            assertParamExists('fileTagLocalize', 'fileTagLocalizeRequest', fileTagLocalizeRequest)
            const localVarPath = `/@apostrophecms/file-tag/localize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileTagLocalizeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a localized version of the specified file tag for a specific language/region
         * @summary Localize file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {PageLocalizeByIdRequest} pageLocalizeByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagLocalizeById: async (id: string, pageLocalizeByIdRequest: PageLocalizeByIdRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileTagLocalizeById', 'id', id)
            // verify required parameter 'pageLocalizeByIdRequest' is not null or undefined
            assertParamExists('fileTagLocalizeById', 'pageLocalizeByIdRequest', pageLocalizeByIdRequest)
            const localVarPath = `/@apostrophecms/file-tag/{_id}/localize`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pageLocalizeByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially update a specific file tag by ID using PATCH semantics
         * @summary Update file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {FileTagPatchByIdRequest} fileTagPatchByIdRequest 
         * @param {FileTagPatchByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagPatchById: async (id: string, fileTagPatchByIdRequest: FileTagPatchByIdRequest, aposMode?: FileTagPatchByIdAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileTagPatchById', 'id', id)
            // verify required parameter 'fileTagPatchByIdRequest' is not null or undefined
            assertParamExists('fileTagPatchById', 'fileTagPatchByIdRequest', fileTagPatchByIdRequest)
            const localVarPath = `/@apostrophecms/file-tag/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileTagPatchByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new file tag for organizing uploaded files (requires editor permissions or higher)
         * @summary Create file tag
         * @param {FileTagPostRequest} fileTagPostRequest 
         * @param {FileTagPostAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagPost: async (fileTagPostRequest: FileTagPostRequest, aposMode?: FileTagPostAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileTagPostRequest' is not null or undefined
            assertParamExists('fileTagPost', 'fileTagPostRequest', fileTagPostRequest)
            const localVarPath = `/@apostrophecms/file-tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileTagPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publish multiple file tags, making them live and visible to end users
         * @summary Publish file tags
         * @param {FileTagPublishRequest} fileTagPublishRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagPublish: async (fileTagPublishRequest: FileTagPublishRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileTagPublishRequest' is not null or undefined
            assertParamExists('fileTagPublish', 'fileTagPublishRequest', fileTagPublishRequest)
            const localVarPath = `/@apostrophecms/file-tag/publish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileTagPublishRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publish the specified file tag, making it live and visible to end users
         * @summary Publish file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagPublishById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileTagPublishById', 'id', id)
            const localVarPath = `/@apostrophecms/file-tag/{_id}/publish`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completely replace a specific file tag by ID using PUT semantics
         * @summary Replace file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {FileTagPutByIdRequest} fileTagPutByIdRequest 
         * @param {FileTagPutByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagPutById: async (id: string, fileTagPutByIdRequest: FileTagPutByIdRequest, aposMode?: FileTagPutByIdAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileTagPutById', 'id', id)
            // verify required parameter 'fileTagPutByIdRequest' is not null or undefined
            assertParamExists('fileTagPutById', 'fileTagPutByIdRequest', fileTagPutByIdRequest)
            const localVarPath = `/@apostrophecms/file-tag/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileTagPutByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore previously archived file tags, making them active again
         * @summary Restore file tags
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagRestore: async (bulkOperationRequest: BulkOperationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkOperationRequest' is not null or undefined
            assertParamExists('fileTagRestore', 'bulkOperationRequest', bulkOperationRequest)
            const localVarPath = `/@apostrophecms/file-tag/restore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkOperationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revert the draft version of the specified file tag back to its published state
         * @summary Revert file tag draft to published
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagRevertDraftToPublishedById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileTagRevertDraftToPublishedById', 'id', id)
            const localVarPath = `/@apostrophecms/file-tag/{_id}/revert-draft-to-published`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revert the published version of the specified file tag to its previous published state
         * @summary Revert file tag published to previous
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagRevertPublishedToPreviousById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileTagRevertPublishedToPreviousById', 'id', id)
            const localVarPath = `/@apostrophecms/file-tag/{_id}/revert-published-to-previous`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a sharing link or configure sharing permissions for the specified file tag
         * @summary Share file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagShareById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileTagShareById', 'id', id)
            const localVarPath = `/@apostrophecms/file-tag/{_id}/share`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit the specified file tag for review and approval workflow
         * @summary Submit file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagSubmitById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileTagSubmitById', 'id', id)
            const localVarPath = `/@apostrophecms/file-tag/{_id}/submit`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unpublish the specified file tag, removing it from public visibility while preserving the content
         * @summary Unpublish file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagUnpublishById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileTagUnpublishById', 'id', id)
            const localVarPath = `/@apostrophecms/file-tag/{_id}/unpublish`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unpublish the specified file, removing it from public visibility while preserving the content
         * @summary Unpublish file
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileUnpublishById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileUnpublishById', 'id', id)
            const localVarPath = `/@apostrophecms/file/{_id}/unpublish`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Archive multiple images, making them inactive while preserving their data
         * @summary Archive images
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageArchive: async (bulkOperationRequest: BulkOperationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkOperationRequest' is not null or undefined
            assertParamExists('imageArchive', 'bulkOperationRequest', bulkOperationRequest)
            const localVarPath = `/@apostrophecms/image/archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkOperationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Automatically crop uploaded images using intelligent cropping algorithms
         * @summary Auto-crop images
         * @param {ImageAutocropRequest} imageAutocropRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageAutocrop: async (imageAutocropRequest: ImageAutocropRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageAutocropRequest' is not null or undefined
            assertParamExists('imageAutocrop', 'imageAutocropRequest', imageAutocropRequest)
            const localVarPath = `/@apostrophecms/image/autocrop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageAutocropRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete a specific image document by ID (requires appropriate permissions)
         * @summary Delete image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageDeleteById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageDeleteById', 'id', id)
            const localVarPath = `/@apostrophecms/image/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Dismiss a pending submission for the specified image document, removing it from the review queue
         * @summary Dismiss image submission
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageDismissSubmissionById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageDismissSubmissionById', 'id', id)
            const localVarPath = `/@apostrophecms/image/{_id}/dismiss-submission`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve images from the media library.  Authentication is required for all requests other than GET requests  for images with defined publicApiProjection. 
         * @summary Get images
         * @param {number} [page] Page number for pagination (1-based)
         * @param {number} [perPage] Number of items per page
         * @param {string} [search] Search term for filtering results
         * @param {ImageGetAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageGet: async (page?: number, perPage?: number, search?: string, aposMode?: ImageGetAposModeEnum, aposLocale?: string, renderAreas?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }

            if (renderAreas !== undefined) {
                localVarQueryParameter['render-areas'] = renderAreas;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific image by ID from the media library. Authentication is required for all requests other than GET requests  for images with defined publicApiProjection. 
         * @summary Get image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {ImageGetByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageGetById: async (id: string, aposMode?: ImageGetByIdAposModeEnum, aposLocale?: string, renderAreas?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageGetById', 'id', id)
            const localVarPath = `/@apostrophecms/image/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }

            if (renderAreas !== undefined) {
                localVarQueryParameter['render-areas'] = renderAreas;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the specified image document in a specific locale
         * @summary Get image document locale
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} toLocale Target locale code (e.g., en:us:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageGetLocaleById: async (id: string, toLocale: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageGetLocaleById', 'id', id)
            // verify required parameter 'toLocale' is not null or undefined
            assertParamExists('imageGetLocaleById', 'toLocale', toLocale)
            const localVarPath = `/@apostrophecms/image/{_id}/locale/{toLocale}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"toLocale"}}`, encodeURIComponent(String(toLocale)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all available locales for the specified image document
         * @summary Get image document locales
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageGetLocalesById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageGetLocalesById', 'id', id)
            const localVarPath = `/@apostrophecms/image/{_id}/locales`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the source URL for a specific image, with optional size and format parameters
         * @summary Get image source URL
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {ImageGetSrcByIdSizeEnum} [size] Image size variant
         * @param {ImageGetSrcByIdFormatEnum} [format] Image format
         * @param {number} [quality] Image quality (1-100)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageGetSrcById: async (id: string, size?: ImageGetSrcByIdSizeEnum, format?: ImageGetSrcByIdFormatEnum, quality?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageGetSrcById', 'id', id)
            const localVarPath = `/@apostrophecms/image/{_id}/src`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update localized versions of images for different languages/regions
         * @summary Localize images
         * @param {ImageLocalizeRequest} imageLocalizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageLocalize: async (imageLocalizeRequest: ImageLocalizeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageLocalizeRequest' is not null or undefined
            assertParamExists('imageLocalize', 'imageLocalizeRequest', imageLocalizeRequest)
            const localVarPath = `/@apostrophecms/image/localize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageLocalizeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a localized version of the specified image document for a specific language/region
         * @summary Localize image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {PageLocalizeByIdRequest} pageLocalizeByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageLocalizeById: async (id: string, pageLocalizeByIdRequest: PageLocalizeByIdRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageLocalizeById', 'id', id)
            // verify required parameter 'pageLocalizeByIdRequest' is not null or undefined
            assertParamExists('imageLocalizeById', 'pageLocalizeByIdRequest', pageLocalizeByIdRequest)
            const localVarPath = `/@apostrophecms/image/{_id}/localize`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pageLocalizeByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially update a specific image document by ID using PATCH semantics
         * @summary Update image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {ImagePatchByIdRequest} imagePatchByIdRequest 
         * @param {ImagePatchByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagePatchById: async (id: string, imagePatchByIdRequest: ImagePatchByIdRequest, aposMode?: ImagePatchByIdAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagePatchById', 'id', id)
            // verify required parameter 'imagePatchByIdRequest' is not null or undefined
            assertParamExists('imagePatchById', 'imagePatchByIdRequest', imagePatchByIdRequest)
            const localVarPath = `/@apostrophecms/image/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imagePatchByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new image document (requires prior attachment upload)
         * @summary Create image
         * @param {ImagePostRequest} imagePostRequest 
         * @param {ImagePostAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagePost: async (imagePostRequest: ImagePostRequest, aposMode?: ImagePostAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imagePostRequest' is not null or undefined
            assertParamExists('imagePost', 'imagePostRequest', imagePostRequest)
            const localVarPath = `/@apostrophecms/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imagePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk publish multiple images, making them live and visible to end users
         * @summary Publish images
         * @param {ImagePublishRequest} imagePublishRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagePublish: async (imagePublishRequest: ImagePublishRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imagePublishRequest' is not null or undefined
            assertParamExists('imagePublish', 'imagePublishRequest', imagePublishRequest)
            const localVarPath = `/@apostrophecms/image/publish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imagePublishRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publish the specified image document, making it live and visible to end users
         * @summary Publish image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagePublishById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagePublishById', 'id', id)
            const localVarPath = `/@apostrophecms/image/{_id}/publish`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completely replace an image document by ID using PUT semantics
         * @summary Replace image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {ImagePostRequest} imagePostRequest 
         * @param {ImagePutByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagePutById: async (id: string, imagePostRequest: ImagePostRequest, aposMode?: ImagePutByIdAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagePutById', 'id', id)
            // verify required parameter 'imagePostRequest' is not null or undefined
            assertParamExists('imagePutById', 'imagePostRequest', imagePostRequest)
            const localVarPath = `/@apostrophecms/image/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imagePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore previously archived images, making them active again
         * @summary Restore images
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageRestore: async (bulkOperationRequest: BulkOperationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkOperationRequest' is not null or undefined
            assertParamExists('imageRestore', 'bulkOperationRequest', bulkOperationRequest)
            const localVarPath = `/@apostrophecms/image/restore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkOperationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revert the draft version of the specified image document back to its published state
         * @summary Revert image draft to published
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageRevertDraftToPublishedById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageRevertDraftToPublishedById', 'id', id)
            const localVarPath = `/@apostrophecms/image/{_id}/revert-draft-to-published`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revert the published version of the specified image document to its previous published state
         * @summary Revert image published to previous
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageRevertPublishedToPreviousById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageRevertPublishedToPreviousById', 'id', id)
            const localVarPath = `/@apostrophecms/image/{_id}/revert-published-to-previous`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a sharing link or configure sharing permissions for the specified image document
         * @summary Share image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageShareById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageShareById', 'id', id)
            const localVarPath = `/@apostrophecms/image/{_id}/share`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit the specified image document for review and approval workflow
         * @summary Submit image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageSubmitById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageSubmitById', 'id', id)
            const localVarPath = `/@apostrophecms/image/{_id}/submit`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add tags to multiple images for better organization and searchability
         * @summary Tag images
         * @param {ImageTagRequest} imageTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTag: async (imageTagRequest: ImageTagRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageTagRequest' is not null or undefined
            assertParamExists('imageTag', 'imageTagRequest', imageTagRequest)
            const localVarPath = `/@apostrophecms/image/tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageTagRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Archive multiple image tags, making them inactive while preserving their data
         * @summary Archive image tags
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagArchive: async (bulkOperationRequest: BulkOperationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkOperationRequest' is not null or undefined
            assertParamExists('imageTagArchive', 'bulkOperationRequest', bulkOperationRequest)
            const localVarPath = `/@apostrophecms/image-tag/archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkOperationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete a specific image tag by ID (requires appropriate permissions)
         * @summary Delete image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagDeleteById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageTagDeleteById', 'id', id)
            const localVarPath = `/@apostrophecms/image-tag/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Dismiss a pending submission for the specified image tag, removing it from the review queue
         * @summary Dismiss image tag submission
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagDismissSubmissionById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageTagDismissSubmissionById', 'id', id)
            const localVarPath = `/@apostrophecms/image-tag/{_id}/dismiss-submission`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve image tags for organizing images
         * @summary Get image tags
         * @param {number} [page] Page number for pagination (1-based)
         * @param {number} [perPage] Number of items per page
         * @param {string} [search] Search term for filtering results
         * @param {ImageTagGetAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagGet: async (page?: number, perPage?: number, search?: string, aposMode?: ImageTagGetAposModeEnum, aposLocale?: string, renderAreas?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/image-tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }

            if (renderAreas !== undefined) {
                localVarQueryParameter['render-areas'] = renderAreas;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific image tag by ID
         * @summary Get image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {ImageTagGetByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagGetById: async (id: string, aposMode?: ImageTagGetByIdAposModeEnum, aposLocale?: string, renderAreas?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageTagGetById', 'id', id)
            const localVarPath = `/@apostrophecms/image-tag/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }

            if (renderAreas !== undefined) {
                localVarQueryParameter['render-areas'] = renderAreas;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the specified image tag in a specific locale
         * @summary Get image tag locale
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} toLocale Target locale code (e.g., en:us:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagGetLocaleById: async (id: string, toLocale: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageTagGetLocaleById', 'id', id)
            // verify required parameter 'toLocale' is not null or undefined
            assertParamExists('imageTagGetLocaleById', 'toLocale', toLocale)
            const localVarPath = `/@apostrophecms/image-tag/{_id}/locale/{toLocale}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"toLocale"}}`, encodeURIComponent(String(toLocale)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all available locales for the specified image tag
         * @summary Get image tag locales
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagGetLocalesById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageTagGetLocalesById', 'id', id)
            const localVarPath = `/@apostrophecms/image-tag/{_id}/locales`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update localized versions of image tags for different languages/regions
         * @summary Localize image tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagLocalize: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/image-tag/localize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a localized version of the specified image tag for a specific language/region
         * @summary Localize image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagLocalizeById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageTagLocalizeById', 'id', id)
            const localVarPath = `/@apostrophecms/image-tag/{_id}/localize`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially update a specific image tag by ID using PATCH semantics
         * @summary Update image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {ImageTagPatchByIdRequest} imageTagPatchByIdRequest 
         * @param {ImageTagPatchByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagPatchById: async (id: string, imageTagPatchByIdRequest: ImageTagPatchByIdRequest, aposMode?: ImageTagPatchByIdAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageTagPatchById', 'id', id)
            // verify required parameter 'imageTagPatchByIdRequest' is not null or undefined
            assertParamExists('imageTagPatchById', 'imageTagPatchByIdRequest', imageTagPatchByIdRequest)
            const localVarPath = `/@apostrophecms/image-tag/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageTagPatchByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new image tag for organizing images
         * @summary Create image tag
         * @param {ImageTagPostRequest} imageTagPostRequest 
         * @param {ImageTagPostAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagPost: async (imageTagPostRequest: ImageTagPostRequest, aposMode?: ImageTagPostAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageTagPostRequest' is not null or undefined
            assertParamExists('imageTagPost', 'imageTagPostRequest', imageTagPostRequest)
            const localVarPath = `/@apostrophecms/image-tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageTagPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publish multiple image tags, making them live and visible to end users
         * @summary Publish image tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagPublish: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/image-tag/publish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publish the specified image tag, making it live and visible to end users
         * @summary Publish image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagPublishById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageTagPublishById', 'id', id)
            const localVarPath = `/@apostrophecms/image-tag/{_id}/publish`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completely replace a specific image tag by ID using PUT semantics
         * @summary Replace image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {ImageTagPostRequest} imageTagPostRequest 
         * @param {ImageTagPutByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagPutById: async (id: string, imageTagPostRequest: ImageTagPostRequest, aposMode?: ImageTagPutByIdAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageTagPutById', 'id', id)
            // verify required parameter 'imageTagPostRequest' is not null or undefined
            assertParamExists('imageTagPutById', 'imageTagPostRequest', imageTagPostRequest)
            const localVarPath = `/@apostrophecms/image-tag/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageTagPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore previously archived image tags, making them active again
         * @summary Restore image tags
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagRestore: async (bulkOperationRequest: BulkOperationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkOperationRequest' is not null or undefined
            assertParamExists('imageTagRestore', 'bulkOperationRequest', bulkOperationRequest)
            const localVarPath = `/@apostrophecms/image-tag/restore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkOperationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revert the draft version of the specified image tag back to its published state
         * @summary Revert draft to published
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagRevertDraftToPublishedById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageTagRevertDraftToPublishedById', 'id', id)
            const localVarPath = `/@apostrophecms/image-tag/{_id}/revert-draft-to-published`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revert the published version of the specified image tag to its previous published state
         * @summary Revert published to previous
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagRevertPublishedToPreviousById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageTagRevertPublishedToPreviousById', 'id', id)
            const localVarPath = `/@apostrophecms/image-tag/{_id}/revert-published-to-previous`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a sharing link or configure sharing permissions for the specified image tag
         * @summary Share image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagShareById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageTagShareById', 'id', id)
            const localVarPath = `/@apostrophecms/image-tag/{_id}/share`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit the specified image tag for review and approval workflow
         * @summary Submit image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagSubmitById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageTagSubmitById', 'id', id)
            const localVarPath = `/@apostrophecms/image-tag/{_id}/submit`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unpublish the specified image tag, removing it from public visibility while preserving the content
         * @summary Unpublish image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagUnpublishById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageTagUnpublishById', 'id', id)
            const localVarPath = `/@apostrophecms/image-tag/{_id}/unpublish`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unpublish the specified image document, removing it from public visibility while preserving the content
         * @summary Unpublish image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUnpublishById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageUnpublishById', 'id', id)
            const localVarPath = `/@apostrophecms/image/{_id}/unpublish`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaApi - functional programming interface
 * @export
 */
export const MediaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MediaApiAxiosParamCreator(configuration)
    return {
        /**
         * Archive multiple files, making them inactive while preserving their data
         * @summary Archive files
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileArchive(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageArchive200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileArchive(bulkOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileArchive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently delete a specific file by ID (requires appropriate permissions)
         * @summary Delete file
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {FileDeleteByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileDeleteById(id: string, aposMode?: FileDeleteByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileDeleteById(id, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileDeleteById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Dismiss a pending submission for the specified file, removing it from the review queue
         * @summary Dismiss file submission
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileDismissSubmissionById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileDismissSubmissionById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileDismissSubmissionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a paginated list of files from the media library
         * @summary List files
         * @param {number} [page] Page number for pagination (1-based)
         * @param {number} [perPage] Number of items per page
         * @param {string} [search] Search term for filtering results
         * @param {FileGetAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileGet(page?: number, perPage?: number, search?: string, aposMode?: FileGetAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileGet(page, perPage, search, aposMode, aposLocale, renderAreas, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific file by ID from the media library
         * @summary Get file by ID
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {FileGetByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileGetById(id: string, aposMode?: FileGetByIdAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileGetById(id, aposMode, aposLocale, renderAreas, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the specified file in a specific locale
         * @summary Get file locale
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} toLocale Target locale code (e.g., en:us:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileGetLocaleById(id: string, toLocale: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileGetLocaleById(id, toLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileGetLocaleById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all available locales for the specified file
         * @summary Get file locales
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileGetLocalesById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileGetLocalesById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileGetLocalesById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or update localized versions of files for different languages/regions
         * @summary Localize files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileLocalize(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileLocalize(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileLocalize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a localized version of the specified file for a specific language/region
         * @summary Localize file
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileLocalizeById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileLocalizeById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileLocalizeById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update a specific file by ID using PATCH semantics
         * @summary Update file
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {FilePatchByIdRequest} filePatchByIdRequest 
         * @param {FilePatchByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filePatchById(id: string, filePatchByIdRequest: FilePatchByIdRequest, aposMode?: FilePatchByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filePatchById(id, filePatchByIdRequest, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.filePatchById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new file document (requires prior attachment upload)
         * @summary Create file
         * @param {FilePostRequest} filePostRequest 
         * @param {FilePostAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filePost(filePostRequest: FilePostRequest, aposMode?: FilePostAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filePost(filePostRequest, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.filePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Bulk publish multiple files, making them live and visible to end users
         * @summary Publish files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filePublish(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filePublish(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.filePublish']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Publish the specified file, making it live and visible to end users
         * @summary Publish file
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filePublishById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filePublishById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.filePublishById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Completely replace a specific file by ID using PUT semantics
         * @summary Replace file
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {FilePostRequest} filePostRequest 
         * @param {FilePutByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filePutById(id: string, filePostRequest: FilePostRequest, aposMode?: FilePutByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filePutById(id, filePostRequest, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.filePutById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restore previously archived files, making them active again
         * @summary Restore files
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileRestore(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileRestore(bulkOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revert the draft version of the specified file back to its published state
         * @summary Revert file draft to published
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileRevertDraftToPublishedById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileRevertDraftToPublishedById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileRevertDraftToPublishedById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revert the published version of the specified file to its previous published state
         * @summary Revert file published to previous
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileRevertPublishedToPreviousById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileRevertPublishedToPreviousById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileRevertPublishedToPreviousById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate a sharing link or configure sharing permissions for the specified file
         * @summary Share file
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileShareById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileShareById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileShareById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit the specified file for review and approval workflow
         * @summary Submit file
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileSubmitById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileSubmitById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileSubmitById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Archive multiple file tags, making them inactive while preserving their data
         * @summary Archive file tags
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileTagArchive(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileTag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileTagArchive(bulkOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileTagArchive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently delete a specific file tag by ID (requires appropriate permissions)
         * @summary Delete file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileTagDeleteById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileTagDeleteById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileTagDeleteById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Dismiss a pending submission for the specified file tag, removing it from the review queue
         * @summary Dismiss file tag submission
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileTagDismissSubmissionById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileTagDismissSubmissionById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileTagDismissSubmissionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of file tags used for organizing and categorizing uploaded files
         * @summary List file tags
         * @param {FileTagGetAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileTagGet(aposMode?: FileTagGetAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTagGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileTagGet(aposMode, aposLocale, renderAreas, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileTagGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific file tag by ID
         * @summary Get file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {FileTagGetByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileTagGetById(id: string, aposMode?: FileTagGetByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileTagGetById(id, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileTagGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the specified file tag in a specific locale
         * @summary Get file tag locale
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} toLocale Target locale code (e.g., en:us:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileTagGetLocaleById(id: string, toLocale: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileTagGetLocaleById(id, toLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileTagGetLocaleById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all available locales for the specified file tag
         * @summary Get file tag locales
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileTagGetLocalesById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileTagGetLocalesById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileTagGetLocalesById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or update localized versions of file tags for different languages/regions
         * @summary Localize file tags
         * @param {FileTagLocalizeRequest} fileTagLocalizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileTagLocalize(fileTagLocalizeRequest: FileTagLocalizeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileTag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileTagLocalize(fileTagLocalizeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileTagLocalize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a localized version of the specified file tag for a specific language/region
         * @summary Localize file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {PageLocalizeByIdRequest} pageLocalizeByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileTagLocalizeById(id: string, pageLocalizeByIdRequest: PageLocalizeByIdRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileTagLocalizeById(id, pageLocalizeByIdRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileTagLocalizeById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update a specific file tag by ID using PATCH semantics
         * @summary Update file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {FileTagPatchByIdRequest} fileTagPatchByIdRequest 
         * @param {FileTagPatchByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileTagPatchById(id: string, fileTagPatchByIdRequest: FileTagPatchByIdRequest, aposMode?: FileTagPatchByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileTagPatchById(id, fileTagPatchByIdRequest, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileTagPatchById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new file tag for organizing uploaded files (requires editor permissions or higher)
         * @summary Create file tag
         * @param {FileTagPostRequest} fileTagPostRequest 
         * @param {FileTagPostAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileTagPost(fileTagPostRequest: FileTagPostRequest, aposMode?: FileTagPostAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileTagPost(fileTagPostRequest, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileTagPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Publish multiple file tags, making them live and visible to end users
         * @summary Publish file tags
         * @param {FileTagPublishRequest} fileTagPublishRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileTagPublish(fileTagPublishRequest: FileTagPublishRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileTag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileTagPublish(fileTagPublishRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileTagPublish']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Publish the specified file tag, making it live and visible to end users
         * @summary Publish file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileTagPublishById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileTagPublishById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileTagPublishById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Completely replace a specific file tag by ID using PUT semantics
         * @summary Replace file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {FileTagPutByIdRequest} fileTagPutByIdRequest 
         * @param {FileTagPutByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileTagPutById(id: string, fileTagPutByIdRequest: FileTagPutByIdRequest, aposMode?: FileTagPutByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileTagPutById(id, fileTagPutByIdRequest, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileTagPutById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restore previously archived file tags, making them active again
         * @summary Restore file tags
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileTagRestore(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileTag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileTagRestore(bulkOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileTagRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revert the draft version of the specified file tag back to its published state
         * @summary Revert file tag draft to published
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileTagRevertDraftToPublishedById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileTagRevertDraftToPublishedById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileTagRevertDraftToPublishedById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revert the published version of the specified file tag to its previous published state
         * @summary Revert file tag published to previous
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileTagRevertPublishedToPreviousById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileTagRevertPublishedToPreviousById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileTagRevertPublishedToPreviousById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate a sharing link or configure sharing permissions for the specified file tag
         * @summary Share file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileTagShareById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileTagShareById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileTagShareById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit the specified file tag for review and approval workflow
         * @summary Submit file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileTagSubmitById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileTagSubmitById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileTagSubmitById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unpublish the specified file tag, removing it from public visibility while preserving the content
         * @summary Unpublish file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileTagUnpublishById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileTagUnpublishById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileTagUnpublishById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unpublish the specified file, removing it from public visibility while preserving the content
         * @summary Unpublish file
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileUnpublishById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileUnpublishById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.fileUnpublishById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Archive multiple images, making them inactive while preserving their data
         * @summary Archive images
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageArchive(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageArchive200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageArchive(bulkOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageArchive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Automatically crop uploaded images using intelligent cropping algorithms
         * @summary Auto-crop images
         * @param {ImageAutocropRequest} imageAutocropRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageAutocrop(imageAutocropRequest: ImageAutocropRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Image>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageAutocrop(imageAutocropRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageAutocrop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently delete a specific image document by ID (requires appropriate permissions)
         * @summary Delete image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageDeleteById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageDeleteById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageDeleteById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Dismiss a pending submission for the specified image document, removing it from the review queue
         * @summary Dismiss image submission
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageDismissSubmissionById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageDismissSubmissionById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageDismissSubmissionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve images from the media library.  Authentication is required for all requests other than GET requests  for images with defined publicApiProjection. 
         * @summary Get images
         * @param {number} [page] Page number for pagination (1-based)
         * @param {number} [perPage] Number of items per page
         * @param {string} [search] Search term for filtering results
         * @param {ImageGetAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageGet(page?: number, perPage?: number, search?: string, aposMode?: ImageGetAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageGet(page, perPage, search, aposMode, aposLocale, renderAreas, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific image by ID from the media library. Authentication is required for all requests other than GET requests  for images with defined publicApiProjection. 
         * @summary Get image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {ImageGetByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageGetById(id: string, aposMode?: ImageGetByIdAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageGetById(id, aposMode, aposLocale, renderAreas, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the specified image document in a specific locale
         * @summary Get image document locale
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} toLocale Target locale code (e.g., en:us:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageGetLocaleById(id: string, toLocale: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageGetLocaleById(id, toLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageGetLocaleById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all available locales for the specified image document
         * @summary Get image document locales
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageGetLocalesById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageGetLocalesById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageGetLocalesById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the source URL for a specific image, with optional size and format parameters
         * @summary Get image source URL
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {ImageGetSrcByIdSizeEnum} [size] Image size variant
         * @param {ImageGetSrcByIdFormatEnum} [format] Image format
         * @param {number} [quality] Image quality (1-100)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageGetSrcById(id: string, size?: ImageGetSrcByIdSizeEnum, format?: ImageGetSrcByIdFormatEnum, quality?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageGetSrcById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageGetSrcById(id, size, format, quality, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageGetSrcById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or update localized versions of images for different languages/regions
         * @summary Localize images
         * @param {ImageLocalizeRequest} imageLocalizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageLocalize(imageLocalizeRequest: ImageLocalizeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Image>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageLocalize(imageLocalizeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageLocalize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a localized version of the specified image document for a specific language/region
         * @summary Localize image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {PageLocalizeByIdRequest} pageLocalizeByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageLocalizeById(id: string, pageLocalizeByIdRequest: PageLocalizeByIdRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageLocalizeById(id, pageLocalizeByIdRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageLocalizeById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update a specific image document by ID using PATCH semantics
         * @summary Update image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {ImagePatchByIdRequest} imagePatchByIdRequest 
         * @param {ImagePatchByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagePatchById(id: string, imagePatchByIdRequest: ImagePatchByIdRequest, aposMode?: ImagePatchByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagePatchById(id, imagePatchByIdRequest, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imagePatchById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new image document (requires prior attachment upload)
         * @summary Create image
         * @param {ImagePostRequest} imagePostRequest 
         * @param {ImagePostAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagePost(imagePostRequest: ImagePostRequest, aposMode?: ImagePostAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagePost(imagePostRequest, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imagePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Bulk publish multiple images, making them live and visible to end users
         * @summary Publish images
         * @param {ImagePublishRequest} imagePublishRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagePublish(imagePublishRequest: ImagePublishRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Image>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagePublish(imagePublishRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imagePublish']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Publish the specified image document, making it live and visible to end users
         * @summary Publish image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagePublishById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagePublishById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imagePublishById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Completely replace an image document by ID using PUT semantics
         * @summary Replace image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {ImagePostRequest} imagePostRequest 
         * @param {ImagePutByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imagePutById(id: string, imagePostRequest: ImagePostRequest, aposMode?: ImagePutByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagePutById(id, imagePostRequest, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imagePutById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restore previously archived images, making them active again
         * @summary Restore images
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageRestore(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Image>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageRestore(bulkOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revert the draft version of the specified image document back to its published state
         * @summary Revert image draft to published
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageRevertDraftToPublishedById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageRevertDraftToPublishedById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageRevertDraftToPublishedById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revert the published version of the specified image document to its previous published state
         * @summary Revert image published to previous
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageRevertPublishedToPreviousById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageRevertPublishedToPreviousById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageRevertPublishedToPreviousById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate a sharing link or configure sharing permissions for the specified image document
         * @summary Share image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageShareById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageShareById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageShareById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit the specified image document for review and approval workflow
         * @summary Submit image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageSubmitById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageSubmitById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageSubmitById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add tags to multiple images for better organization and searchability
         * @summary Tag images
         * @param {ImageTagRequest} imageTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageTag(imageTagRequest: ImageTagRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Image>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageTag(imageTagRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageTag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Archive multiple image tags, making them inactive while preserving their data
         * @summary Archive image tags
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageTagArchive(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageArchive200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageTagArchive(bulkOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageTagArchive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently delete a specific image tag by ID (requires appropriate permissions)
         * @summary Delete image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageTagDeleteById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageTagDeleteById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageTagDeleteById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Dismiss a pending submission for the specified image tag, removing it from the review queue
         * @summary Dismiss image tag submission
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageTagDismissSubmissionById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageTagDismissSubmissionById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageTagDismissSubmissionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve image tags for organizing images
         * @summary Get image tags
         * @param {number} [page] Page number for pagination (1-based)
         * @param {number} [perPage] Number of items per page
         * @param {string} [search] Search term for filtering results
         * @param {ImageTagGetAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageTagGet(page?: number, perPage?: number, search?: string, aposMode?: ImageTagGetAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageTagGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageTagGet(page, perPage, search, aposMode, aposLocale, renderAreas, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageTagGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific image tag by ID
         * @summary Get image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {ImageTagGetByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageTagGetById(id: string, aposMode?: ImageTagGetByIdAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageTagGetById(id, aposMode, aposLocale, renderAreas, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageTagGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the specified image tag in a specific locale
         * @summary Get image tag locale
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} toLocale Target locale code (e.g., en:us:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageTagGetLocaleById(id: string, toLocale: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageTagGetLocaleById(id, toLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageTagGetLocaleById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all available locales for the specified image tag
         * @summary Get image tag locales
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageTagGetLocalesById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageTagGetLocalesById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageTagGetLocalesById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or update localized versions of image tags for different languages/regions
         * @summary Localize image tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageTagLocalize(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageTag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageTagLocalize(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageTagLocalize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a localized version of the specified image tag for a specific language/region
         * @summary Localize image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageTagLocalizeById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageTagLocalizeById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageTagLocalizeById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update a specific image tag by ID using PATCH semantics
         * @summary Update image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {ImageTagPatchByIdRequest} imageTagPatchByIdRequest 
         * @param {ImageTagPatchByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageTagPatchById(id: string, imageTagPatchByIdRequest: ImageTagPatchByIdRequest, aposMode?: ImageTagPatchByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageTagPatchById(id, imageTagPatchByIdRequest, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageTagPatchById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new image tag for organizing images
         * @summary Create image tag
         * @param {ImageTagPostRequest} imageTagPostRequest 
         * @param {ImageTagPostAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageTagPost(imageTagPostRequest: ImageTagPostRequest, aposMode?: ImageTagPostAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageTagPost(imageTagPostRequest, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageTagPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Publish multiple image tags, making them live and visible to end users
         * @summary Publish image tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageTagPublish(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageTag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageTagPublish(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageTagPublish']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Publish the specified image tag, making it live and visible to end users
         * @summary Publish image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageTagPublishById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageTagPublishById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageTagPublishById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Completely replace a specific image tag by ID using PUT semantics
         * @summary Replace image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {ImageTagPostRequest} imageTagPostRequest 
         * @param {ImageTagPutByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageTagPutById(id: string, imageTagPostRequest: ImageTagPostRequest, aposMode?: ImageTagPutByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageTagPutById(id, imageTagPostRequest, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageTagPutById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restore previously archived image tags, making them active again
         * @summary Restore image tags
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageTagRestore(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageTag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageTagRestore(bulkOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageTagRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revert the draft version of the specified image tag back to its published state
         * @summary Revert draft to published
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageTagRevertDraftToPublishedById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageTagRevertDraftToPublishedById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageTagRevertDraftToPublishedById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revert the published version of the specified image tag to its previous published state
         * @summary Revert published to previous
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageTagRevertPublishedToPreviousById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageTagRevertPublishedToPreviousById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageTagRevertPublishedToPreviousById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate a sharing link or configure sharing permissions for the specified image tag
         * @summary Share image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageTagShareById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageTagShareById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageTagShareById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit the specified image tag for review and approval workflow
         * @summary Submit image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageTagSubmitById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageTagSubmitById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageTagSubmitById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unpublish the specified image tag, removing it from public visibility while preserving the content
         * @summary Unpublish image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageTagUnpublishById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageTagUnpublishById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageTagUnpublishById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unpublish the specified image document, removing it from public visibility while preserving the content
         * @summary Unpublish image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUnpublishById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUnpublishById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.imageUnpublishById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MediaApi - factory interface
 * @export
 */
export const MediaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MediaApiFp(configuration)
    return {
        /**
         * Archive multiple files, making them inactive while preserving their data
         * @summary Archive files
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileArchive(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<PageArchive200Response> {
            return localVarFp.fileArchive(bulkOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently delete a specific file by ID (requires appropriate permissions)
         * @summary Delete file
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {FileDeleteByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileDeleteById(id: string, aposMode?: FileDeleteByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<FileObject> {
            return localVarFp.fileDeleteById(id, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Dismiss a pending submission for the specified file, removing it from the review queue
         * @summary Dismiss file submission
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileDismissSubmissionById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FileObject> {
            return localVarFp.fileDismissSubmissionById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a paginated list of files from the media library
         * @summary List files
         * @param {number} [page] Page number for pagination (1-based)
         * @param {number} [perPage] Number of items per page
         * @param {string} [search] Search term for filtering results
         * @param {FileGetAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileGet(page?: number, perPage?: number, search?: string, aposMode?: FileGetAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<FileGet200Response> {
            return localVarFp.fileGet(page, perPage, search, aposMode, aposLocale, renderAreas, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific file by ID from the media library
         * @summary Get file by ID
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {FileGetByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileGetById(id: string, aposMode?: FileGetByIdAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<FileObject> {
            return localVarFp.fileGetById(id, aposMode, aposLocale, renderAreas, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the specified file in a specific locale
         * @summary Get file locale
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} toLocale Target locale code (e.g., en:us:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileGetLocaleById(id: string, toLocale: string, options?: RawAxiosRequestConfig): AxiosPromise<FileObject> {
            return localVarFp.fileGetLocaleById(id, toLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all available locales for the specified file
         * @summary Get file locales
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileGetLocalesById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.fileGetLocalesById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update localized versions of files for different languages/regions
         * @summary Localize files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileLocalize(options?: RawAxiosRequestConfig): AxiosPromise<Array<FileObject>> {
            return localVarFp.fileLocalize(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a localized version of the specified file for a specific language/region
         * @summary Localize file
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileLocalizeById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FileObject> {
            return localVarFp.fileLocalizeById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Partially update a specific file by ID using PATCH semantics
         * @summary Update file
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {FilePatchByIdRequest} filePatchByIdRequest 
         * @param {FilePatchByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filePatchById(id: string, filePatchByIdRequest: FilePatchByIdRequest, aposMode?: FilePatchByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<FileObject> {
            return localVarFp.filePatchById(id, filePatchByIdRequest, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new file document (requires prior attachment upload)
         * @summary Create file
         * @param {FilePostRequest} filePostRequest 
         * @param {FilePostAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filePost(filePostRequest: FilePostRequest, aposMode?: FilePostAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<FileObject> {
            return localVarFp.filePost(filePostRequest, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Bulk publish multiple files, making them live and visible to end users
         * @summary Publish files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filePublish(options?: RawAxiosRequestConfig): AxiosPromise<Array<FileObject>> {
            return localVarFp.filePublish(options).then((request) => request(axios, basePath));
        },
        /**
         * Publish the specified file, making it live and visible to end users
         * @summary Publish file
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filePublishById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FileObject> {
            return localVarFp.filePublishById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Completely replace a specific file by ID using PUT semantics
         * @summary Replace file
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {FilePostRequest} filePostRequest 
         * @param {FilePutByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filePutById(id: string, filePostRequest: FilePostRequest, aposMode?: FilePutByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<FileObject> {
            return localVarFp.filePutById(id, filePostRequest, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore previously archived files, making them active again
         * @summary Restore files
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileRestore(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FileObject>> {
            return localVarFp.fileRestore(bulkOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Revert the draft version of the specified file back to its published state
         * @summary Revert file draft to published
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileRevertDraftToPublishedById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FileObject> {
            return localVarFp.fileRevertDraftToPublishedById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Revert the published version of the specified file to its previous published state
         * @summary Revert file published to previous
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileRevertPublishedToPreviousById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FileObject> {
            return localVarFp.fileRevertPublishedToPreviousById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a sharing link or configure sharing permissions for the specified file
         * @summary Share file
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileShareById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FileObject> {
            return localVarFp.fileShareById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit the specified file for review and approval workflow
         * @summary Submit file
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileSubmitById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FileObject> {
            return localVarFp.fileSubmitById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Archive multiple file tags, making them inactive while preserving their data
         * @summary Archive file tags
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagArchive(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FileTag>> {
            return localVarFp.fileTagArchive(bulkOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently delete a specific file tag by ID (requires appropriate permissions)
         * @summary Delete file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagDeleteById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTag> {
            return localVarFp.fileTagDeleteById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Dismiss a pending submission for the specified file tag, removing it from the review queue
         * @summary Dismiss file tag submission
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagDismissSubmissionById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTag> {
            return localVarFp.fileTagDismissSubmissionById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of file tags used for organizing and categorizing uploaded files
         * @summary List file tags
         * @param {FileTagGetAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagGet(aposMode?: FileTagGetAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<FileTagGet200Response> {
            return localVarFp.fileTagGet(aposMode, aposLocale, renderAreas, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific file tag by ID
         * @summary Get file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {FileTagGetByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagGetById(id: string, aposMode?: FileTagGetByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTag> {
            return localVarFp.fileTagGetById(id, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the specified file tag in a specific locale
         * @summary Get file tag locale
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} toLocale Target locale code (e.g., en:us:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagGetLocaleById(id: string, toLocale: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTag> {
            return localVarFp.fileTagGetLocaleById(id, toLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all available locales for the specified file tag
         * @summary Get file tag locales
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagGetLocalesById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.fileTagGetLocalesById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update localized versions of file tags for different languages/regions
         * @summary Localize file tags
         * @param {FileTagLocalizeRequest} fileTagLocalizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagLocalize(fileTagLocalizeRequest: FileTagLocalizeRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FileTag>> {
            return localVarFp.fileTagLocalize(fileTagLocalizeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a localized version of the specified file tag for a specific language/region
         * @summary Localize file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {PageLocalizeByIdRequest} pageLocalizeByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagLocalizeById(id: string, pageLocalizeByIdRequest: PageLocalizeByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<FileTag> {
            return localVarFp.fileTagLocalizeById(id, pageLocalizeByIdRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Partially update a specific file tag by ID using PATCH semantics
         * @summary Update file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {FileTagPatchByIdRequest} fileTagPatchByIdRequest 
         * @param {FileTagPatchByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagPatchById(id: string, fileTagPatchByIdRequest: FileTagPatchByIdRequest, aposMode?: FileTagPatchByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTag> {
            return localVarFp.fileTagPatchById(id, fileTagPatchByIdRequest, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new file tag for organizing uploaded files (requires editor permissions or higher)
         * @summary Create file tag
         * @param {FileTagPostRequest} fileTagPostRequest 
         * @param {FileTagPostAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagPost(fileTagPostRequest: FileTagPostRequest, aposMode?: FileTagPostAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTag> {
            return localVarFp.fileTagPost(fileTagPostRequest, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Publish multiple file tags, making them live and visible to end users
         * @summary Publish file tags
         * @param {FileTagPublishRequest} fileTagPublishRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagPublish(fileTagPublishRequest: FileTagPublishRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FileTag>> {
            return localVarFp.fileTagPublish(fileTagPublishRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Publish the specified file tag, making it live and visible to end users
         * @summary Publish file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagPublishById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTag> {
            return localVarFp.fileTagPublishById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Completely replace a specific file tag by ID using PUT semantics
         * @summary Replace file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {FileTagPutByIdRequest} fileTagPutByIdRequest 
         * @param {FileTagPutByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagPutById(id: string, fileTagPutByIdRequest: FileTagPutByIdRequest, aposMode?: FileTagPutByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTag> {
            return localVarFp.fileTagPutById(id, fileTagPutByIdRequest, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore previously archived file tags, making them active again
         * @summary Restore file tags
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagRestore(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FileTag>> {
            return localVarFp.fileTagRestore(bulkOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Revert the draft version of the specified file tag back to its published state
         * @summary Revert file tag draft to published
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagRevertDraftToPublishedById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTag> {
            return localVarFp.fileTagRevertDraftToPublishedById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Revert the published version of the specified file tag to its previous published state
         * @summary Revert file tag published to previous
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagRevertPublishedToPreviousById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTag> {
            return localVarFp.fileTagRevertPublishedToPreviousById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a sharing link or configure sharing permissions for the specified file tag
         * @summary Share file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagShareById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTag> {
            return localVarFp.fileTagShareById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit the specified file tag for review and approval workflow
         * @summary Submit file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagSubmitById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTag> {
            return localVarFp.fileTagSubmitById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Unpublish the specified file tag, removing it from public visibility while preserving the content
         * @summary Unpublish file tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileTagUnpublishById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTag> {
            return localVarFp.fileTagUnpublishById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Unpublish the specified file, removing it from public visibility while preserving the content
         * @summary Unpublish file
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileUnpublishById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FileObject> {
            return localVarFp.fileUnpublishById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Archive multiple images, making them inactive while preserving their data
         * @summary Archive images
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageArchive(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<PageArchive200Response> {
            return localVarFp.imageArchive(bulkOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Automatically crop uploaded images using intelligent cropping algorithms
         * @summary Auto-crop images
         * @param {ImageAutocropRequest} imageAutocropRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageAutocrop(imageAutocropRequest: ImageAutocropRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Image>> {
            return localVarFp.imageAutocrop(imageAutocropRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently delete a specific image document by ID (requires appropriate permissions)
         * @summary Delete image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageDeleteById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Image> {
            return localVarFp.imageDeleteById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Dismiss a pending submission for the specified image document, removing it from the review queue
         * @summary Dismiss image submission
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageDismissSubmissionById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Image> {
            return localVarFp.imageDismissSubmissionById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve images from the media library.  Authentication is required for all requests other than GET requests  for images with defined publicApiProjection. 
         * @summary Get images
         * @param {number} [page] Page number for pagination (1-based)
         * @param {number} [perPage] Number of items per page
         * @param {string} [search] Search term for filtering results
         * @param {ImageGetAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageGet(page?: number, perPage?: number, search?: string, aposMode?: ImageGetAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ImageGet200Response> {
            return localVarFp.imageGet(page, perPage, search, aposMode, aposLocale, renderAreas, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific image by ID from the media library. Authentication is required for all requests other than GET requests  for images with defined publicApiProjection. 
         * @summary Get image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {ImageGetByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageGetById(id: string, aposMode?: ImageGetByIdAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Image> {
            return localVarFp.imageGetById(id, aposMode, aposLocale, renderAreas, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the specified image document in a specific locale
         * @summary Get image document locale
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} toLocale Target locale code (e.g., en:us:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageGetLocaleById(id: string, toLocale: string, options?: RawAxiosRequestConfig): AxiosPromise<Image> {
            return localVarFp.imageGetLocaleById(id, toLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all available locales for the specified image document
         * @summary Get image document locales
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageGetLocalesById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.imageGetLocalesById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the source URL for a specific image, with optional size and format parameters
         * @summary Get image source URL
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {ImageGetSrcByIdSizeEnum} [size] Image size variant
         * @param {ImageGetSrcByIdFormatEnum} [format] Image format
         * @param {number} [quality] Image quality (1-100)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageGetSrcById(id: string, size?: ImageGetSrcByIdSizeEnum, format?: ImageGetSrcByIdFormatEnum, quality?: number, options?: RawAxiosRequestConfig): AxiosPromise<ImageGetSrcById200Response> {
            return localVarFp.imageGetSrcById(id, size, format, quality, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update localized versions of images for different languages/regions
         * @summary Localize images
         * @param {ImageLocalizeRequest} imageLocalizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageLocalize(imageLocalizeRequest: ImageLocalizeRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Image>> {
            return localVarFp.imageLocalize(imageLocalizeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a localized version of the specified image document for a specific language/region
         * @summary Localize image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {PageLocalizeByIdRequest} pageLocalizeByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageLocalizeById(id: string, pageLocalizeByIdRequest: PageLocalizeByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<Image> {
            return localVarFp.imageLocalizeById(id, pageLocalizeByIdRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Partially update a specific image document by ID using PATCH semantics
         * @summary Update image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {ImagePatchByIdRequest} imagePatchByIdRequest 
         * @param {ImagePatchByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagePatchById(id: string, imagePatchByIdRequest: ImagePatchByIdRequest, aposMode?: ImagePatchByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<Image> {
            return localVarFp.imagePatchById(id, imagePatchByIdRequest, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new image document (requires prior attachment upload)
         * @summary Create image
         * @param {ImagePostRequest} imagePostRequest 
         * @param {ImagePostAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagePost(imagePostRequest: ImagePostRequest, aposMode?: ImagePostAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<Image> {
            return localVarFp.imagePost(imagePostRequest, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Bulk publish multiple images, making them live and visible to end users
         * @summary Publish images
         * @param {ImagePublishRequest} imagePublishRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagePublish(imagePublishRequest: ImagePublishRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Image>> {
            return localVarFp.imagePublish(imagePublishRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Publish the specified image document, making it live and visible to end users
         * @summary Publish image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagePublishById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Image> {
            return localVarFp.imagePublishById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Completely replace an image document by ID using PUT semantics
         * @summary Replace image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {ImagePostRequest} imagePostRequest 
         * @param {ImagePutByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imagePutById(id: string, imagePostRequest: ImagePostRequest, aposMode?: ImagePutByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<Image> {
            return localVarFp.imagePutById(id, imagePostRequest, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore previously archived images, making them active again
         * @summary Restore images
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageRestore(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Image>> {
            return localVarFp.imageRestore(bulkOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Revert the draft version of the specified image document back to its published state
         * @summary Revert image draft to published
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageRevertDraftToPublishedById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Image> {
            return localVarFp.imageRevertDraftToPublishedById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Revert the published version of the specified image document to its previous published state
         * @summary Revert image published to previous
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageRevertPublishedToPreviousById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Image> {
            return localVarFp.imageRevertPublishedToPreviousById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a sharing link or configure sharing permissions for the specified image document
         * @summary Share image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageShareById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Image> {
            return localVarFp.imageShareById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit the specified image document for review and approval workflow
         * @summary Submit image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageSubmitById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Image> {
            return localVarFp.imageSubmitById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Add tags to multiple images for better organization and searchability
         * @summary Tag images
         * @param {ImageTagRequest} imageTagRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTag(imageTagRequest: ImageTagRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Image>> {
            return localVarFp.imageTag(imageTagRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Archive multiple image tags, making them inactive while preserving their data
         * @summary Archive image tags
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagArchive(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<PageArchive200Response> {
            return localVarFp.imageTagArchive(bulkOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently delete a specific image tag by ID (requires appropriate permissions)
         * @summary Delete image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagDeleteById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageTag> {
            return localVarFp.imageTagDeleteById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Dismiss a pending submission for the specified image tag, removing it from the review queue
         * @summary Dismiss image tag submission
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagDismissSubmissionById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageTag> {
            return localVarFp.imageTagDismissSubmissionById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve image tags for organizing images
         * @summary Get image tags
         * @param {number} [page] Page number for pagination (1-based)
         * @param {number} [perPage] Number of items per page
         * @param {string} [search] Search term for filtering results
         * @param {ImageTagGetAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagGet(page?: number, perPage?: number, search?: string, aposMode?: ImageTagGetAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ImageTagGet200Response> {
            return localVarFp.imageTagGet(page, perPage, search, aposMode, aposLocale, renderAreas, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific image tag by ID
         * @summary Get image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {ImageTagGetByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagGetById(id: string, aposMode?: ImageTagGetByIdAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ImageTag> {
            return localVarFp.imageTagGetById(id, aposMode, aposLocale, renderAreas, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the specified image tag in a specific locale
         * @summary Get image tag locale
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} toLocale Target locale code (e.g., en:us:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagGetLocaleById(id: string, toLocale: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageTag> {
            return localVarFp.imageTagGetLocaleById(id, toLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all available locales for the specified image tag
         * @summary Get image tag locales
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagGetLocalesById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.imageTagGetLocalesById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update localized versions of image tags for different languages/regions
         * @summary Localize image tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagLocalize(options?: RawAxiosRequestConfig): AxiosPromise<Array<ImageTag>> {
            return localVarFp.imageTagLocalize(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a localized version of the specified image tag for a specific language/region
         * @summary Localize image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagLocalizeById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageTag> {
            return localVarFp.imageTagLocalizeById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Partially update a specific image tag by ID using PATCH semantics
         * @summary Update image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {ImageTagPatchByIdRequest} imageTagPatchByIdRequest 
         * @param {ImageTagPatchByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagPatchById(id: string, imageTagPatchByIdRequest: ImageTagPatchByIdRequest, aposMode?: ImageTagPatchByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageTag> {
            return localVarFp.imageTagPatchById(id, imageTagPatchByIdRequest, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new image tag for organizing images
         * @summary Create image tag
         * @param {ImageTagPostRequest} imageTagPostRequest 
         * @param {ImageTagPostAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagPost(imageTagPostRequest: ImageTagPostRequest, aposMode?: ImageTagPostAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageTag> {
            return localVarFp.imageTagPost(imageTagPostRequest, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Publish multiple image tags, making them live and visible to end users
         * @summary Publish image tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagPublish(options?: RawAxiosRequestConfig): AxiosPromise<Array<ImageTag>> {
            return localVarFp.imageTagPublish(options).then((request) => request(axios, basePath));
        },
        /**
         * Publish the specified image tag, making it live and visible to end users
         * @summary Publish image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagPublishById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageTag> {
            return localVarFp.imageTagPublishById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Completely replace a specific image tag by ID using PUT semantics
         * @summary Replace image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {ImageTagPostRequest} imageTagPostRequest 
         * @param {ImageTagPutByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagPutById(id: string, imageTagPostRequest: ImageTagPostRequest, aposMode?: ImageTagPutByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageTag> {
            return localVarFp.imageTagPutById(id, imageTagPostRequest, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore previously archived image tags, making them active again
         * @summary Restore image tags
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagRestore(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ImageTag>> {
            return localVarFp.imageTagRestore(bulkOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Revert the draft version of the specified image tag back to its published state
         * @summary Revert draft to published
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagRevertDraftToPublishedById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageTag> {
            return localVarFp.imageTagRevertDraftToPublishedById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Revert the published version of the specified image tag to its previous published state
         * @summary Revert published to previous
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagRevertPublishedToPreviousById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageTag> {
            return localVarFp.imageTagRevertPublishedToPreviousById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a sharing link or configure sharing permissions for the specified image tag
         * @summary Share image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagShareById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageTag> {
            return localVarFp.imageTagShareById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit the specified image tag for review and approval workflow
         * @summary Submit image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagSubmitById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageTag> {
            return localVarFp.imageTagSubmitById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Unpublish the specified image tag, removing it from public visibility while preserving the content
         * @summary Unpublish image tag
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageTagUnpublishById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ImageTag> {
            return localVarFp.imageTagUnpublishById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Unpublish the specified image document, removing it from public visibility while preserving the content
         * @summary Unpublish image document
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUnpublishById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Image> {
            return localVarFp.imageUnpublishById(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaApi - object-oriented interface
 * @export
 * @class MediaApi
 * @extends {BaseAPI}
 */
export class MediaApi extends BaseAPI {
    /**
     * Archive multiple files, making them inactive while preserving their data
     * @summary Archive files
     * @param {BulkOperationRequest} bulkOperationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileArchive(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileArchive(bulkOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently delete a specific file by ID (requires appropriate permissions)
     * @summary Delete file
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {FileDeleteByIdAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileDeleteById(id: string, aposMode?: FileDeleteByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileDeleteById(id, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Dismiss a pending submission for the specified file, removing it from the review queue
     * @summary Dismiss file submission
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileDismissSubmissionById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileDismissSubmissionById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a paginated list of files from the media library
     * @summary List files
     * @param {number} [page] Page number for pagination (1-based)
     * @param {number} [perPage] Number of items per page
     * @param {string} [search] Search term for filtering results
     * @param {FileGetAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileGet(page?: number, perPage?: number, search?: string, aposMode?: FileGetAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileGet(page, perPage, search, aposMode, aposLocale, renderAreas, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific file by ID from the media library
     * @summary Get file by ID
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {FileGetByIdAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileGetById(id: string, aposMode?: FileGetByIdAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileGetById(id, aposMode, aposLocale, renderAreas, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the specified file in a specific locale
     * @summary Get file locale
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {string} toLocale Target locale code (e.g., en:us:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileGetLocaleById(id: string, toLocale: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileGetLocaleById(id, toLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all available locales for the specified file
     * @summary Get file locales
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileGetLocalesById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileGetLocalesById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update localized versions of files for different languages/regions
     * @summary Localize files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileLocalize(options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileLocalize(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a localized version of the specified file for a specific language/region
     * @summary Localize file
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileLocalizeById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileLocalizeById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update a specific file by ID using PATCH semantics
     * @summary Update file
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {FilePatchByIdRequest} filePatchByIdRequest 
     * @param {FilePatchByIdAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public filePatchById(id: string, filePatchByIdRequest: FilePatchByIdRequest, aposMode?: FilePatchByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).filePatchById(id, filePatchByIdRequest, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new file document (requires prior attachment upload)
     * @summary Create file
     * @param {FilePostRequest} filePostRequest 
     * @param {FilePostAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public filePost(filePostRequest: FilePostRequest, aposMode?: FilePostAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).filePost(filePostRequest, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Bulk publish multiple files, making them live and visible to end users
     * @summary Publish files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public filePublish(options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).filePublish(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Publish the specified file, making it live and visible to end users
     * @summary Publish file
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public filePublishById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).filePublishById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completely replace a specific file by ID using PUT semantics
     * @summary Replace file
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {FilePostRequest} filePostRequest 
     * @param {FilePutByIdAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public filePutById(id: string, filePostRequest: FilePostRequest, aposMode?: FilePutByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).filePutById(id, filePostRequest, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore previously archived files, making them active again
     * @summary Restore files
     * @param {BulkOperationRequest} bulkOperationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileRestore(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileRestore(bulkOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revert the draft version of the specified file back to its published state
     * @summary Revert file draft to published
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileRevertDraftToPublishedById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileRevertDraftToPublishedById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revert the published version of the specified file to its previous published state
     * @summary Revert file published to previous
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileRevertPublishedToPreviousById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileRevertPublishedToPreviousById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a sharing link or configure sharing permissions for the specified file
     * @summary Share file
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileShareById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileShareById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit the specified file for review and approval workflow
     * @summary Submit file
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileSubmitById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileSubmitById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Archive multiple file tags, making them inactive while preserving their data
     * @summary Archive file tags
     * @param {BulkOperationRequest} bulkOperationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileTagArchive(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileTagArchive(bulkOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently delete a specific file tag by ID (requires appropriate permissions)
     * @summary Delete file tag
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileTagDeleteById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileTagDeleteById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Dismiss a pending submission for the specified file tag, removing it from the review queue
     * @summary Dismiss file tag submission
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileTagDismissSubmissionById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileTagDismissSubmissionById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of file tags used for organizing and categorizing uploaded files
     * @summary List file tags
     * @param {FileTagGetAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileTagGet(aposMode?: FileTagGetAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileTagGet(aposMode, aposLocale, renderAreas, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific file tag by ID
     * @summary Get file tag
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {FileTagGetByIdAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileTagGetById(id: string, aposMode?: FileTagGetByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileTagGetById(id, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the specified file tag in a specific locale
     * @summary Get file tag locale
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {string} toLocale Target locale code (e.g., en:us:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileTagGetLocaleById(id: string, toLocale: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileTagGetLocaleById(id, toLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all available locales for the specified file tag
     * @summary Get file tag locales
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileTagGetLocalesById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileTagGetLocalesById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update localized versions of file tags for different languages/regions
     * @summary Localize file tags
     * @param {FileTagLocalizeRequest} fileTagLocalizeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileTagLocalize(fileTagLocalizeRequest: FileTagLocalizeRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileTagLocalize(fileTagLocalizeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a localized version of the specified file tag for a specific language/region
     * @summary Localize file tag
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {PageLocalizeByIdRequest} pageLocalizeByIdRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileTagLocalizeById(id: string, pageLocalizeByIdRequest: PageLocalizeByIdRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileTagLocalizeById(id, pageLocalizeByIdRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update a specific file tag by ID using PATCH semantics
     * @summary Update file tag
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {FileTagPatchByIdRequest} fileTagPatchByIdRequest 
     * @param {FileTagPatchByIdAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileTagPatchById(id: string, fileTagPatchByIdRequest: FileTagPatchByIdRequest, aposMode?: FileTagPatchByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileTagPatchById(id, fileTagPatchByIdRequest, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new file tag for organizing uploaded files (requires editor permissions or higher)
     * @summary Create file tag
     * @param {FileTagPostRequest} fileTagPostRequest 
     * @param {FileTagPostAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileTagPost(fileTagPostRequest: FileTagPostRequest, aposMode?: FileTagPostAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileTagPost(fileTagPostRequest, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Publish multiple file tags, making them live and visible to end users
     * @summary Publish file tags
     * @param {FileTagPublishRequest} fileTagPublishRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileTagPublish(fileTagPublishRequest: FileTagPublishRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileTagPublish(fileTagPublishRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Publish the specified file tag, making it live and visible to end users
     * @summary Publish file tag
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileTagPublishById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileTagPublishById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completely replace a specific file tag by ID using PUT semantics
     * @summary Replace file tag
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {FileTagPutByIdRequest} fileTagPutByIdRequest 
     * @param {FileTagPutByIdAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileTagPutById(id: string, fileTagPutByIdRequest: FileTagPutByIdRequest, aposMode?: FileTagPutByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileTagPutById(id, fileTagPutByIdRequest, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore previously archived file tags, making them active again
     * @summary Restore file tags
     * @param {BulkOperationRequest} bulkOperationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileTagRestore(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileTagRestore(bulkOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revert the draft version of the specified file tag back to its published state
     * @summary Revert file tag draft to published
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileTagRevertDraftToPublishedById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileTagRevertDraftToPublishedById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revert the published version of the specified file tag to its previous published state
     * @summary Revert file tag published to previous
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileTagRevertPublishedToPreviousById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileTagRevertPublishedToPreviousById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a sharing link or configure sharing permissions for the specified file tag
     * @summary Share file tag
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileTagShareById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileTagShareById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit the specified file tag for review and approval workflow
     * @summary Submit file tag
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileTagSubmitById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileTagSubmitById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unpublish the specified file tag, removing it from public visibility while preserving the content
     * @summary Unpublish file tag
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileTagUnpublishById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileTagUnpublishById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unpublish the specified file, removing it from public visibility while preserving the content
     * @summary Unpublish file
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public fileUnpublishById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).fileUnpublishById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Archive multiple images, making them inactive while preserving their data
     * @summary Archive images
     * @param {BulkOperationRequest} bulkOperationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageArchive(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageArchive(bulkOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Automatically crop uploaded images using intelligent cropping algorithms
     * @summary Auto-crop images
     * @param {ImageAutocropRequest} imageAutocropRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageAutocrop(imageAutocropRequest: ImageAutocropRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageAutocrop(imageAutocropRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently delete a specific image document by ID (requires appropriate permissions)
     * @summary Delete image document
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageDeleteById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageDeleteById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Dismiss a pending submission for the specified image document, removing it from the review queue
     * @summary Dismiss image submission
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageDismissSubmissionById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageDismissSubmissionById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve images from the media library.  Authentication is required for all requests other than GET requests  for images with defined publicApiProjection. 
     * @summary Get images
     * @param {number} [page] Page number for pagination (1-based)
     * @param {number} [perPage] Number of items per page
     * @param {string} [search] Search term for filtering results
     * @param {ImageGetAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageGet(page?: number, perPage?: number, search?: string, aposMode?: ImageGetAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageGet(page, perPage, search, aposMode, aposLocale, renderAreas, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific image by ID from the media library. Authentication is required for all requests other than GET requests  for images with defined publicApiProjection. 
     * @summary Get image document
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {ImageGetByIdAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageGetById(id: string, aposMode?: ImageGetByIdAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageGetById(id, aposMode, aposLocale, renderAreas, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the specified image document in a specific locale
     * @summary Get image document locale
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {string} toLocale Target locale code (e.g., en:us:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageGetLocaleById(id: string, toLocale: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageGetLocaleById(id, toLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all available locales for the specified image document
     * @summary Get image document locales
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageGetLocalesById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageGetLocalesById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the source URL for a specific image, with optional size and format parameters
     * @summary Get image source URL
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {ImageGetSrcByIdSizeEnum} [size] Image size variant
     * @param {ImageGetSrcByIdFormatEnum} [format] Image format
     * @param {number} [quality] Image quality (1-100)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageGetSrcById(id: string, size?: ImageGetSrcByIdSizeEnum, format?: ImageGetSrcByIdFormatEnum, quality?: number, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageGetSrcById(id, size, format, quality, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update localized versions of images for different languages/regions
     * @summary Localize images
     * @param {ImageLocalizeRequest} imageLocalizeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageLocalize(imageLocalizeRequest: ImageLocalizeRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageLocalize(imageLocalizeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a localized version of the specified image document for a specific language/region
     * @summary Localize image document
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {PageLocalizeByIdRequest} pageLocalizeByIdRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageLocalizeById(id: string, pageLocalizeByIdRequest: PageLocalizeByIdRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageLocalizeById(id, pageLocalizeByIdRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update a specific image document by ID using PATCH semantics
     * @summary Update image document
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {ImagePatchByIdRequest} imagePatchByIdRequest 
     * @param {ImagePatchByIdAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imagePatchById(id: string, imagePatchByIdRequest: ImagePatchByIdRequest, aposMode?: ImagePatchByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imagePatchById(id, imagePatchByIdRequest, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new image document (requires prior attachment upload)
     * @summary Create image
     * @param {ImagePostRequest} imagePostRequest 
     * @param {ImagePostAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imagePost(imagePostRequest: ImagePostRequest, aposMode?: ImagePostAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imagePost(imagePostRequest, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Bulk publish multiple images, making them live and visible to end users
     * @summary Publish images
     * @param {ImagePublishRequest} imagePublishRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imagePublish(imagePublishRequest: ImagePublishRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imagePublish(imagePublishRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Publish the specified image document, making it live and visible to end users
     * @summary Publish image document
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imagePublishById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imagePublishById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completely replace an image document by ID using PUT semantics
     * @summary Replace image document
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {ImagePostRequest} imagePostRequest 
     * @param {ImagePutByIdAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imagePutById(id: string, imagePostRequest: ImagePostRequest, aposMode?: ImagePutByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imagePutById(id, imagePostRequest, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore previously archived images, making them active again
     * @summary Restore images
     * @param {BulkOperationRequest} bulkOperationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageRestore(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageRestore(bulkOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revert the draft version of the specified image document back to its published state
     * @summary Revert image draft to published
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageRevertDraftToPublishedById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageRevertDraftToPublishedById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revert the published version of the specified image document to its previous published state
     * @summary Revert image published to previous
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageRevertPublishedToPreviousById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageRevertPublishedToPreviousById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a sharing link or configure sharing permissions for the specified image document
     * @summary Share image document
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageShareById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageShareById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit the specified image document for review and approval workflow
     * @summary Submit image document
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageSubmitById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageSubmitById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add tags to multiple images for better organization and searchability
     * @summary Tag images
     * @param {ImageTagRequest} imageTagRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageTag(imageTagRequest: ImageTagRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageTag(imageTagRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Archive multiple image tags, making them inactive while preserving their data
     * @summary Archive image tags
     * @param {BulkOperationRequest} bulkOperationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageTagArchive(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageTagArchive(bulkOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently delete a specific image tag by ID (requires appropriate permissions)
     * @summary Delete image tag
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageTagDeleteById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageTagDeleteById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Dismiss a pending submission for the specified image tag, removing it from the review queue
     * @summary Dismiss image tag submission
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageTagDismissSubmissionById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageTagDismissSubmissionById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve image tags for organizing images
     * @summary Get image tags
     * @param {number} [page] Page number for pagination (1-based)
     * @param {number} [perPage] Number of items per page
     * @param {string} [search] Search term for filtering results
     * @param {ImageTagGetAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageTagGet(page?: number, perPage?: number, search?: string, aposMode?: ImageTagGetAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageTagGet(page, perPage, search, aposMode, aposLocale, renderAreas, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific image tag by ID
     * @summary Get image tag
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {ImageTagGetByIdAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageTagGetById(id: string, aposMode?: ImageTagGetByIdAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageTagGetById(id, aposMode, aposLocale, renderAreas, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the specified image tag in a specific locale
     * @summary Get image tag locale
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {string} toLocale Target locale code (e.g., en:us:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageTagGetLocaleById(id: string, toLocale: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageTagGetLocaleById(id, toLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all available locales for the specified image tag
     * @summary Get image tag locales
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageTagGetLocalesById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageTagGetLocalesById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update localized versions of image tags for different languages/regions
     * @summary Localize image tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageTagLocalize(options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageTagLocalize(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a localized version of the specified image tag for a specific language/region
     * @summary Localize image tag
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageTagLocalizeById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageTagLocalizeById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update a specific image tag by ID using PATCH semantics
     * @summary Update image tag
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {ImageTagPatchByIdRequest} imageTagPatchByIdRequest 
     * @param {ImageTagPatchByIdAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageTagPatchById(id: string, imageTagPatchByIdRequest: ImageTagPatchByIdRequest, aposMode?: ImageTagPatchByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageTagPatchById(id, imageTagPatchByIdRequest, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new image tag for organizing images
     * @summary Create image tag
     * @param {ImageTagPostRequest} imageTagPostRequest 
     * @param {ImageTagPostAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageTagPost(imageTagPostRequest: ImageTagPostRequest, aposMode?: ImageTagPostAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageTagPost(imageTagPostRequest, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Publish multiple image tags, making them live and visible to end users
     * @summary Publish image tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageTagPublish(options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageTagPublish(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Publish the specified image tag, making it live and visible to end users
     * @summary Publish image tag
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageTagPublishById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageTagPublishById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completely replace a specific image tag by ID using PUT semantics
     * @summary Replace image tag
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {ImageTagPostRequest} imageTagPostRequest 
     * @param {ImageTagPutByIdAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageTagPutById(id: string, imageTagPostRequest: ImageTagPostRequest, aposMode?: ImageTagPutByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageTagPutById(id, imageTagPostRequest, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore previously archived image tags, making them active again
     * @summary Restore image tags
     * @param {BulkOperationRequest} bulkOperationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageTagRestore(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageTagRestore(bulkOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revert the draft version of the specified image tag back to its published state
     * @summary Revert draft to published
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageTagRevertDraftToPublishedById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageTagRevertDraftToPublishedById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revert the published version of the specified image tag to its previous published state
     * @summary Revert published to previous
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageTagRevertPublishedToPreviousById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageTagRevertPublishedToPreviousById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a sharing link or configure sharing permissions for the specified image tag
     * @summary Share image tag
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageTagShareById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageTagShareById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit the specified image tag for review and approval workflow
     * @summary Submit image tag
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageTagSubmitById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageTagSubmitById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unpublish the specified image tag, removing it from public visibility while preserving the content
     * @summary Unpublish image tag
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageTagUnpublishById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageTagUnpublishById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unpublish the specified image document, removing it from public visibility while preserving the content
     * @summary Unpublish image document
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public imageUnpublishById(id: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).imageUnpublishById(id, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FileDeleteByIdAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type FileDeleteByIdAposModeEnum = typeof FileDeleteByIdAposModeEnum[keyof typeof FileDeleteByIdAposModeEnum];
/**
 * @export
 */
export const FileGetAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type FileGetAposModeEnum = typeof FileGetAposModeEnum[keyof typeof FileGetAposModeEnum];
/**
 * @export
 */
export const FileGetByIdAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type FileGetByIdAposModeEnum = typeof FileGetByIdAposModeEnum[keyof typeof FileGetByIdAposModeEnum];
/**
 * @export
 */
export const FilePatchByIdAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type FilePatchByIdAposModeEnum = typeof FilePatchByIdAposModeEnum[keyof typeof FilePatchByIdAposModeEnum];
/**
 * @export
 */
export const FilePostAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type FilePostAposModeEnum = typeof FilePostAposModeEnum[keyof typeof FilePostAposModeEnum];
/**
 * @export
 */
export const FilePutByIdAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type FilePutByIdAposModeEnum = typeof FilePutByIdAposModeEnum[keyof typeof FilePutByIdAposModeEnum];
/**
 * @export
 */
export const FileTagGetAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type FileTagGetAposModeEnum = typeof FileTagGetAposModeEnum[keyof typeof FileTagGetAposModeEnum];
/**
 * @export
 */
export const FileTagGetByIdAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type FileTagGetByIdAposModeEnum = typeof FileTagGetByIdAposModeEnum[keyof typeof FileTagGetByIdAposModeEnum];
/**
 * @export
 */
export const FileTagPatchByIdAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type FileTagPatchByIdAposModeEnum = typeof FileTagPatchByIdAposModeEnum[keyof typeof FileTagPatchByIdAposModeEnum];
/**
 * @export
 */
export const FileTagPostAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type FileTagPostAposModeEnum = typeof FileTagPostAposModeEnum[keyof typeof FileTagPostAposModeEnum];
/**
 * @export
 */
export const FileTagPutByIdAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type FileTagPutByIdAposModeEnum = typeof FileTagPutByIdAposModeEnum[keyof typeof FileTagPutByIdAposModeEnum];
/**
 * @export
 */
export const ImageGetAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type ImageGetAposModeEnum = typeof ImageGetAposModeEnum[keyof typeof ImageGetAposModeEnum];
/**
 * @export
 */
export const ImageGetByIdAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type ImageGetByIdAposModeEnum = typeof ImageGetByIdAposModeEnum[keyof typeof ImageGetByIdAposModeEnum];
/**
 * @export
 */
export const ImageGetSrcByIdSizeEnum = {
    Thumbnail: 'thumbnail',
    Small: 'small',
    Medium: 'medium',
    Large: 'large',
    Original: 'original'
} as const;
export type ImageGetSrcByIdSizeEnum = typeof ImageGetSrcByIdSizeEnum[keyof typeof ImageGetSrcByIdSizeEnum];
/**
 * @export
 */
export const ImageGetSrcByIdFormatEnum = {
    Jpg: 'jpg',
    Jpeg: 'jpeg',
    Png: 'png',
    Webp: 'webp',
    Avif: 'avif'
} as const;
export type ImageGetSrcByIdFormatEnum = typeof ImageGetSrcByIdFormatEnum[keyof typeof ImageGetSrcByIdFormatEnum];
/**
 * @export
 */
export const ImagePatchByIdAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type ImagePatchByIdAposModeEnum = typeof ImagePatchByIdAposModeEnum[keyof typeof ImagePatchByIdAposModeEnum];
/**
 * @export
 */
export const ImagePostAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type ImagePostAposModeEnum = typeof ImagePostAposModeEnum[keyof typeof ImagePostAposModeEnum];
/**
 * @export
 */
export const ImagePutByIdAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type ImagePutByIdAposModeEnum = typeof ImagePutByIdAposModeEnum[keyof typeof ImagePutByIdAposModeEnum];
/**
 * @export
 */
export const ImageTagGetAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type ImageTagGetAposModeEnum = typeof ImageTagGetAposModeEnum[keyof typeof ImageTagGetAposModeEnum];
/**
 * @export
 */
export const ImageTagGetByIdAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type ImageTagGetByIdAposModeEnum = typeof ImageTagGetByIdAposModeEnum[keyof typeof ImageTagGetByIdAposModeEnum];
/**
 * @export
 */
export const ImageTagPatchByIdAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type ImageTagPatchByIdAposModeEnum = typeof ImageTagPatchByIdAposModeEnum[keyof typeof ImageTagPatchByIdAposModeEnum];
/**
 * @export
 */
export const ImageTagPostAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type ImageTagPostAposModeEnum = typeof ImageTagPostAposModeEnum[keyof typeof ImageTagPostAposModeEnum];
/**
 * @export
 */
export const ImageTagPutByIdAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type ImageTagPutByIdAposModeEnum = typeof ImageTagPutByIdAposModeEnum[keyof typeof ImageTagPutByIdAposModeEnum];


/**
 * PagesApi - axios parameter creator
 * @export
 */
export const PagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Archive pages in bulk, making them inactive while preserving their data in the page tree
         * @summary Archive pages
         * @param {PageArchiveRequest} pageArchiveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageArchive: async (pageArchiveRequest: PageArchiveRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageArchiveRequest' is not null or undefined
            assertParamExists('pageArchive', 'pageArchiveRequest', pageArchiveRequest)
            const localVarPath = `/@apostrophecms/page/archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pageArchiveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * âš ï¸ **Permanently delete a page document.** This cannot be undone.  **Important**: This endpoint should be used to delete the draft version of a page. If the page has been published, you should unpublish it first using the unpublish endpoint to ensure complete removal.  **Recommended deletion workflow**: 1. Unpublish the page (removes published version) 2. Delete the page (removes draft version)  **Restrictions:** - Cannot delete home page - Cannot delete pages with children (delete children first) - Cannot delete draft if published version exists âš ï¸ **Permanently delete a page document.** This cannot be undone.  **Use with caution!** 
         * @summary Delete page
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {PageDeleteByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageDeleteById: async (id: string, aposMode?: PageDeleteByIdAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pageDeleteById', 'id', id)
            const localVarPath = `/@apostrophecms/page/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Dismiss a pending submission for the specified page, removing it from the review queue
         * @summary Dismiss page submission
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageDismissSubmissionById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pageDismissSubmissionById', 'id', id)
            const localVarPath = `/@apostrophecms/page/{_id}/dismiss-submission`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ðŸš€ **Essential for headless sites!** Fetch your site\'s complete page structure and content.  **Perfect for:** - Building navigation menus - Getting all pages for static site generation - Fetching content for SPA routing - Understanding your site structure  Returns the complete page hierarchy starting from the home page. Use `flat=1` to get pages in a flat array instead of nested structure. 
         * @summary Get page tree
         * @param {PageGetAllEnum} [all] Include entire page tree regardless of depth (use with caution for large sites)
         * @param {PageGetFlatEnum} [flat] ðŸ’¡ Return pages in flat array instead of tree structure - easier for some use cases
         * @param {PageGetChildrenEnum} [children] Include children array in response (set to \&#39;false\&#39; to exclude)
         * @param {PageGetAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageGet: async (all?: PageGetAllEnum, flat?: PageGetFlatEnum, children?: PageGetChildrenEnum, aposMode?: PageGetAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (all !== undefined) {
                localVarQueryParameter['all'] = all;
            }

            if (flat !== undefined) {
                localVarQueryParameter['flat'] = flat;
            }

            if (children !== undefined) {
                localVarQueryParameter['children'] = children;
            }

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a single page document by ID for detailed content access.  **Perfect for:** - Getting page content for rendering - Fetching specific page data - Building page detail views  The ID can include mode and locale (e.g., `id:en:published`) or use query parameters to specify them. 
         * @summary Get page by ID
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {PageGetByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageGetById: async (id: string, aposMode?: PageGetByIdAposModeEnum, aposLocale?: string, renderAreas?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pageGetById', 'id', id)
            const localVarPath = `/@apostrophecms/page/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }

            if (renderAreas !== undefined) {
                localVarQueryParameter['render-areas'] = renderAreas;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the specified page in a specific locale
         * @summary Get page in specific locale
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} toLocale Target locale code (e.g., en:us:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageGetLocaleById: async (id: string, toLocale: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pageGetLocaleById', 'id', id)
            // verify required parameter 'toLocale' is not null or undefined
            assertParamExists('pageGetLocaleById', 'toLocale', toLocale)
            const localVarPath = `/@apostrophecms/page/{_id}/locale/{toLocale}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"toLocale"}}`, encodeURIComponent(String(toLocale)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all available locales for the specified page
         * @summary Get page locales
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageGetLocalesById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pageGetLocalesById', 'id', id)
            const localVarPath = `/@apostrophecms/page/{_id}/locales`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update localized versions of pages in bulk for different languages/regions
         * @summary Localize pages
         * @param {PageLocalizeRequest} pageLocalizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageLocalize: async (pageLocalizeRequest: PageLocalizeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageLocalizeRequest' is not null or undefined
            assertParamExists('pageLocalize', 'pageLocalizeRequest', pageLocalizeRequest)
            const localVarPath = `/@apostrophecms/page/localize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pageLocalizeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a localized version of the specified page for a specific language/region
         * @summary Localize page
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {PageLocalizeByIdRequest} pageLocalizeByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageLocalizeById: async (id: string, pageLocalizeByIdRequest: PageLocalizeByIdRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pageLocalizeById', 'id', id)
            // verify required parameter 'pageLocalizeByIdRequest' is not null or undefined
            assertParamExists('pageLocalizeById', 'pageLocalizeByIdRequest', pageLocalizeByIdRequest)
            const localVarPath = `/@apostrophecms/page/{_id}/localize`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pageLocalizeByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially update a page document.  **Perfect for:** - Updating page titles or content - Moving pages within the tree - Making incremental changes  Can use MongoDB-style operators and dot notation for nested properties. Include `_targetId` and `_position` to move the page within the tree. 
         * @summary Update page
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {PagePatchByIdRequest} pagePatchByIdRequest 
         * @param {PagePatchByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagePatchById: async (id: string, pagePatchByIdRequest: PagePatchByIdRequest, aposMode?: PagePatchByIdAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pagePatchById', 'id', id)
            // verify required parameter 'pagePatchByIdRequest' is not null or undefined
            assertParamExists('pagePatchById', 'pagePatchByIdRequest', pagePatchByIdRequest)
            const localVarPath = `/@apostrophecms/page/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pagePatchByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Insert a new page at the specified position in the page tree.  **Perfect for:** - Programmatically creating pages - Building page management interfaces - Migrating content from other systems  Requires `_targetId` and `_position` to determine placement in the page tree. 
         * @summary Create new page
         * @param {PageCreateRequest} pageCreateRequest 
         * @param {PagePostAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagePost: async (pageCreateRequest: PageCreateRequest, aposMode?: PagePostAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageCreateRequest' is not null or undefined
            assertParamExists('pagePost', 'pageCreateRequest', pageCreateRequest)
            const localVarPath = `/@apostrophecms/page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pageCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publish pages in bulk, making them live and visible to end users in the page tree
         * @summary Publish pages
         * @param {PagePublishRequest} pagePublishRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagePublish: async (pagePublishRequest: PagePublishRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pagePublishRequest' is not null or undefined
            assertParamExists('pagePublish', 'pagePublishRequest', pagePublishRequest)
            const localVarPath = `/@apostrophecms/page/publish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pagePublishRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Advanced Feature**: Publish a draft page to make it live.  Moves a page from draft mode to published mode, making it visible to public users. Essential for content workflows where editors create drafts before publishing.  **Use cases:** - Content approval workflows - Scheduled publishing systems - Editorial review processes  The `_id` can be from either the draft or published version,  or you can use the `aposDocId` to reference the document. 
         * @summary Publish page
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagePublishById: async (id: string, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pagePublishById', 'id', id)
            const localVarPath = `/@apostrophecms/page/{_id}/publish`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completely replace a page document.  **Use cases:** - Complete page updates - Moving pages in the tree structure - Replacing page content entirely  Requires `_targetId` and `_position` for page tree positioning. 
         * @summary Replace page
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {PagePutByIdRequest} pagePutByIdRequest 
         * @param {PagePutByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagePutById: async (id: string, pagePutByIdRequest: PagePutByIdRequest, aposMode?: PagePutByIdAposModeEnum, aposLocale?: string, renderAreas?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pagePutById', 'id', id)
            // verify required parameter 'pagePutByIdRequest' is not null or undefined
            assertParamExists('pagePutById', 'pagePutByIdRequest', pagePutByIdRequest)
            const localVarPath = `/@apostrophecms/page/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }

            if (renderAreas !== undefined) {
                localVarQueryParameter['render-areas'] = renderAreas;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pagePutByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore previously archived pages in bulk, making them active again in the page tree
         * @summary Restore pages
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageRestore: async (bulkOperationRequest: BulkOperationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkOperationRequest' is not null or undefined
            assertParamExists('pageRestore', 'bulkOperationRequest', bulkOperationRequest)
            const localVarPath = `/@apostrophecms/page/restore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkOperationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revert the draft version of the specified page back to its published state
         * @summary Revert draft to published
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageRevertDraftToPublishedById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pageRevertDraftToPublishedById', 'id', id)
            const localVarPath = `/@apostrophecms/page/{_id}/revert-draft-to-published`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revert the published version of the specified page to its previous published state
         * @summary Revert published to previous
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageRevertPublishedToPreviousById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pageRevertPublishedToPreviousById', 'id', id)
            const localVarPath = `/@apostrophecms/page/{_id}/revert-published-to-previous`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a sharing link or configure sharing permissions for the specified page
         * @summary Share page
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageShareById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pageShareById', 'id', id)
            const localVarPath = `/@apostrophecms/page/{_id}/share`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit the specified page for review and approval workflow
         * @summary Submit page
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageSubmitById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pageSubmitById', 'id', id)
            const localVarPath = `/@apostrophecms/page/{_id}/submit`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unpublish the specified page, removing it from public visibility while preserving the content
         * @summary Unpublish page
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {PageUnpublishByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageUnpublishById: async (id: string, aposMode?: PageUnpublishByIdAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pageUnpublishById', 'id', id)
            const localVarPath = `/@apostrophecms/page/{_id}/unpublish`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PagesApi - functional programming interface
 * @export
 */
export const PagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Archive pages in bulk, making them inactive while preserving their data in the page tree
         * @summary Archive pages
         * @param {PageArchiveRequest} pageArchiveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageArchive(pageArchiveRequest: PageArchiveRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageArchive200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageArchive(pageArchiveRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pageArchive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * âš ï¸ **Permanently delete a page document.** This cannot be undone.  **Important**: This endpoint should be used to delete the draft version of a page. If the page has been published, you should unpublish it first using the unpublish endpoint to ensure complete removal.  **Recommended deletion workflow**: 1. Unpublish the page (removes published version) 2. Delete the page (removes draft version)  **Restrictions:** - Cannot delete home page - Cannot delete pages with children (delete children first) - Cannot delete draft if published version exists âš ï¸ **Permanently delete a page document.** This cannot be undone.  **Use with caution!** 
         * @summary Delete page
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {PageDeleteByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageDeleteById(id: string, aposMode?: PageDeleteByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageDeleteById(id, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pageDeleteById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Dismiss a pending submission for the specified page, removing it from the review queue
         * @summary Dismiss page submission
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageDismissSubmissionById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageDismissSubmissionById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pageDismissSubmissionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ðŸš€ **Essential for headless sites!** Fetch your site\'s complete page structure and content.  **Perfect for:** - Building navigation menus - Getting all pages for static site generation - Fetching content for SPA routing - Understanding your site structure  Returns the complete page hierarchy starting from the home page. Use `flat=1` to get pages in a flat array instead of nested structure. 
         * @summary Get page tree
         * @param {PageGetAllEnum} [all] Include entire page tree regardless of depth (use with caution for large sites)
         * @param {PageGetFlatEnum} [flat] ðŸ’¡ Return pages in flat array instead of tree structure - easier for some use cases
         * @param {PageGetChildrenEnum} [children] Include children array in response (set to \&#39;false\&#39; to exclude)
         * @param {PageGetAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageGet(all?: PageGetAllEnum, flat?: PageGetFlatEnum, children?: PageGetChildrenEnum, aposMode?: PageGetAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageGet(all, flat, children, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pageGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch a single page document by ID for detailed content access.  **Perfect for:** - Getting page content for rendering - Fetching specific page data - Building page detail views  The ID can include mode and locale (e.g., `id:en:published`) or use query parameters to specify them. 
         * @summary Get page by ID
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {PageGetByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageGetById(id: string, aposMode?: PageGetByIdAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageGetById(id, aposMode, aposLocale, renderAreas, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pageGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the specified page in a specific locale
         * @summary Get page in specific locale
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} toLocale Target locale code (e.g., en:us:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageGetLocaleById(id: string, toLocale: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageGetLocaleById(id, toLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pageGetLocaleById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all available locales for the specified page
         * @summary Get page locales
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageGetLocalesById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageGetLocalesById200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageGetLocalesById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pageGetLocalesById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or update localized versions of pages in bulk for different languages/regions
         * @summary Localize pages
         * @param {PageLocalizeRequest} pageLocalizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageLocalize(pageLocalizeRequest: PageLocalizeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Page>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageLocalize(pageLocalizeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pageLocalize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a localized version of the specified page for a specific language/region
         * @summary Localize page
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {PageLocalizeByIdRequest} pageLocalizeByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageLocalizeById(id: string, pageLocalizeByIdRequest: PageLocalizeByIdRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageLocalizeById(id, pageLocalizeByIdRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pageLocalizeById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update a page document.  **Perfect for:** - Updating page titles or content - Moving pages within the tree - Making incremental changes  Can use MongoDB-style operators and dot notation for nested properties. Include `_targetId` and `_position` to move the page within the tree. 
         * @summary Update page
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {PagePatchByIdRequest} pagePatchByIdRequest 
         * @param {PagePatchByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagePatchById(id: string, pagePatchByIdRequest: PagePatchByIdRequest, aposMode?: PagePatchByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagePatchById(id, pagePatchByIdRequest, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pagePatchById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Insert a new page at the specified position in the page tree.  **Perfect for:** - Programmatically creating pages - Building page management interfaces - Migrating content from other systems  Requires `_targetId` and `_position` to determine placement in the page tree. 
         * @summary Create new page
         * @param {PageCreateRequest} pageCreateRequest 
         * @param {PagePostAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagePost(pageCreateRequest: PageCreateRequest, aposMode?: PagePostAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagePost(pageCreateRequest, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pagePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Publish pages in bulk, making them live and visible to end users in the page tree
         * @summary Publish pages
         * @param {PagePublishRequest} pagePublishRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagePublish(pagePublishRequest: PagePublishRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Page>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagePublish(pagePublishRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pagePublish']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * **Advanced Feature**: Publish a draft page to make it live.  Moves a page from draft mode to published mode, making it visible to public users. Essential for content workflows where editors create drafts before publishing.  **Use cases:** - Content approval workflows - Scheduled publishing systems - Editorial review processes  The `_id` can be from either the draft or published version,  or you can use the `aposDocId` to reference the document. 
         * @summary Publish page
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagePublishById(id: string, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagePublishById(id, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pagePublishById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Completely replace a page document.  **Use cases:** - Complete page updates - Moving pages in the tree structure - Replacing page content entirely  Requires `_targetId` and `_position` for page tree positioning. 
         * @summary Replace page
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {PagePutByIdRequest} pagePutByIdRequest 
         * @param {PagePutByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagePutById(id: string, pagePutByIdRequest: PagePutByIdRequest, aposMode?: PagePutByIdAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pagePutById(id, pagePutByIdRequest, aposMode, aposLocale, renderAreas, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pagePutById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restore previously archived pages in bulk, making them active again in the page tree
         * @summary Restore pages
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageRestore(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Page>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageRestore(bulkOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pageRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revert the draft version of the specified page back to its published state
         * @summary Revert draft to published
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageRevertDraftToPublishedById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageRevertDraftToPublishedById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pageRevertDraftToPublishedById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revert the published version of the specified page to its previous published state
         * @summary Revert published to previous
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageRevertPublishedToPreviousById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageRevertPublishedToPreviousById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pageRevertPublishedToPreviousById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate a sharing link or configure sharing permissions for the specified page
         * @summary Share page
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageShareById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageShareById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pageShareById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit the specified page for review and approval workflow
         * @summary Submit page
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageSubmitById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageSubmitById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pageSubmitById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unpublish the specified page, removing it from public visibility while preserving the content
         * @summary Unpublish page
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {PageUnpublishByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageUnpublishById(id: string, aposMode?: PageUnpublishByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageUnpublishById(id, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PagesApi.pageUnpublishById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PagesApi - factory interface
 * @export
 */
export const PagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PagesApiFp(configuration)
    return {
        /**
         * Archive pages in bulk, making them inactive while preserving their data in the page tree
         * @summary Archive pages
         * @param {PageArchiveRequest} pageArchiveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageArchive(pageArchiveRequest: PageArchiveRequest, options?: RawAxiosRequestConfig): AxiosPromise<PageArchive200Response> {
            return localVarFp.pageArchive(pageArchiveRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * âš ï¸ **Permanently delete a page document.** This cannot be undone.  **Important**: This endpoint should be used to delete the draft version of a page. If the page has been published, you should unpublish it first using the unpublish endpoint to ensure complete removal.  **Recommended deletion workflow**: 1. Unpublish the page (removes published version) 2. Delete the page (removes draft version)  **Restrictions:** - Cannot delete home page - Cannot delete pages with children (delete children first) - Cannot delete draft if published version exists âš ï¸ **Permanently delete a page document.** This cannot be undone.  **Use with caution!** 
         * @summary Delete page
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {PageDeleteByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageDeleteById(id: string, aposMode?: PageDeleteByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<Page> {
            return localVarFp.pageDeleteById(id, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Dismiss a pending submission for the specified page, removing it from the review queue
         * @summary Dismiss page submission
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageDismissSubmissionById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Page> {
            return localVarFp.pageDismissSubmissionById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * ðŸš€ **Essential for headless sites!** Fetch your site\'s complete page structure and content.  **Perfect for:** - Building navigation menus - Getting all pages for static site generation - Fetching content for SPA routing - Understanding your site structure  Returns the complete page hierarchy starting from the home page. Use `flat=1` to get pages in a flat array instead of nested structure. 
         * @summary Get page tree
         * @param {PageGetAllEnum} [all] Include entire page tree regardless of depth (use with caution for large sites)
         * @param {PageGetFlatEnum} [flat] ðŸ’¡ Return pages in flat array instead of tree structure - easier for some use cases
         * @param {PageGetChildrenEnum} [children] Include children array in response (set to \&#39;false\&#39; to exclude)
         * @param {PageGetAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageGet(all?: PageGetAllEnum, flat?: PageGetFlatEnum, children?: PageGetChildrenEnum, aposMode?: PageGetAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<PageGet200Response> {
            return localVarFp.pageGet(all, flat, children, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a single page document by ID for detailed content access.  **Perfect for:** - Getting page content for rendering - Fetching specific page data - Building page detail views  The ID can include mode and locale (e.g., `id:en:published`) or use query parameters to specify them. 
         * @summary Get page by ID
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {PageGetByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageGetById(id: string, aposMode?: PageGetByIdAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Page> {
            return localVarFp.pageGetById(id, aposMode, aposLocale, renderAreas, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the specified page in a specific locale
         * @summary Get page in specific locale
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} toLocale Target locale code (e.g., en:us:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageGetLocaleById(id: string, toLocale: string, options?: RawAxiosRequestConfig): AxiosPromise<Page> {
            return localVarFp.pageGetLocaleById(id, toLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all available locales for the specified page
         * @summary Get page locales
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageGetLocalesById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<PageGetLocalesById200Response> {
            return localVarFp.pageGetLocalesById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update localized versions of pages in bulk for different languages/regions
         * @summary Localize pages
         * @param {PageLocalizeRequest} pageLocalizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageLocalize(pageLocalizeRequest: PageLocalizeRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Page>> {
            return localVarFp.pageLocalize(pageLocalizeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a localized version of the specified page for a specific language/region
         * @summary Localize page
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {PageLocalizeByIdRequest} pageLocalizeByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageLocalizeById(id: string, pageLocalizeByIdRequest: PageLocalizeByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<Page> {
            return localVarFp.pageLocalizeById(id, pageLocalizeByIdRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Partially update a page document.  **Perfect for:** - Updating page titles or content - Moving pages within the tree - Making incremental changes  Can use MongoDB-style operators and dot notation for nested properties. Include `_targetId` and `_position` to move the page within the tree. 
         * @summary Update page
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {PagePatchByIdRequest} pagePatchByIdRequest 
         * @param {PagePatchByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagePatchById(id: string, pagePatchByIdRequest: PagePatchByIdRequest, aposMode?: PagePatchByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<Page> {
            return localVarFp.pagePatchById(id, pagePatchByIdRequest, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Insert a new page at the specified position in the page tree.  **Perfect for:** - Programmatically creating pages - Building page management interfaces - Migrating content from other systems  Requires `_targetId` and `_position` to determine placement in the page tree. 
         * @summary Create new page
         * @param {PageCreateRequest} pageCreateRequest 
         * @param {PagePostAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagePost(pageCreateRequest: PageCreateRequest, aposMode?: PagePostAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<Page> {
            return localVarFp.pagePost(pageCreateRequest, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Publish pages in bulk, making them live and visible to end users in the page tree
         * @summary Publish pages
         * @param {PagePublishRequest} pagePublishRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagePublish(pagePublishRequest: PagePublishRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Page>> {
            return localVarFp.pagePublish(pagePublishRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * **Advanced Feature**: Publish a draft page to make it live.  Moves a page from draft mode to published mode, making it visible to public users. Essential for content workflows where editors create drafts before publishing.  **Use cases:** - Content approval workflows - Scheduled publishing systems - Editorial review processes  The `_id` can be from either the draft or published version,  or you can use the `aposDocId` to reference the document. 
         * @summary Publish page
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagePublishById(id: string, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<Page> {
            return localVarFp.pagePublishById(id, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Completely replace a page document.  **Use cases:** - Complete page updates - Moving pages in the tree structure - Replacing page content entirely  Requires `_targetId` and `_position` for page tree positioning. 
         * @summary Replace page
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {PagePutByIdRequest} pagePutByIdRequest 
         * @param {PagePutByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagePutById(id: string, pagePutByIdRequest: PagePutByIdRequest, aposMode?: PagePutByIdAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Page> {
            return localVarFp.pagePutById(id, pagePutByIdRequest, aposMode, aposLocale, renderAreas, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore previously archived pages in bulk, making them active again in the page tree
         * @summary Restore pages
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageRestore(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Page>> {
            return localVarFp.pageRestore(bulkOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Revert the draft version of the specified page back to its published state
         * @summary Revert draft to published
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageRevertDraftToPublishedById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Page> {
            return localVarFp.pageRevertDraftToPublishedById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Revert the published version of the specified page to its previous published state
         * @summary Revert published to previous
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageRevertPublishedToPreviousById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Page> {
            return localVarFp.pageRevertPublishedToPreviousById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a sharing link or configure sharing permissions for the specified page
         * @summary Share page
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageShareById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Page> {
            return localVarFp.pageShareById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit the specified page for review and approval workflow
         * @summary Submit page
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageSubmitById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Page> {
            return localVarFp.pageSubmitById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Unpublish the specified page, removing it from public visibility while preserving the content
         * @summary Unpublish page
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {PageUnpublishByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageUnpublishById(id: string, aposMode?: PageUnpublishByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<Page> {
            return localVarFp.pageUnpublishById(id, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PagesApi - object-oriented interface
 * @export
 * @class PagesApi
 * @extends {BaseAPI}
 */
export class PagesApi extends BaseAPI {
    /**
     * Archive pages in bulk, making them inactive while preserving their data in the page tree
     * @summary Archive pages
     * @param {PageArchiveRequest} pageArchiveRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pageArchive(pageArchiveRequest: PageArchiveRequest, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pageArchive(pageArchiveRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * âš ï¸ **Permanently delete a page document.** This cannot be undone.  **Important**: This endpoint should be used to delete the draft version of a page. If the page has been published, you should unpublish it first using the unpublish endpoint to ensure complete removal.  **Recommended deletion workflow**: 1. Unpublish the page (removes published version) 2. Delete the page (removes draft version)  **Restrictions:** - Cannot delete home page - Cannot delete pages with children (delete children first) - Cannot delete draft if published version exists âš ï¸ **Permanently delete a page document.** This cannot be undone.  **Use with caution!** 
     * @summary Delete page
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {PageDeleteByIdAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pageDeleteById(id: string, aposMode?: PageDeleteByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pageDeleteById(id, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Dismiss a pending submission for the specified page, removing it from the review queue
     * @summary Dismiss page submission
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pageDismissSubmissionById(id: string, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pageDismissSubmissionById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ðŸš€ **Essential for headless sites!** Fetch your site\'s complete page structure and content.  **Perfect for:** - Building navigation menus - Getting all pages for static site generation - Fetching content for SPA routing - Understanding your site structure  Returns the complete page hierarchy starting from the home page. Use `flat=1` to get pages in a flat array instead of nested structure. 
     * @summary Get page tree
     * @param {PageGetAllEnum} [all] Include entire page tree regardless of depth (use with caution for large sites)
     * @param {PageGetFlatEnum} [flat] ðŸ’¡ Return pages in flat array instead of tree structure - easier for some use cases
     * @param {PageGetChildrenEnum} [children] Include children array in response (set to \&#39;false\&#39; to exclude)
     * @param {PageGetAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pageGet(all?: PageGetAllEnum, flat?: PageGetFlatEnum, children?: PageGetChildrenEnum, aposMode?: PageGetAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pageGet(all, flat, children, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a single page document by ID for detailed content access.  **Perfect for:** - Getting page content for rendering - Fetching specific page data - Building page detail views  The ID can include mode and locale (e.g., `id:en:published`) or use query parameters to specify them. 
     * @summary Get page by ID
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {PageGetByIdAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pageGetById(id: string, aposMode?: PageGetByIdAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pageGetById(id, aposMode, aposLocale, renderAreas, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the specified page in a specific locale
     * @summary Get page in specific locale
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {string} toLocale Target locale code (e.g., en:us:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pageGetLocaleById(id: string, toLocale: string, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pageGetLocaleById(id, toLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all available locales for the specified page
     * @summary Get page locales
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pageGetLocalesById(id: string, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pageGetLocalesById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update localized versions of pages in bulk for different languages/regions
     * @summary Localize pages
     * @param {PageLocalizeRequest} pageLocalizeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pageLocalize(pageLocalizeRequest: PageLocalizeRequest, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pageLocalize(pageLocalizeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a localized version of the specified page for a specific language/region
     * @summary Localize page
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {PageLocalizeByIdRequest} pageLocalizeByIdRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pageLocalizeById(id: string, pageLocalizeByIdRequest: PageLocalizeByIdRequest, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pageLocalizeById(id, pageLocalizeByIdRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update a page document.  **Perfect for:** - Updating page titles or content - Moving pages within the tree - Making incremental changes  Can use MongoDB-style operators and dot notation for nested properties. Include `_targetId` and `_position` to move the page within the tree. 
     * @summary Update page
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {PagePatchByIdRequest} pagePatchByIdRequest 
     * @param {PagePatchByIdAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pagePatchById(id: string, pagePatchByIdRequest: PagePatchByIdRequest, aposMode?: PagePatchByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pagePatchById(id, pagePatchByIdRequest, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Insert a new page at the specified position in the page tree.  **Perfect for:** - Programmatically creating pages - Building page management interfaces - Migrating content from other systems  Requires `_targetId` and `_position` to determine placement in the page tree. 
     * @summary Create new page
     * @param {PageCreateRequest} pageCreateRequest 
     * @param {PagePostAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pagePost(pageCreateRequest: PageCreateRequest, aposMode?: PagePostAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pagePost(pageCreateRequest, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Publish pages in bulk, making them live and visible to end users in the page tree
     * @summary Publish pages
     * @param {PagePublishRequest} pagePublishRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pagePublish(pagePublishRequest: PagePublishRequest, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pagePublish(pagePublishRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Advanced Feature**: Publish a draft page to make it live.  Moves a page from draft mode to published mode, making it visible to public users. Essential for content workflows where editors create drafts before publishing.  **Use cases:** - Content approval workflows - Scheduled publishing systems - Editorial review processes  The `_id` can be from either the draft or published version,  or you can use the `aposDocId` to reference the document. 
     * @summary Publish page
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pagePublishById(id: string, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pagePublishById(id, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completely replace a page document.  **Use cases:** - Complete page updates - Moving pages in the tree structure - Replacing page content entirely  Requires `_targetId` and `_position` for page tree positioning. 
     * @summary Replace page
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {PagePutByIdRequest} pagePutByIdRequest 
     * @param {PagePutByIdAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pagePutById(id: string, pagePutByIdRequest: PagePutByIdRequest, aposMode?: PagePutByIdAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pagePutById(id, pagePutByIdRequest, aposMode, aposLocale, renderAreas, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore previously archived pages in bulk, making them active again in the page tree
     * @summary Restore pages
     * @param {BulkOperationRequest} bulkOperationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pageRestore(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pageRestore(bulkOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revert the draft version of the specified page back to its published state
     * @summary Revert draft to published
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pageRevertDraftToPublishedById(id: string, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pageRevertDraftToPublishedById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revert the published version of the specified page to its previous published state
     * @summary Revert published to previous
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pageRevertPublishedToPreviousById(id: string, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pageRevertPublishedToPreviousById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a sharing link or configure sharing permissions for the specified page
     * @summary Share page
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pageShareById(id: string, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pageShareById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit the specified page for review and approval workflow
     * @summary Submit page
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pageSubmitById(id: string, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pageSubmitById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unpublish the specified page, removing it from public visibility while preserving the content
     * @summary Unpublish page
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {PageUnpublishByIdAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pageUnpublishById(id: string, aposMode?: PageUnpublishByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return PagesApiFp(this.configuration).pageUnpublishById(id, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const PageDeleteByIdAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type PageDeleteByIdAposModeEnum = typeof PageDeleteByIdAposModeEnum[keyof typeof PageDeleteByIdAposModeEnum];
/**
 * @export
 */
export const PageGetAllEnum = {
    _1: '1'
} as const;
export type PageGetAllEnum = typeof PageGetAllEnum[keyof typeof PageGetAllEnum];
/**
 * @export
 */
export const PageGetFlatEnum = {
    _1: '1'
} as const;
export type PageGetFlatEnum = typeof PageGetFlatEnum[keyof typeof PageGetFlatEnum];
/**
 * @export
 */
export const PageGetChildrenEnum = {
    False: 'false'
} as const;
export type PageGetChildrenEnum = typeof PageGetChildrenEnum[keyof typeof PageGetChildrenEnum];
/**
 * @export
 */
export const PageGetAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type PageGetAposModeEnum = typeof PageGetAposModeEnum[keyof typeof PageGetAposModeEnum];
/**
 * @export
 */
export const PageGetByIdAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type PageGetByIdAposModeEnum = typeof PageGetByIdAposModeEnum[keyof typeof PageGetByIdAposModeEnum];
/**
 * @export
 */
export const PagePatchByIdAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type PagePatchByIdAposModeEnum = typeof PagePatchByIdAposModeEnum[keyof typeof PagePatchByIdAposModeEnum];
/**
 * @export
 */
export const PagePostAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type PagePostAposModeEnum = typeof PagePostAposModeEnum[keyof typeof PagePostAposModeEnum];
/**
 * @export
 */
export const PagePutByIdAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type PagePutByIdAposModeEnum = typeof PagePutByIdAposModeEnum[keyof typeof PagePutByIdAposModeEnum];
/**
 * @export
 */
export const PageUnpublishByIdAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type PageUnpublishByIdAposModeEnum = typeof PageUnpublishByIdAposModeEnum[keyof typeof PageUnpublishByIdAposModeEnum];


/**
 * SubmittedDraftsApi - axios parameter creator
 * @export
 */
export const SubmittedDraftsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Archive multiple submitted drafts, removing them from active review queues while preserving data
         * @summary Archive submitted drafts
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftArchive: async (bulkOperationRequest: BulkOperationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkOperationRequest' is not null or undefined
            assertParamExists('submittedDraftArchive', 'bulkOperationRequest', bulkOperationRequest)
            const localVarPath = `/@apostrophecms/submitted-draft/archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkOperationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete a specific submitted draft by ID (requires appropriate permissions)
         * @summary Delete submitted draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftDeleteById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submittedDraftDeleteById', 'id', id)
            const localVarPath = `/@apostrophecms/submitted-draft/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Dismiss a pending submission for the specified draft, removing it from the review queue
         * @summary Dismiss submission
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftDismissSubmissionById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submittedDraftDismissSubmissionById', 'id', id)
            const localVarPath = `/@apostrophecms/submitted-draft/{_id}/dismiss-submission`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all submitted drafts in the review queue
         * @summary List submitted drafts
         * @param {SubmittedDraftGetAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftGet: async (aposMode?: SubmittedDraftGetAposModeEnum, aposLocale?: string, renderAreas?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/submitted-draft`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }

            if (renderAreas !== undefined) {
                localVarQueryParameter['render-areas'] = renderAreas;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific submitted draft by ID (requires appropriate permissions)
         * @summary Get submitted draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftGetById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submittedDraftGetById', 'id', id)
            const localVarPath = `/@apostrophecms/submitted-draft/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the specified submitted draft in a specific locale
         * @summary Get submitted draft locale
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} toLocale Target locale code (e.g., en:us:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftGetLocaleById: async (id: string, toLocale: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submittedDraftGetLocaleById', 'id', id)
            // verify required parameter 'toLocale' is not null or undefined
            assertParamExists('submittedDraftGetLocaleById', 'toLocale', toLocale)
            const localVarPath = `/@apostrophecms/submitted-draft/{_id}/locale/{toLocale}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"toLocale"}}`, encodeURIComponent(String(toLocale)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all available locales for the specified submitted draft
         * @summary Get submitted draft locales
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftGetLocalesById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submittedDraftGetLocalesById', 'id', id)
            const localVarPath = `/@apostrophecms/submitted-draft/{_id}/locales`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update localized versions of submitted drafts for different languages/regions
         * @summary Localize submitted drafts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftLocalize: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/submitted-draft/localize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a localized version of the specified submitted draft for a specific language/region
         * @summary Localize submitted draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftLocalizeById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submittedDraftLocalizeById', 'id', id)
            const localVarPath = `/@apostrophecms/submitted-draft/{_id}/localize`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially update a specific submitted draft by ID using PATCH semantics
         * @summary Update submitted draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {SubmittedDraftPatchByIdRequest} submittedDraftPatchByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftPatchById: async (id: string, submittedDraftPatchByIdRequest: SubmittedDraftPatchByIdRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submittedDraftPatchById', 'id', id)
            // verify required parameter 'submittedDraftPatchByIdRequest' is not null or undefined
            assertParamExists('submittedDraftPatchById', 'submittedDraftPatchByIdRequest', submittedDraftPatchByIdRequest)
            const localVarPath = `/@apostrophecms/submitted-draft/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submittedDraftPatchByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new submitted draft for review workflow (requires contributor permissions or higher)
         * @summary Create submitted draft
         * @param {SubmittedDraftPostRequest} submittedDraftPostRequest 
         * @param {SubmittedDraftPostAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftPost: async (submittedDraftPostRequest: SubmittedDraftPostRequest, aposMode?: SubmittedDraftPostAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submittedDraftPostRequest' is not null or undefined
            assertParamExists('submittedDraftPost', 'submittedDraftPostRequest', submittedDraftPostRequest)
            const localVarPath = `/@apostrophecms/submitted-draft`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submittedDraftPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk publish multiple submitted drafts, moving them from draft status to published content
         * @summary Publish submitted drafts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftPublish: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/submitted-draft/publish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publish the specified submitted draft, moving it from draft status to published content
         * @summary Publish submitted draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftPublishById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submittedDraftPublishById', 'id', id)
            const localVarPath = `/@apostrophecms/submitted-draft/{_id}/publish`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completely replace a specific submitted draft by ID using PUT semantics
         * @summary Replace submitted draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {SubmittedDraftPutByIdRequest} submittedDraftPutByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftPutById: async (id: string, submittedDraftPutByIdRequest: SubmittedDraftPutByIdRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submittedDraftPutById', 'id', id)
            // verify required parameter 'submittedDraftPutByIdRequest' is not null or undefined
            assertParamExists('submittedDraftPutById', 'submittedDraftPutByIdRequest', submittedDraftPutByIdRequest)
            const localVarPath = `/@apostrophecms/submitted-draft/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submittedDraftPutByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore previously archived submitted drafts, returning them to active review queues
         * @summary Restore submitted drafts
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftRestore: async (bulkOperationRequest: BulkOperationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkOperationRequest' is not null or undefined
            assertParamExists('submittedDraftRestore', 'bulkOperationRequest', bulkOperationRequest)
            const localVarPath = `/@apostrophecms/submitted-draft/restore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkOperationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revert the draft version of the specified submitted draft back to its published state
         * @summary Revert draft to published
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftRevertDraftToPublishedById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submittedDraftRevertDraftToPublishedById', 'id', id)
            const localVarPath = `/@apostrophecms/submitted-draft/{_id}/revert-draft-to-published`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revert the published version of the specified submitted draft to its previous published state
         * @summary Revert published to previous
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftRevertPublishedToPreviousById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submittedDraftRevertPublishedToPreviousById', 'id', id)
            const localVarPath = `/@apostrophecms/submitted-draft/{_id}/revert-published-to-previous`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a sharing link or configure sharing permissions for the specified submitted draft
         * @summary Share submitted draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftShareById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submittedDraftShareById', 'id', id)
            const localVarPath = `/@apostrophecms/submitted-draft/{_id}/share`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit the specified draft for review and approval workflow
         * @summary Submit draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftSubmitById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submittedDraftSubmitById', 'id', id)
            const localVarPath = `/@apostrophecms/submitted-draft/{_id}/submit`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unpublish the specified submitted draft, removing it from public visibility while preserving the content
         * @summary Unpublish submitted draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftUnpublishById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('submittedDraftUnpublishById', 'id', id)
            const localVarPath = `/@apostrophecms/submitted-draft/{_id}/unpublish`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubmittedDraftsApi - functional programming interface
 * @export
 */
export const SubmittedDraftsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubmittedDraftsApiAxiosParamCreator(configuration)
    return {
        /**
         * Archive multiple submitted drafts, removing them from active review queues while preserving data
         * @summary Archive submitted drafts
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submittedDraftArchive(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmittedDraftArchive200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submittedDraftArchive(bulkOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmittedDraftsApi.submittedDraftArchive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently delete a specific submitted draft by ID (requires appropriate permissions)
         * @summary Delete submitted draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submittedDraftDeleteById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmittedDraft>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submittedDraftDeleteById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmittedDraftsApi.submittedDraftDeleteById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Dismiss a pending submission for the specified draft, removing it from the review queue
         * @summary Dismiss submission
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submittedDraftDismissSubmissionById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmittedDraft>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submittedDraftDismissSubmissionById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmittedDraftsApi.submittedDraftDismissSubmissionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all submitted drafts in the review queue
         * @summary List submitted drafts
         * @param {SubmittedDraftGetAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submittedDraftGet(aposMode?: SubmittedDraftGetAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmittedDraftGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submittedDraftGet(aposMode, aposLocale, renderAreas, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmittedDraftsApi.submittedDraftGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific submitted draft by ID (requires appropriate permissions)
         * @summary Get submitted draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submittedDraftGetById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmittedDraft>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submittedDraftGetById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmittedDraftsApi.submittedDraftGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the specified submitted draft in a specific locale
         * @summary Get submitted draft locale
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} toLocale Target locale code (e.g., en:us:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submittedDraftGetLocaleById(id: string, toLocale: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmittedDraft>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submittedDraftGetLocaleById(id, toLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmittedDraftsApi.submittedDraftGetLocaleById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all available locales for the specified submitted draft
         * @summary Get submitted draft locales
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submittedDraftGetLocalesById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submittedDraftGetLocalesById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmittedDraftsApi.submittedDraftGetLocalesById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or update localized versions of submitted drafts for different languages/regions
         * @summary Localize submitted drafts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submittedDraftLocalize(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmittedDraftLocalize200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submittedDraftLocalize(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmittedDraftsApi.submittedDraftLocalize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a localized version of the specified submitted draft for a specific language/region
         * @summary Localize submitted draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submittedDraftLocalizeById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmittedDraft>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submittedDraftLocalizeById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmittedDraftsApi.submittedDraftLocalizeById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update a specific submitted draft by ID using PATCH semantics
         * @summary Update submitted draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {SubmittedDraftPatchByIdRequest} submittedDraftPatchByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submittedDraftPatchById(id: string, submittedDraftPatchByIdRequest: SubmittedDraftPatchByIdRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmittedDraft>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submittedDraftPatchById(id, submittedDraftPatchByIdRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmittedDraftsApi.submittedDraftPatchById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new submitted draft for review workflow (requires contributor permissions or higher)
         * @summary Create submitted draft
         * @param {SubmittedDraftPostRequest} submittedDraftPostRequest 
         * @param {SubmittedDraftPostAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submittedDraftPost(submittedDraftPostRequest: SubmittedDraftPostRequest, aposMode?: SubmittedDraftPostAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmittedDraft>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submittedDraftPost(submittedDraftPostRequest, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmittedDraftsApi.submittedDraftPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Bulk publish multiple submitted drafts, moving them from draft status to published content
         * @summary Publish submitted drafts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submittedDraftPublish(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmittedDraftPublish200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submittedDraftPublish(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmittedDraftsApi.submittedDraftPublish']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Publish the specified submitted draft, moving it from draft status to published content
         * @summary Publish submitted draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submittedDraftPublishById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmittedDraft>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submittedDraftPublishById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmittedDraftsApi.submittedDraftPublishById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Completely replace a specific submitted draft by ID using PUT semantics
         * @summary Replace submitted draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {SubmittedDraftPutByIdRequest} submittedDraftPutByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submittedDraftPutById(id: string, submittedDraftPutByIdRequest: SubmittedDraftPutByIdRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmittedDraft>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submittedDraftPutById(id, submittedDraftPutByIdRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmittedDraftsApi.submittedDraftPutById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restore previously archived submitted drafts, returning them to active review queues
         * @summary Restore submitted drafts
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submittedDraftRestore(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmittedDraftRestore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submittedDraftRestore(bulkOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmittedDraftsApi.submittedDraftRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revert the draft version of the specified submitted draft back to its published state
         * @summary Revert draft to published
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submittedDraftRevertDraftToPublishedById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmittedDraft>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submittedDraftRevertDraftToPublishedById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmittedDraftsApi.submittedDraftRevertDraftToPublishedById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revert the published version of the specified submitted draft to its previous published state
         * @summary Revert published to previous
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submittedDraftRevertPublishedToPreviousById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmittedDraft>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submittedDraftRevertPublishedToPreviousById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmittedDraftsApi.submittedDraftRevertPublishedToPreviousById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate a sharing link or configure sharing permissions for the specified submitted draft
         * @summary Share submitted draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submittedDraftShareById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmittedDraft>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submittedDraftShareById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmittedDraftsApi.submittedDraftShareById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit the specified draft for review and approval workflow
         * @summary Submit draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submittedDraftSubmitById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmittedDraft>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submittedDraftSubmitById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmittedDraftsApi.submittedDraftSubmitById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unpublish the specified submitted draft, removing it from public visibility while preserving the content
         * @summary Unpublish submitted draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submittedDraftUnpublishById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmittedDraft>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submittedDraftUnpublishById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubmittedDraftsApi.submittedDraftUnpublishById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubmittedDraftsApi - factory interface
 * @export
 */
export const SubmittedDraftsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubmittedDraftsApiFp(configuration)
    return {
        /**
         * Archive multiple submitted drafts, removing them from active review queues while preserving data
         * @summary Archive submitted drafts
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftArchive(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<SubmittedDraftArchive200Response> {
            return localVarFp.submittedDraftArchive(bulkOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently delete a specific submitted draft by ID (requires appropriate permissions)
         * @summary Delete submitted draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftDeleteById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SubmittedDraft> {
            return localVarFp.submittedDraftDeleteById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Dismiss a pending submission for the specified draft, removing it from the review queue
         * @summary Dismiss submission
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftDismissSubmissionById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SubmittedDraft> {
            return localVarFp.submittedDraftDismissSubmissionById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all submitted drafts in the review queue
         * @summary List submitted drafts
         * @param {SubmittedDraftGetAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftGet(aposMode?: SubmittedDraftGetAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<SubmittedDraftGet200Response> {
            return localVarFp.submittedDraftGet(aposMode, aposLocale, renderAreas, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific submitted draft by ID (requires appropriate permissions)
         * @summary Get submitted draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftGetById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SubmittedDraft> {
            return localVarFp.submittedDraftGetById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the specified submitted draft in a specific locale
         * @summary Get submitted draft locale
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} toLocale Target locale code (e.g., en:us:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftGetLocaleById(id: string, toLocale: string, options?: RawAxiosRequestConfig): AxiosPromise<SubmittedDraft> {
            return localVarFp.submittedDraftGetLocaleById(id, toLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all available locales for the specified submitted draft
         * @summary Get submitted draft locales
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftGetLocalesById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.submittedDraftGetLocalesById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update localized versions of submitted drafts for different languages/regions
         * @summary Localize submitted drafts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftLocalize(options?: RawAxiosRequestConfig): AxiosPromise<SubmittedDraftLocalize200Response> {
            return localVarFp.submittedDraftLocalize(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a localized version of the specified submitted draft for a specific language/region
         * @summary Localize submitted draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftLocalizeById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SubmittedDraft> {
            return localVarFp.submittedDraftLocalizeById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Partially update a specific submitted draft by ID using PATCH semantics
         * @summary Update submitted draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {SubmittedDraftPatchByIdRequest} submittedDraftPatchByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftPatchById(id: string, submittedDraftPatchByIdRequest: SubmittedDraftPatchByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<SubmittedDraft> {
            return localVarFp.submittedDraftPatchById(id, submittedDraftPatchByIdRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new submitted draft for review workflow (requires contributor permissions or higher)
         * @summary Create submitted draft
         * @param {SubmittedDraftPostRequest} submittedDraftPostRequest 
         * @param {SubmittedDraftPostAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftPost(submittedDraftPostRequest: SubmittedDraftPostRequest, aposMode?: SubmittedDraftPostAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<SubmittedDraft> {
            return localVarFp.submittedDraftPost(submittedDraftPostRequest, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Bulk publish multiple submitted drafts, moving them from draft status to published content
         * @summary Publish submitted drafts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftPublish(options?: RawAxiosRequestConfig): AxiosPromise<SubmittedDraftPublish200Response> {
            return localVarFp.submittedDraftPublish(options).then((request) => request(axios, basePath));
        },
        /**
         * Publish the specified submitted draft, moving it from draft status to published content
         * @summary Publish submitted draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftPublishById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SubmittedDraft> {
            return localVarFp.submittedDraftPublishById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Completely replace a specific submitted draft by ID using PUT semantics
         * @summary Replace submitted draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {SubmittedDraftPutByIdRequest} submittedDraftPutByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftPutById(id: string, submittedDraftPutByIdRequest: SubmittedDraftPutByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<SubmittedDraft> {
            return localVarFp.submittedDraftPutById(id, submittedDraftPutByIdRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore previously archived submitted drafts, returning them to active review queues
         * @summary Restore submitted drafts
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftRestore(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<SubmittedDraftRestore200Response> {
            return localVarFp.submittedDraftRestore(bulkOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Revert the draft version of the specified submitted draft back to its published state
         * @summary Revert draft to published
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftRevertDraftToPublishedById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SubmittedDraft> {
            return localVarFp.submittedDraftRevertDraftToPublishedById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Revert the published version of the specified submitted draft to its previous published state
         * @summary Revert published to previous
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftRevertPublishedToPreviousById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SubmittedDraft> {
            return localVarFp.submittedDraftRevertPublishedToPreviousById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a sharing link or configure sharing permissions for the specified submitted draft
         * @summary Share submitted draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftShareById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SubmittedDraft> {
            return localVarFp.submittedDraftShareById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit the specified draft for review and approval workflow
         * @summary Submit draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftSubmitById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SubmittedDraft> {
            return localVarFp.submittedDraftSubmitById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Unpublish the specified submitted draft, removing it from public visibility while preserving the content
         * @summary Unpublish submitted draft
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submittedDraftUnpublishById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SubmittedDraft> {
            return localVarFp.submittedDraftUnpublishById(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubmittedDraftsApi - object-oriented interface
 * @export
 * @class SubmittedDraftsApi
 * @extends {BaseAPI}
 */
export class SubmittedDraftsApi extends BaseAPI {
    /**
     * Archive multiple submitted drafts, removing them from active review queues while preserving data
     * @summary Archive submitted drafts
     * @param {BulkOperationRequest} bulkOperationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmittedDraftsApi
     */
    public submittedDraftArchive(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig) {
        return SubmittedDraftsApiFp(this.configuration).submittedDraftArchive(bulkOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently delete a specific submitted draft by ID (requires appropriate permissions)
     * @summary Delete submitted draft
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmittedDraftsApi
     */
    public submittedDraftDeleteById(id: string, options?: RawAxiosRequestConfig) {
        return SubmittedDraftsApiFp(this.configuration).submittedDraftDeleteById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Dismiss a pending submission for the specified draft, removing it from the review queue
     * @summary Dismiss submission
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmittedDraftsApi
     */
    public submittedDraftDismissSubmissionById(id: string, options?: RawAxiosRequestConfig) {
        return SubmittedDraftsApiFp(this.configuration).submittedDraftDismissSubmissionById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all submitted drafts in the review queue
     * @summary List submitted drafts
     * @param {SubmittedDraftGetAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmittedDraftsApi
     */
    public submittedDraftGet(aposMode?: SubmittedDraftGetAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig) {
        return SubmittedDraftsApiFp(this.configuration).submittedDraftGet(aposMode, aposLocale, renderAreas, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific submitted draft by ID (requires appropriate permissions)
     * @summary Get submitted draft
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmittedDraftsApi
     */
    public submittedDraftGetById(id: string, options?: RawAxiosRequestConfig) {
        return SubmittedDraftsApiFp(this.configuration).submittedDraftGetById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the specified submitted draft in a specific locale
     * @summary Get submitted draft locale
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {string} toLocale Target locale code (e.g., en:us:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmittedDraftsApi
     */
    public submittedDraftGetLocaleById(id: string, toLocale: string, options?: RawAxiosRequestConfig) {
        return SubmittedDraftsApiFp(this.configuration).submittedDraftGetLocaleById(id, toLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all available locales for the specified submitted draft
     * @summary Get submitted draft locales
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmittedDraftsApi
     */
    public submittedDraftGetLocalesById(id: string, options?: RawAxiosRequestConfig) {
        return SubmittedDraftsApiFp(this.configuration).submittedDraftGetLocalesById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update localized versions of submitted drafts for different languages/regions
     * @summary Localize submitted drafts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmittedDraftsApi
     */
    public submittedDraftLocalize(options?: RawAxiosRequestConfig) {
        return SubmittedDraftsApiFp(this.configuration).submittedDraftLocalize(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a localized version of the specified submitted draft for a specific language/region
     * @summary Localize submitted draft
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmittedDraftsApi
     */
    public submittedDraftLocalizeById(id: string, options?: RawAxiosRequestConfig) {
        return SubmittedDraftsApiFp(this.configuration).submittedDraftLocalizeById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update a specific submitted draft by ID using PATCH semantics
     * @summary Update submitted draft
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {SubmittedDraftPatchByIdRequest} submittedDraftPatchByIdRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmittedDraftsApi
     */
    public submittedDraftPatchById(id: string, submittedDraftPatchByIdRequest: SubmittedDraftPatchByIdRequest, options?: RawAxiosRequestConfig) {
        return SubmittedDraftsApiFp(this.configuration).submittedDraftPatchById(id, submittedDraftPatchByIdRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new submitted draft for review workflow (requires contributor permissions or higher)
     * @summary Create submitted draft
     * @param {SubmittedDraftPostRequest} submittedDraftPostRequest 
     * @param {SubmittedDraftPostAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmittedDraftsApi
     */
    public submittedDraftPost(submittedDraftPostRequest: SubmittedDraftPostRequest, aposMode?: SubmittedDraftPostAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return SubmittedDraftsApiFp(this.configuration).submittedDraftPost(submittedDraftPostRequest, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Bulk publish multiple submitted drafts, moving them from draft status to published content
     * @summary Publish submitted drafts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmittedDraftsApi
     */
    public submittedDraftPublish(options?: RawAxiosRequestConfig) {
        return SubmittedDraftsApiFp(this.configuration).submittedDraftPublish(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Publish the specified submitted draft, moving it from draft status to published content
     * @summary Publish submitted draft
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmittedDraftsApi
     */
    public submittedDraftPublishById(id: string, options?: RawAxiosRequestConfig) {
        return SubmittedDraftsApiFp(this.configuration).submittedDraftPublishById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completely replace a specific submitted draft by ID using PUT semantics
     * @summary Replace submitted draft
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {SubmittedDraftPutByIdRequest} submittedDraftPutByIdRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmittedDraftsApi
     */
    public submittedDraftPutById(id: string, submittedDraftPutByIdRequest: SubmittedDraftPutByIdRequest, options?: RawAxiosRequestConfig) {
        return SubmittedDraftsApiFp(this.configuration).submittedDraftPutById(id, submittedDraftPutByIdRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore previously archived submitted drafts, returning them to active review queues
     * @summary Restore submitted drafts
     * @param {BulkOperationRequest} bulkOperationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmittedDraftsApi
     */
    public submittedDraftRestore(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig) {
        return SubmittedDraftsApiFp(this.configuration).submittedDraftRestore(bulkOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revert the draft version of the specified submitted draft back to its published state
     * @summary Revert draft to published
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmittedDraftsApi
     */
    public submittedDraftRevertDraftToPublishedById(id: string, options?: RawAxiosRequestConfig) {
        return SubmittedDraftsApiFp(this.configuration).submittedDraftRevertDraftToPublishedById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revert the published version of the specified submitted draft to its previous published state
     * @summary Revert published to previous
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmittedDraftsApi
     */
    public submittedDraftRevertPublishedToPreviousById(id: string, options?: RawAxiosRequestConfig) {
        return SubmittedDraftsApiFp(this.configuration).submittedDraftRevertPublishedToPreviousById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a sharing link or configure sharing permissions for the specified submitted draft
     * @summary Share submitted draft
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmittedDraftsApi
     */
    public submittedDraftShareById(id: string, options?: RawAxiosRequestConfig) {
        return SubmittedDraftsApiFp(this.configuration).submittedDraftShareById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit the specified draft for review and approval workflow
     * @summary Submit draft
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmittedDraftsApi
     */
    public submittedDraftSubmitById(id: string, options?: RawAxiosRequestConfig) {
        return SubmittedDraftsApiFp(this.configuration).submittedDraftSubmitById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unpublish the specified submitted draft, removing it from public visibility while preserving the content
     * @summary Unpublish submitted draft
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmittedDraftsApi
     */
    public submittedDraftUnpublishById(id: string, options?: RawAxiosRequestConfig) {
        return SubmittedDraftsApiFp(this.configuration).submittedDraftUnpublishById(id, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SubmittedDraftGetAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type SubmittedDraftGetAposModeEnum = typeof SubmittedDraftGetAposModeEnum[keyof typeof SubmittedDraftGetAposModeEnum];
/**
 * @export
 */
export const SubmittedDraftPostAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type SubmittedDraftPostAposModeEnum = typeof SubmittedDraftPostAposModeEnum[keyof typeof SubmittedDraftPostAposModeEnum];


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Archive multiple users, making them inactive while preserving their data
         * @summary Archive users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userArchive: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/user/archive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user account with the specified properties
         * @summary Create user
         * @param {UserCreateRequest} userCreateRequest 
         * @param {UserCreateAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreate: async (userCreateRequest: UserCreateRequest, aposMode?: UserCreateAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreateRequest' is not null or undefined
            assertParamExists('userCreate', 'userCreateRequest', userCreateRequest)
            const localVarPath = `/@apostrophecms/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete a specific user by ID (requires appropriate permissions)
         * @summary Delete user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userDeleteById', 'id', id)
            const localVarPath = `/@apostrophecms/user/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Dismiss a pending submission for the specified user, removing it from the review queue
         * @summary Dismiss user submission
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDismissSubmissionById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userDismissSubmissionById', 'id', id)
            const localVarPath = `/@apostrophecms/user/{_id}/dismiss-submission`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific user by ID
         * @summary Get user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {UserGetByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetById: async (id: string, aposMode?: UserGetByIdAposModeEnum, aposLocale?: string, renderAreas?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userGetById', 'id', id)
            const localVarPath = `/@apostrophecms/user/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }

            if (renderAreas !== undefined) {
                localVarQueryParameter['render-areas'] = renderAreas;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the specified user in a specific locale
         * @summary Get user locale
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} toLocale Target locale code (e.g., en:us:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetLocaleById: async (id: string, toLocale: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userGetLocaleById', 'id', id)
            // verify required parameter 'toLocale' is not null or undefined
            assertParamExists('userGetLocaleById', 'toLocale', toLocale)
            const localVarPath = `/@apostrophecms/user/{_id}/locale/{toLocale}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"toLocale"}}`, encodeURIComponent(String(toLocale)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all available locales for the specified user
         * @summary Get user locales
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetLocalesById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userGetLocalesById', 'id', id)
            const localVarPath = `/@apostrophecms/user/{_id}/locales`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of users with optional filtering, sorting, and pagination
         * @summary List users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update localized versions of users for different languages/regions
         * @summary Localize users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLocalize: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/user/localize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a localized version of the specified user for a specific language/region
         * @summary Localize user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLocalizeById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userLocalizeById', 'id', id)
            const localVarPath = `/@apostrophecms/user/{_id}/localize`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Partially update a specific user by ID using PATCH semantics
         * @summary Update user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {UserPatchByIdRequest} userPatchByIdRequest 
         * @param {UserPatchByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPatchById: async (id: string, userPatchByIdRequest: UserPatchByIdRequest, aposMode?: UserPatchByIdAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userPatchById', 'id', id)
            // verify required parameter 'userPatchByIdRequest' is not null or undefined
            assertParamExists('userPatchById', 'userPatchByIdRequest', userPatchByIdRequest)
            const localVarPath = `/@apostrophecms/user/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPatchByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publish multiple users, making them live and visible
         * @summary Publish users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPublish: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/@apostrophecms/user/publish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publish the specified user, making them live and visible
         * @summary Publish user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPublishById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userPublishById', 'id', id)
            const localVarPath = `/@apostrophecms/user/{_id}/publish`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completely replace a specific user by ID using PUT semantics
         * @summary Replace user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {UserPutByIdRequest} userPutByIdRequest 
         * @param {UserPutByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPutById: async (id: string, userPutByIdRequest: UserPutByIdRequest, aposMode?: UserPutByIdAposModeEnum, aposLocale?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userPutById', 'id', id)
            // verify required parameter 'userPutByIdRequest' is not null or undefined
            assertParamExists('userPutById', 'userPutByIdRequest', userPutByIdRequest)
            const localVarPath = `/@apostrophecms/user/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (aposMode !== undefined) {
                localVarQueryParameter['aposMode'] = aposMode;
            }

            if (aposLocale !== undefined) {
                localVarQueryParameter['aposLocale'] = aposLocale;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPutByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore previously archived users, making them active again
         * @summary Restore users
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRestore: async (bulkOperationRequest: BulkOperationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkOperationRequest' is not null or undefined
            assertParamExists('userRestore', 'bulkOperationRequest', bulkOperationRequest)
            const localVarPath = `/@apostrophecms/user/restore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkOperationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revert the draft version of the specified user back to its published state
         * @summary Revert draft to published
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRevertDraftToPublishedById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userRevertDraftToPublishedById', 'id', id)
            const localVarPath = `/@apostrophecms/user/{_id}/revert-draft-to-published`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revert the published version of the specified user to its previous published state
         * @summary Revert published to previous
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRevertPublishedToPreviousById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userRevertPublishedToPreviousById', 'id', id)
            const localVarPath = `/@apostrophecms/user/{_id}/revert-published-to-previous`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a sharing link or configure sharing permissions for the specified user
         * @summary Share user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userShareById', 'id', id)
            const localVarPath = `/@apostrophecms/user/{_id}/share`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit the specified user for review and approval workflow
         * @summary Submit user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSubmitById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userSubmitById', 'id', id)
            const localVarPath = `/@apostrophecms/user/{_id}/submit`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unpublish the specified user, removing them from public visibility while preserving the content
         * @summary Unpublish user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUnpublishById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userUnpublishById', 'id', id)
            const localVarPath = `/@apostrophecms/user/{_id}/unpublish`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SessionAuth required

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarQueryParameter, "apikey", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Archive multiple users, making them inactive while preserving their data
         * @summary Archive users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userArchive(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageArchive200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userArchive(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userArchive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new user account with the specified properties
         * @summary Create user
         * @param {UserCreateRequest} userCreateRequest 
         * @param {UserCreateAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCreate(userCreateRequest: UserCreateRequest, aposMode?: UserCreateAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCreate(userCreateRequest, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently delete a specific user by ID (requires appropriate permissions)
         * @summary Delete user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDeleteById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userDeleteById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userDeleteById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Dismiss a pending submission for the specified user, removing it from the review queue
         * @summary Dismiss user submission
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDismissSubmissionById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userDismissSubmissionById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userDismissSubmissionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific user by ID
         * @summary Get user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {UserGetByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetById(id: string, aposMode?: UserGetByIdAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetById(id, aposMode, aposLocale, renderAreas, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the specified user in a specific locale
         * @summary Get user locale
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} toLocale Target locale code (e.g., en:us:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetLocaleById(id: string, toLocale: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetLocaleById(id, toLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userGetLocaleById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all available locales for the specified user
         * @summary Get user locales
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetLocalesById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetLocalesById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userGetLocalesById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of users with optional filtering, sorting, and pagination
         * @summary List users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or update localized versions of users for different languages/regions
         * @summary Localize users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLocalize(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLocalize(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userLocalize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a localized version of the specified user for a specific language/region
         * @summary Localize user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLocalizeById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLocalizeById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userLocalizeById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Partially update a specific user by ID using PATCH semantics
         * @summary Update user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {UserPatchByIdRequest} userPatchByIdRequest 
         * @param {UserPatchByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userPatchById(id: string, userPatchByIdRequest: UserPatchByIdRequest, aposMode?: UserPatchByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userPatchById(id, userPatchByIdRequest, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userPatchById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Publish multiple users, making them live and visible
         * @summary Publish users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userPublish(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userPublish(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userPublish']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Publish the specified user, making them live and visible
         * @summary Publish user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userPublishById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userPublishById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userPublishById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Completely replace a specific user by ID using PUT semantics
         * @summary Replace user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {UserPutByIdRequest} userPutByIdRequest 
         * @param {UserPutByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userPutById(id: string, userPutByIdRequest: UserPutByIdRequest, aposMode?: UserPutByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userPutById(id, userPutByIdRequest, aposMode, aposLocale, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userPutById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restore previously archived users, making them active again
         * @summary Restore users
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userRestore(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userRestore(bulkOperationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userRestore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revert the draft version of the specified user back to its published state
         * @summary Revert draft to published
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userRevertDraftToPublishedById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userRevertDraftToPublishedById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userRevertDraftToPublishedById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revert the published version of the specified user to its previous published state
         * @summary Revert published to previous
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userRevertPublishedToPreviousById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userRevertPublishedToPreviousById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userRevertPublishedToPreviousById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate a sharing link or configure sharing permissions for the specified user
         * @summary Share user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShareById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userShareById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userShareById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit the specified user for review and approval workflow
         * @summary Submit user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSubmitById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSubmitById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userSubmitById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unpublish the specified user, removing them from public visibility while preserving the content
         * @summary Unpublish user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUnpublishById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUnpublishById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userUnpublishById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Archive multiple users, making them inactive while preserving their data
         * @summary Archive users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userArchive(options?: RawAxiosRequestConfig): AxiosPromise<PageArchive200Response> {
            return localVarFp.userArchive(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user account with the specified properties
         * @summary Create user
         * @param {UserCreateRequest} userCreateRequest 
         * @param {UserCreateAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreate(userCreateRequest: UserCreateRequest, aposMode?: UserCreateAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.userCreate(userCreateRequest, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently delete a specific user by ID (requires appropriate permissions)
         * @summary Delete user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.userDeleteById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Dismiss a pending submission for the specified user, removing it from the review queue
         * @summary Dismiss user submission
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDismissSubmissionById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.userDismissSubmissionById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific user by ID
         * @summary Get user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {UserGetByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetById(id: string, aposMode?: UserGetByIdAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.userGetById(id, aposMode, aposLocale, renderAreas, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the specified user in a specific locale
         * @summary Get user locale
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {string} toLocale Target locale code (e.g., en:us:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetLocaleById(id: string, toLocale: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.userGetLocaleById(id, toLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all available locales for the specified user
         * @summary Get user locales
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetLocalesById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.userGetLocalesById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of users with optional filtering, sorting, and pagination
         * @summary List users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userList(options?: RawAxiosRequestConfig): AxiosPromise<UserList200Response> {
            return localVarFp.userList(options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update localized versions of users for different languages/regions
         * @summary Localize users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLocalize(options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.userLocalize(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a localized version of the specified user for a specific language/region
         * @summary Localize user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLocalizeById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.userLocalizeById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Partially update a specific user by ID using PATCH semantics
         * @summary Update user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {UserPatchByIdRequest} userPatchByIdRequest 
         * @param {UserPatchByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPatchById(id: string, userPatchByIdRequest: UserPatchByIdRequest, aposMode?: UserPatchByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.userPatchById(id, userPatchByIdRequest, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Publish multiple users, making them live and visible
         * @summary Publish users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPublish(options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.userPublish(options).then((request) => request(axios, basePath));
        },
        /**
         * Publish the specified user, making them live and visible
         * @summary Publish user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPublishById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.userPublishById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Completely replace a specific user by ID using PUT semantics
         * @summary Replace user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {UserPutByIdRequest} userPutByIdRequest 
         * @param {UserPutByIdAposModeEnum} [aposMode] Request draft or published version of content
         * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPutById(id: string, userPutByIdRequest: UserPutByIdRequest, aposMode?: UserPutByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.userPutById(id, userPutByIdRequest, aposMode, aposLocale, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore previously archived users, making them active again
         * @summary Restore users
         * @param {BulkOperationRequest} bulkOperationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRestore(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.userRestore(bulkOperationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Revert the draft version of the specified user back to its published state
         * @summary Revert draft to published
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRevertDraftToPublishedById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.userRevertDraftToPublishedById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Revert the published version of the specified user to its previous published state
         * @summary Revert published to previous
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRevertPublishedToPreviousById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.userRevertPublishedToPreviousById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a sharing link or configure sharing permissions for the specified user
         * @summary Share user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShareById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.userShareById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit the specified user for review and approval workflow
         * @summary Submit user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSubmitById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.userSubmitById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Unpublish the specified user, removing them from public visibility while preserving the content
         * @summary Unpublish user
         * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUnpublishById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.userUnpublishById(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Archive multiple users, making them inactive while preserving their data
     * @summary Archive users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userArchive(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userArchive(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user account with the specified properties
     * @summary Create user
     * @param {UserCreateRequest} userCreateRequest 
     * @param {UserCreateAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userCreate(userCreateRequest: UserCreateRequest, aposMode?: UserCreateAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userCreate(userCreateRequest, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently delete a specific user by ID (requires appropriate permissions)
     * @summary Delete user
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userDeleteById(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userDeleteById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Dismiss a pending submission for the specified user, removing it from the review queue
     * @summary Dismiss user submission
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userDismissSubmissionById(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userDismissSubmissionById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific user by ID
     * @summary Get user
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {UserGetByIdAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {boolean} [renderAreas] ðŸ’¡ Render widget areas as HTML instead of returning raw widget data - useful for hybrid architectures
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userGetById(id: string, aposMode?: UserGetByIdAposModeEnum, aposLocale?: string, renderAreas?: boolean, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userGetById(id, aposMode, aposLocale, renderAreas, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the specified user in a specific locale
     * @summary Get user locale
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {string} toLocale Target locale code (e.g., en:us:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userGetLocaleById(id: string, toLocale: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userGetLocaleById(id, toLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all available locales for the specified user
     * @summary Get user locales
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userGetLocalesById(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userGetLocalesById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of users with optional filtering, sorting, and pagination
     * @summary List users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userList(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update localized versions of users for different languages/regions
     * @summary Localize users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userLocalize(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userLocalize(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a localized version of the specified user for a specific language/region
     * @summary Localize user
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userLocalizeById(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userLocalizeById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Partially update a specific user by ID using PATCH semantics
     * @summary Update user
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {UserPatchByIdRequest} userPatchByIdRequest 
     * @param {UserPatchByIdAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userPatchById(id: string, userPatchByIdRequest: UserPatchByIdRequest, aposMode?: UserPatchByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userPatchById(id, userPatchByIdRequest, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Publish multiple users, making them live and visible
     * @summary Publish users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userPublish(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userPublish(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Publish the specified user, making them live and visible
     * @summary Publish user
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userPublishById(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userPublishById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completely replace a specific user by ID using PUT semantics
     * @summary Replace user
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {UserPutByIdRequest} userPutByIdRequest 
     * @param {UserPutByIdAposModeEnum} [aposMode] Request draft or published version of content
     * @param {string} [aposLocale] Locale for internationalization (e.g., \&#39;en\&#39;, \&#39;fr\&#39;, \&#39;es\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userPutById(id: string, userPutByIdRequest: UserPutByIdRequest, aposMode?: UserPutByIdAposModeEnum, aposLocale?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userPutById(id, userPutByIdRequest, aposMode, aposLocale, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore previously archived users, making them active again
     * @summary Restore users
     * @param {BulkOperationRequest} bulkOperationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userRestore(bulkOperationRequest: BulkOperationRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userRestore(bulkOperationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revert the draft version of the specified user back to its published state
     * @summary Revert draft to published
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userRevertDraftToPublishedById(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userRevertDraftToPublishedById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revert the published version of the specified user to its previous published state
     * @summary Revert published to previous
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userRevertPublishedToPreviousById(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userRevertPublishedToPreviousById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a sharing link or configure sharing permissions for the specified user
     * @summary Share user
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userShareById(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userShareById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit the specified user for review and approval workflow
     * @summary Submit user
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userSubmitById(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userSubmitById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unpublish the specified user, removing them from public visibility while preserving the content
     * @summary Unpublish user
     * @param {string} id Document ID (can include mode and locale, e.g., id:en:published)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userUnpublishById(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userUnpublishById(id, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const UserCreateAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type UserCreateAposModeEnum = typeof UserCreateAposModeEnum[keyof typeof UserCreateAposModeEnum];
/**
 * @export
 */
export const UserGetByIdAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type UserGetByIdAposModeEnum = typeof UserGetByIdAposModeEnum[keyof typeof UserGetByIdAposModeEnum];
/**
 * @export
 */
export const UserPatchByIdAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type UserPatchByIdAposModeEnum = typeof UserPatchByIdAposModeEnum[keyof typeof UserPatchByIdAposModeEnum];
/**
 * @export
 */
export const UserPutByIdAposModeEnum = {
    Draft: 'draft',
    Published: 'published'
} as const;
export type UserPutByIdAposModeEnum = typeof UserPutByIdAposModeEnum[keyof typeof UserPutByIdAposModeEnum];


