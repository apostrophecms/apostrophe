/* tslint:disable */
/* eslint-disable */
/**
 * ApostropheCMS REST API
 * **ðŸš€ The headless CMS that developers actually want to use**  **For production use:** Download this YAML file and update the server URL and cookie names to match your setup.  The ApostropheCMS REST API allows you to create, read, update, and delete content programmatically. Perfect for building modern websites, mobile apps, and any digital experience that needs flexible content management.  ## Quick Start Guide 1. **Authentication**: Use the login endpoint to get a bearer token or session cookie 2. **Get Content**: Start with `/@apostrophecms/page` to fetch your page structure 3. **Media Files**: Upload files via `/@apostrophecms/attachment/upload` 4. **Internationalization**: Use `/@apostrophecms/i18n` to localize your content  ## Content Architecture ApostropheCMS uses a flexible \"pieces\" system for content types. While the core system provides essential pieces like users and global content, most projects define custom piece types like articles, events, or products using the `@apostrophecms/piece-type` module.  ## Built-in Piece Types - `@apostrophecms/user` - User accounts and profiles - `@apostrophecms/global` - Site-wide content (customizable with additional fields) - `@apostrophecms/image` - Image file management - `@apostrophecms/file` - General file management (PDFs, documents, etc.)  ## Built-in Tag Types - `@apostrophecms/image-tag` - Tags for organizing images - `@apostrophecms/file-tag` - Tags for organizing files  ## Authentication Methods - **Bearer Token**: Recommended for API clients and SPAs - **Session Cookie**: For traditional web applications - **API Key**: For server-to-server communication  ## Rate Limiting API requests are rate-limited to prevent abuse. See response headers for current limits. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@apostrophecms.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export interface ConfigurationParameters {
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    username?: string;
    password?: string;
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    basePath?: string;
    serverIndex?: number;
    baseOptions?: any;
    formDataCtor?: new () => any;
}

export class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username?: string;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password?: string;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath?: string;
    /**
     * override server index
     *
     * @type {number}
     * @memberof Configuration
     */
    serverIndex?: number;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions?: any;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor?: new () => any;

    constructor(param: ConfigurationParameters = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.serverIndex = param.serverIndex;
        this.baseOptions = {
            ...param.baseOptions,
            headers: {
                ...param.baseOptions?.headers,
            },
        };
        this.formDataCtor = param.formDataCtor;
    }

    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    public isJsonMime(mime: string): boolean {
        const jsonMime: RegExp = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
}
